{"ast":null,"code":"import { pushAtSortPosition } from 'array-push-at-sort-position';\nexport const doNothing = _input => {};\nexport const insertFirst = input => {\n  input.previousResults.unshift(input.changeEvent.doc);\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n  }\n};\nexport const insertLast = input => {\n  input.previousResults.push(input.changeEvent.doc);\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n  }\n};\nexport const removeFirstItem = input => {\n  const first = input.previousResults.shift();\n  if (input.keyDocumentMap && first) {\n    input.keyDocumentMap.delete(first[input.queryParams.primaryKey]);\n  }\n};\nexport const removeLastItem = input => {\n  const last = input.previousResults.pop();\n  if (input.keyDocumentMap && last) {\n    input.keyDocumentMap.delete(last[input.queryParams.primaryKey]);\n  }\n};\nexport const removeFirstInsertLast = input => {\n  removeFirstItem(input);\n  insertLast(input);\n};\nexport const removeLastInsertFirst = input => {\n  removeLastItem(input);\n  insertFirst(input);\n};\nexport const removeFirstInsertFirst = input => {\n  removeFirstItem(input);\n  insertFirst(input);\n};\nexport const removeLastInsertLast = input => {\n  removeLastItem(input);\n  insertLast(input);\n};\nexport const removeExisting = input => {\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.delete(input.changeEvent.id);\n  }\n  // find index of document\n  const primary = input.queryParams.primaryKey;\n  const results = input.previousResults;\n  for (let i = 0; i < results.length; i++) {\n    const item = results[i];\n    // remove\n    // console.dir(item);\n    if (item[primary] === input.changeEvent.id) {\n      results.splice(i, 1);\n      break;\n    }\n  }\n};\nexport const replaceExisting = input => {\n  // find index of document\n  const doc = input.changeEvent.doc;\n  const primary = input.queryParams.primaryKey;\n  const results = input.previousResults;\n  for (let i = 0; i < results.length; i++) {\n    const item = results[i];\n    // replace\n    if (item[primary] === input.changeEvent.id) {\n      results[i] = doc;\n      if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(input.changeEvent.id, doc);\n      }\n      break;\n    }\n  }\n};\n/**\n * this function always returns wrong results\n * it must be later optimised out\n * otherwise there is something broken\n */\nexport const alwaysWrong = input => {\n  const wrongHuman = {\n    _id: 'wrongHuman' + new Date().getTime()\n  };\n  input.previousResults.length = 0; // clear array\n  input.previousResults.push(wrongHuman);\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.clear();\n    input.keyDocumentMap.set(wrongHuman._id, wrongHuman);\n  }\n};\nexport const insertAtSortPosition = input => {\n  const docId = input.changeEvent.id;\n  const doc = input.changeEvent.doc;\n  if (input.keyDocumentMap) {\n    if (input.keyDocumentMap.has(docId)) {\n      /**\n       * If document is already in results,\n       * we cannot add it again because it would throw on non-deterministic ordering.\n       */\n      return;\n    }\n    input.keyDocumentMap.set(docId, doc);\n  } else {\n    const isDocInResults = input.previousResults.find(d => d[input.queryParams.primaryKey] === docId);\n    /**\n     * If document is already in results,\n     * we cannot add it again because it would throw on non-deterministic ordering.\n     */\n    if (isDocInResults) {\n      return;\n    }\n  }\n  pushAtSortPosition(input.previousResults, doc, input.queryParams.sortComparator, true);\n};\nexport const removeExistingAndInsertAtSortPosition = input => {\n  removeExisting(input);\n  insertAtSortPosition(input);\n};\nexport const runFullQueryAgain = _input => {\n  throw new Error('Action runFullQueryAgain must be implemented by yourself');\n};\nexport const unknownAction = _input => {\n  throw new Error('Action unknownAction should never be called');\n};","map":{"version":3,"names":["pushAtSortPosition","doNothing","_input","insertFirst","input","previousResults","unshift","changeEvent","doc","keyDocumentMap","set","id","insertLast","push","removeFirstItem","first","shift","delete","queryParams","primaryKey","removeLastItem","last","pop","removeFirstInsertLast","removeLastInsertFirst","removeFirstInsertFirst","removeLastInsertLast","removeExisting","primary","results","i","length","item","splice","replaceExisting","alwaysWrong","wrongHuman","_id","Date","getTime","clear","insertAtSortPosition","docId","has","isDocInResults","find","d","sortComparator","removeExistingAndInsertAtSortPosition","runFullQueryAgain","Error","unknownAction"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/event-reduce-js/dist/es/actions/action-functions.js"],"sourcesContent":["import { pushAtSortPosition } from 'array-push-at-sort-position';\nexport const doNothing = (_input) => { };\nexport const insertFirst = (input) => {\n    input.previousResults.unshift(input.changeEvent.doc);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n    }\n};\nexport const insertLast = (input) => {\n    input.previousResults.push(input.changeEvent.doc);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n    }\n};\nexport const removeFirstItem = (input) => {\n    const first = input.previousResults.shift();\n    if (input.keyDocumentMap && first) {\n        input.keyDocumentMap.delete(first[input.queryParams.primaryKey]);\n    }\n};\nexport const removeLastItem = (input) => {\n    const last = input.previousResults.pop();\n    if (input.keyDocumentMap && last) {\n        input.keyDocumentMap.delete(last[input.queryParams.primaryKey]);\n    }\n};\nexport const removeFirstInsertLast = (input) => {\n    removeFirstItem(input);\n    insertLast(input);\n};\nexport const removeLastInsertFirst = (input) => {\n    removeLastItem(input);\n    insertFirst(input);\n};\nexport const removeFirstInsertFirst = (input) => {\n    removeFirstItem(input);\n    insertFirst(input);\n};\nexport const removeLastInsertLast = (input) => {\n    removeLastItem(input);\n    insertLast(input);\n};\nexport const removeExisting = (input) => {\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.delete(input.changeEvent.id);\n    }\n    // find index of document\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n        const item = results[i];\n        // remove\n        // console.dir(item);\n        if (item[primary] === input.changeEvent.id) {\n            results.splice(i, 1);\n            break;\n        }\n    }\n};\nexport const replaceExisting = (input) => {\n    // find index of document\n    const doc = input.changeEvent.doc;\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n        const item = results[i];\n        // replace\n        if (item[primary] === input.changeEvent.id) {\n            results[i] = doc;\n            if (input.keyDocumentMap) {\n                input.keyDocumentMap.set(input.changeEvent.id, doc);\n            }\n            break;\n        }\n    }\n};\n/**\n * this function always returns wrong results\n * it must be later optimised out\n * otherwise there is something broken\n */\nexport const alwaysWrong = (input) => {\n    const wrongHuman = {\n        _id: 'wrongHuman' + new Date().getTime()\n    };\n    input.previousResults.length = 0; // clear array\n    input.previousResults.push(wrongHuman);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.clear();\n        input.keyDocumentMap.set(wrongHuman._id, wrongHuman);\n    }\n};\nexport const insertAtSortPosition = (input) => {\n    const docId = input.changeEvent.id;\n    const doc = input.changeEvent.doc;\n    if (input.keyDocumentMap) {\n        if (input.keyDocumentMap.has(docId)) {\n            /**\n             * If document is already in results,\n             * we cannot add it again because it would throw on non-deterministic ordering.\n             */\n            return;\n        }\n        input.keyDocumentMap.set(docId, doc);\n    }\n    else {\n        const isDocInResults = input.previousResults.find((d) => d[input.queryParams.primaryKey] === docId);\n        /**\n         * If document is already in results,\n         * we cannot add it again because it would throw on non-deterministic ordering.\n         */\n        if (isDocInResults) {\n            return;\n        }\n    }\n    pushAtSortPosition(input.previousResults, doc, input.queryParams.sortComparator, true);\n};\nexport const removeExistingAndInsertAtSortPosition = (input) => {\n    removeExisting(input);\n    insertAtSortPosition(input);\n};\nexport const runFullQueryAgain = (_input) => {\n    throw new Error('Action runFullQueryAgain must be implemented by yourself');\n};\nexport const unknownAction = (_input) => {\n    throw new Error('Action unknownAction should never be called');\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}