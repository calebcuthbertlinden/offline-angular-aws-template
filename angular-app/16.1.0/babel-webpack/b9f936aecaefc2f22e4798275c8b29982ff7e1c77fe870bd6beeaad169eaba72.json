{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { getDefaultRevision, createRevision, now, flatClone, deepEqual } from '../plugins/utils';\nexport var defaultConflictHandler = function (i, _context) {\n  /**\n   * If the documents are deep equal,\n   * we have no conflict.\n   * On your custom conflict handler you might only\n   * check some properties, like the updatedAt time,\n   * for better performance, because deepEqual is expensive.\n   */\n  if (deepEqual(i.newDocumentState, i.realMasterState)) {\n    return Promise.resolve({\n      isEqual: true\n    });\n  }\n\n  /**\n   * The default conflict handler will always\n   * drop the fork state and use the master state instead.\n   */\n  return Promise.resolve({\n    isEqual: false,\n    documentData: i.realMasterState\n  });\n};\n\n/**\n * Resolves a conflict error or determines that the given document states are equal.\n * Returns the resolved document that must be written to the fork.\n * Then the new document state can be pushed upstream.\n * If document is not in conflict, returns undefined.\n * If error is non-409, it throws an error.\n * Conflicts are only solved in the upstream, never in the downstream.\n */\nexport function resolveConflictError(_x, _x2, _x3) {\n  return _resolveConflictError.apply(this, arguments);\n}\nfunction _resolveConflictError() {\n  _resolveConflictError = _asyncToGenerator(function* (state, input, forkState) {\n    var conflictHandler = state.input.conflictHandler;\n    var conflictHandlerOutput = yield conflictHandler(input, 'replication-resolve-conflict');\n    if (conflictHandlerOutput.isEqual) {\n      /**\n       * Documents are equal,\n       * so this is not a conflict -> do nothing.\n       */\n      return undefined;\n    } else {\n      /**\n       * We have a resolved conflict,\n       * use the resolved document data.\n       */\n      var resolvedDoc = Object.assign({}, conflictHandlerOutput.documentData, {\n        /**\n         * Because the resolved conflict is written to the fork,\n         * we have to keep/update the forks _meta data, not the masters.\n         */\n        _meta: flatClone(forkState._meta),\n        _rev: getDefaultRevision(),\n        _attachments: flatClone(forkState._attachments)\n      });\n      resolvedDoc._meta.lwt = now();\n      resolvedDoc._rev = createRevision(state.input.identifier, forkState);\n      return {\n        resolvedDoc,\n        output: conflictHandlerOutput\n      };\n    }\n  });\n  return _resolveConflictError.apply(this, arguments);\n}","map":{"version":3,"names":["getDefaultRevision","createRevision","now","flatClone","deepEqual","defaultConflictHandler","i","_context","newDocumentState","realMasterState","Promise","resolve","isEqual","documentData","resolveConflictError","_x","_x2","_x3","_resolveConflictError","apply","arguments","_asyncToGenerator","state","input","forkState","conflictHandler","conflictHandlerOutput","undefined","resolvedDoc","Object","assign","_meta","_rev","_attachments","lwt","identifier","output"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/replication-protocol/conflicts.js"],"sourcesContent":["import { getDefaultRevision, createRevision, now, flatClone, deepEqual } from '../plugins/utils';\nexport var defaultConflictHandler = function (i, _context) {\n  /**\n   * If the documents are deep equal,\n   * we have no conflict.\n   * On your custom conflict handler you might only\n   * check some properties, like the updatedAt time,\n   * for better performance, because deepEqual is expensive.\n   */\n  if (deepEqual(i.newDocumentState, i.realMasterState)) {\n    return Promise.resolve({\n      isEqual: true\n    });\n  }\n\n  /**\n   * The default conflict handler will always\n   * drop the fork state and use the master state instead.\n   */\n  return Promise.resolve({\n    isEqual: false,\n    documentData: i.realMasterState\n  });\n};\n\n/**\n * Resolves a conflict error or determines that the given document states are equal.\n * Returns the resolved document that must be written to the fork.\n * Then the new document state can be pushed upstream.\n * If document is not in conflict, returns undefined.\n * If error is non-409, it throws an error.\n * Conflicts are only solved in the upstream, never in the downstream.\n */\nexport async function resolveConflictError(state, input, forkState) {\n  var conflictHandler = state.input.conflictHandler;\n  var conflictHandlerOutput = await conflictHandler(input, 'replication-resolve-conflict');\n  if (conflictHandlerOutput.isEqual) {\n    /**\n     * Documents are equal,\n     * so this is not a conflict -> do nothing.\n     */\n    return undefined;\n  } else {\n    /**\n     * We have a resolved conflict,\n     * use the resolved document data.\n     */\n    var resolvedDoc = Object.assign({}, conflictHandlerOutput.documentData, {\n      /**\n       * Because the resolved conflict is written to the fork,\n       * we have to keep/update the forks _meta data, not the masters.\n       */\n      _meta: flatClone(forkState._meta),\n      _rev: getDefaultRevision(),\n      _attachments: flatClone(forkState._attachments)\n    });\n    resolvedDoc._meta.lwt = now();\n    resolvedDoc._rev = createRevision(state.input.identifier, forkState);\n    return {\n      resolvedDoc,\n      output: conflictHandlerOutput\n    };\n  }\n}\n"],"mappings":";AAAA,SAASA,kBAAkB,EAAEC,cAAc,EAAEC,GAAG,EAAEC,SAAS,EAAEC,SAAS,QAAQ,kBAAkB;AAChG,OAAO,IAAIC,sBAAsB,GAAG,SAAAA,CAAUC,CAAC,EAAEC,QAAQ,EAAE;EACzD;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIH,SAAS,CAACE,CAAC,CAACE,gBAAgB,EAAEF,CAAC,CAACG,eAAe,CAAC,EAAE;IACpD,OAAOC,OAAO,CAACC,OAAO,CAAC;MACrBC,OAAO,EAAE;IACX,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;EACE,OAAOF,OAAO,CAACC,OAAO,CAAC;IACrBC,OAAO,EAAE,KAAK;IACdC,YAAY,EAAEP,CAAC,CAACG;EAClB,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAsBK,oBAAoBA,CAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,qBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AA8BzC,SAAAF,sBAAA;EAAAA,qBAAA,GAAAG,iBAAA,CA9BM,WAAoCC,KAAK,EAAEC,KAAK,EAAEC,SAAS,EAAE;IAClE,IAAIC,eAAe,GAAGH,KAAK,CAACC,KAAK,CAACE,eAAe;IACjD,IAAIC,qBAAqB,SAASD,eAAe,CAACF,KAAK,EAAE,8BAA8B,CAAC;IACxF,IAAIG,qBAAqB,CAACd,OAAO,EAAE;MACjC;AACJ;AACA;AACA;MACI,OAAOe,SAAS;IAClB,CAAC,MAAM;MACL;AACJ;AACA;AACA;MACI,IAAIC,WAAW,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEJ,qBAAqB,CAACb,YAAY,EAAE;QACtE;AACN;AACA;AACA;QACMkB,KAAK,EAAE5B,SAAS,CAACqB,SAAS,CAACO,KAAK,CAAC;QACjCC,IAAI,EAAEhC,kBAAkB,CAAC,CAAC;QAC1BiC,YAAY,EAAE9B,SAAS,CAACqB,SAAS,CAACS,YAAY;MAChD,CAAC,CAAC;MACFL,WAAW,CAACG,KAAK,CAACG,GAAG,GAAGhC,GAAG,CAAC,CAAC;MAC7B0B,WAAW,CAACI,IAAI,GAAG/B,cAAc,CAACqB,KAAK,CAACC,KAAK,CAACY,UAAU,EAAEX,SAAS,CAAC;MACpE,OAAO;QACLI,WAAW;QACXQ,MAAM,EAAEV;MACV,CAAC;IACH;EACF,CAAC;EAAA,OAAAR,qBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}