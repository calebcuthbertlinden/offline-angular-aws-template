{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { filter, mergeMap, tap } from 'rxjs/operators';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nimport { defaultHashSha256, flatClone, getFromMapOrCreate, requestIdleCallbackIfAvailable } from './plugins/utils';\nimport { BehaviorSubject, firstValueFrom } from 'rxjs';\n\n/**\n * Returns the validation errors.\n * If document is fully valid, returns an empty array.\n */\n\n/**\n * cache the validators by the schema-hash\n * so we can reuse them when multiple collections have the same schema\n */\nvar VALIDATOR_CACHE_BY_VALIDATOR_KEY = new Map();\n\n/**\n * This factory is used in the validation plugins\n * so that we can reuse the basic storage wrapping code.\n */\nexport function wrappedValidateStorageFactory(\n/**\n * Returns a method that can be used to validate\n * documents and throws when the document is not valid.\n */\ngetValidator,\n/**\n * A string to identify the validation library.\n */\nvalidatorKey) {\n  var VALIDATOR_CACHE = getFromMapOrCreate(VALIDATOR_CACHE_BY_VALIDATOR_KEY, validatorKey, () => new Map());\n  function initValidator(schema) {\n    var hash = defaultHashSha256(JSON.stringify(schema));\n    return getFromMapOrCreate(VALIDATOR_CACHE, hash, () => getValidator(schema));\n  }\n  return args => {\n    return Object.assign({}, args.storage, {\n      createStorageInstance(params) {\n        return _asyncToGenerator(function* () {\n          var instance = yield args.storage.createStorageInstance(params);\n          var primaryPath = getPrimaryFieldOfPrimaryKey(params.schema.primaryKey);\n\n          /**\n           * Lazy initialize the validator\n           * to save initial page load performance.\n           * Some libraries take really long to initialize the validator\n           * from the schema.\n           */\n          var validatorCached;\n          requestIdleCallbackIfAvailable(() => validatorCached = initValidator(params.schema));\n          var oldBulkWrite = instance.bulkWrite.bind(instance);\n          instance.bulkWrite = (documentWrites, context) => {\n            if (!validatorCached) {\n              validatorCached = initValidator(params.schema);\n            }\n            var errors = [];\n            var continueWrites = [];\n            documentWrites.forEach(row => {\n              var documentId = row.document[primaryPath];\n              var validationErrors = validatorCached(row.document);\n              if (validationErrors.length > 0) {\n                errors.push({\n                  status: 422,\n                  isError: true,\n                  documentId,\n                  writeRow: row,\n                  validationErrors\n                });\n              } else {\n                continueWrites.push(row);\n              }\n            });\n            var writePromise = continueWrites.length > 0 ? oldBulkWrite(continueWrites, context) : Promise.resolve({\n              error: {},\n              success: {}\n            });\n            return writePromise.then(writeResult => {\n              errors.forEach(validationError => {\n                writeResult.error[validationError.documentId] = validationError;\n              });\n              return writeResult;\n            });\n          };\n          return instance;\n        })();\n      }\n    });\n  };\n}\n\n/**\n * Used in plugins to easily modify all in- and outgoing\n * data of that storage instance.\n */\nexport function wrapRxStorageInstance(instance, modifyToStorage, modifyFromStorage, modifyAttachmentFromStorage = v => v) {\n  function toStorage(_x) {\n    return _toStorage.apply(this, arguments);\n  }\n  function _toStorage() {\n    _toStorage = _asyncToGenerator(function* (docData) {\n      if (!docData) {\n        return docData;\n      }\n      return yield modifyToStorage(docData);\n    });\n    return _toStorage.apply(this, arguments);\n  }\n  function fromStorage(_x2) {\n    return _fromStorage.apply(this, arguments);\n  }\n  function _fromStorage() {\n    _fromStorage = _asyncToGenerator(function* (docData) {\n      if (!docData) {\n        return docData;\n      }\n      return yield modifyFromStorage(docData);\n    });\n    return _fromStorage.apply(this, arguments);\n  }\n  function errorFromStorage(_x3) {\n    return _errorFromStorage.apply(this, arguments);\n  }\n  function _errorFromStorage() {\n    _errorFromStorage = _asyncToGenerator(function* (error) {\n      var ret = flatClone(error);\n      ret.writeRow = flatClone(ret.writeRow);\n      if (ret.documentInDb) {\n        ret.documentInDb = yield fromStorage(ret.documentInDb);\n      }\n      if (ret.writeRow.previous) {\n        ret.writeRow.previous = yield fromStorage(ret.writeRow.previous);\n      }\n      ret.writeRow.document = yield fromStorage(ret.writeRow.document);\n      return ret;\n    });\n    return _errorFromStorage.apply(this, arguments);\n  }\n  var processingChangesCount$ = new BehaviorSubject(0);\n  var wrappedInstance = {\n    databaseName: instance.databaseName,\n    internals: instance.internals,\n    cleanup: instance.cleanup.bind(instance),\n    options: instance.options,\n    close: instance.close.bind(instance),\n    schema: instance.schema,\n    collectionName: instance.collectionName,\n    count: instance.count.bind(instance),\n    remove: instance.remove.bind(instance),\n    originalStorageInstance: instance,\n    bulkWrite: function () {\n      var _ref = _asyncToGenerator(function* (documentWrites, context) {\n        var useRows = [];\n        yield Promise.all(documentWrites.map( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (row) {\n            var [previous, document] = yield Promise.all([row.previous ? toStorage(row.previous) : undefined, toStorage(row.document)]);\n            useRows.push({\n              previous,\n              document\n            });\n          });\n          return function (_x6) {\n            return _ref2.apply(this, arguments);\n          };\n        }()));\n        var writeResult = yield instance.bulkWrite(useRows, context);\n        var ret = {\n          success: {},\n          error: {}\n        };\n        var promises = [];\n        Object.entries(writeResult.success).forEach(([k, v]) => {\n          promises.push(fromStorage(v).then(v2 => ret.success[k] = v2));\n        });\n        Object.entries(writeResult.error).forEach(([k, error]) => {\n          promises.push(errorFromStorage(error).then(err => ret.error[k] = err));\n        });\n        yield Promise.all(promises);\n\n        /**\n         * By definition, all change events must be emitted\n         * BEFORE the write call resolves.\n         * To ensure that even when the modifiers are async,\n         * we wait here until the processing queue is empty.\n         */\n        yield firstValueFrom(processingChangesCount$.pipe(filter(v => v === 0)));\n        return ret;\n      });\n      return function bulkWrite(_x4, _x5) {\n        return _ref.apply(this, arguments);\n      };\n    }(),\n    query: preparedQuery => {\n      return instance.query(preparedQuery).then(queryResult => {\n        return Promise.all(queryResult.documents.map(doc => fromStorage(doc)));\n      }).then(documents => ({\n        documents: documents\n      }));\n    },\n    getAttachmentData: function () {\n      var _ref3 = _asyncToGenerator(function* (documentId, attachmentId, digest) {\n        var data = yield instance.getAttachmentData(documentId, attachmentId, digest);\n        data = yield modifyAttachmentFromStorage(data);\n        return data;\n      });\n      return function getAttachmentData(_x7, _x8, _x9) {\n        return _ref3.apply(this, arguments);\n      };\n    }(),\n    findDocumentsById: (ids, deleted) => {\n      return instance.findDocumentsById(ids, deleted).then( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (findResult) {\n          var ret = {};\n          yield Promise.all(Object.entries(findResult).map( /*#__PURE__*/function () {\n            var _ref5 = _asyncToGenerator(function* ([key, doc]) {\n              ret[key] = yield fromStorage(doc);\n            });\n            return function (_x11) {\n              return _ref5.apply(this, arguments);\n            };\n          }()));\n          return ret;\n        });\n        return function (_x10) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n    },\n    getChangedDocumentsSince: (limit, checkpoint) => {\n      return instance.getChangedDocumentsSince(limit, checkpoint).then( /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator(function* (result) {\n          return {\n            checkpoint: result.checkpoint,\n            documents: yield Promise.all(result.documents.map(d => fromStorage(d)))\n          };\n        });\n        return function (_x12) {\n          return _ref6.apply(this, arguments);\n        };\n      }());\n    },\n    changeStream: () => {\n      return instance.changeStream().pipe(tap(() => processingChangesCount$.next(processingChangesCount$.getValue() + 1)), mergeMap( /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator(function* (eventBulk) {\n          var useEvents = yield Promise.all(eventBulk.events.map( /*#__PURE__*/function () {\n            var _ref8 = _asyncToGenerator(function* (event) {\n              var [documentData, previousDocumentData] = yield Promise.all([fromStorage(event.documentData), fromStorage(event.previousDocumentData)]);\n              var ev = {\n                operation: event.operation,\n                eventId: event.eventId,\n                documentId: event.documentId,\n                endTime: event.endTime,\n                startTime: event.startTime,\n                documentData: documentData,\n                previousDocumentData: previousDocumentData,\n                isLocal: false\n              };\n              return ev;\n            });\n            return function (_x14) {\n              return _ref8.apply(this, arguments);\n            };\n          }()));\n          var ret = {\n            id: eventBulk.id,\n            events: useEvents,\n            checkpoint: eventBulk.checkpoint,\n            context: eventBulk.context\n          };\n          return ret;\n        });\n        return function (_x13) {\n          return _ref7.apply(this, arguments);\n        };\n      }()), tap(() => processingChangesCount$.next(processingChangesCount$.getValue() - 1)));\n    },\n    conflictResultionTasks: () => {\n      return instance.conflictResultionTasks().pipe(mergeMap( /*#__PURE__*/function () {\n        var _ref9 = _asyncToGenerator(function* (task) {\n          var assumedMasterState = yield fromStorage(task.input.assumedMasterState);\n          var newDocumentState = yield fromStorage(task.input.newDocumentState);\n          var realMasterState = yield fromStorage(task.input.realMasterState);\n          return {\n            id: task.id,\n            context: task.context,\n            input: {\n              assumedMasterState,\n              realMasterState,\n              newDocumentState\n            }\n          };\n        });\n        return function (_x15) {\n          return _ref9.apply(this, arguments);\n        };\n      }()));\n    },\n    resolveConflictResultionTask: taskSolution => {\n      if (taskSolution.output.isEqual) {\n        return instance.resolveConflictResultionTask(taskSolution);\n      }\n      var useSolution = {\n        id: taskSolution.id,\n        output: {\n          isEqual: false,\n          documentData: taskSolution.output.documentData\n        }\n      };\n      return instance.resolveConflictResultionTask(useSolution);\n    }\n  };\n  return wrappedInstance;\n}","map":{"version":3,"names":["filter","mergeMap","tap","getPrimaryFieldOfPrimaryKey","defaultHashSha256","flatClone","getFromMapOrCreate","requestIdleCallbackIfAvailable","BehaviorSubject","firstValueFrom","VALIDATOR_CACHE_BY_VALIDATOR_KEY","Map","wrappedValidateStorageFactory","getValidator","validatorKey","VALIDATOR_CACHE","initValidator","schema","hash","JSON","stringify","args","Object","assign","storage","createStorageInstance","params","_asyncToGenerator","instance","primaryPath","primaryKey","validatorCached","oldBulkWrite","bulkWrite","bind","documentWrites","context","errors","continueWrites","forEach","row","documentId","document","validationErrors","length","push","status","isError","writeRow","writePromise","Promise","resolve","error","success","then","writeResult","validationError","wrapRxStorageInstance","modifyToStorage","modifyFromStorage","modifyAttachmentFromStorage","v","toStorage","_x","_toStorage","apply","arguments","docData","fromStorage","_x2","_fromStorage","errorFromStorage","_x3","_errorFromStorage","ret","documentInDb","previous","processingChangesCount$","wrappedInstance","databaseName","internals","cleanup","options","close","collectionName","count","remove","originalStorageInstance","_ref","useRows","all","map","_ref2","undefined","_x6","promises","entries","k","v2","err","pipe","_x4","_x5","query","preparedQuery","queryResult","documents","doc","getAttachmentData","_ref3","attachmentId","digest","data","_x7","_x8","_x9","findDocumentsById","ids","deleted","_ref4","findResult","_ref5","key","_x11","_x10","getChangedDocumentsSince","limit","checkpoint","_ref6","result","d","_x12","changeStream","next","getValue","_ref7","eventBulk","useEvents","events","_ref8","event","documentData","previousDocumentData","ev","operation","eventId","endTime","startTime","isLocal","_x14","id","_x13","conflictResultionTasks","_ref9","task","assumedMasterState","input","newDocumentState","realMasterState","_x15","resolveConflictResultionTask","taskSolution","output","isEqual","useSolution"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/plugin-helpers.js"],"sourcesContent":["import { filter, mergeMap, tap } from 'rxjs/operators';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nimport { defaultHashSha256, flatClone, getFromMapOrCreate, requestIdleCallbackIfAvailable } from './plugins/utils';\nimport { BehaviorSubject, firstValueFrom } from 'rxjs';\n\n/**\n * Returns the validation errors.\n * If document is fully valid, returns an empty array.\n */\n\n/**\n * cache the validators by the schema-hash\n * so we can reuse them when multiple collections have the same schema\n */\nvar VALIDATOR_CACHE_BY_VALIDATOR_KEY = new Map();\n\n/**\n * This factory is used in the validation plugins\n * so that we can reuse the basic storage wrapping code.\n */\nexport function wrappedValidateStorageFactory(\n/**\n * Returns a method that can be used to validate\n * documents and throws when the document is not valid.\n */\ngetValidator,\n/**\n * A string to identify the validation library.\n */\nvalidatorKey) {\n  var VALIDATOR_CACHE = getFromMapOrCreate(VALIDATOR_CACHE_BY_VALIDATOR_KEY, validatorKey, () => new Map());\n  function initValidator(schema) {\n    var hash = defaultHashSha256(JSON.stringify(schema));\n    return getFromMapOrCreate(VALIDATOR_CACHE, hash, () => getValidator(schema));\n  }\n  return args => {\n    return Object.assign({}, args.storage, {\n      async createStorageInstance(params) {\n        var instance = await args.storage.createStorageInstance(params);\n        var primaryPath = getPrimaryFieldOfPrimaryKey(params.schema.primaryKey);\n\n        /**\n         * Lazy initialize the validator\n         * to save initial page load performance.\n         * Some libraries take really long to initialize the validator\n         * from the schema.\n         */\n        var validatorCached;\n        requestIdleCallbackIfAvailable(() => validatorCached = initValidator(params.schema));\n        var oldBulkWrite = instance.bulkWrite.bind(instance);\n        instance.bulkWrite = (documentWrites, context) => {\n          if (!validatorCached) {\n            validatorCached = initValidator(params.schema);\n          }\n          var errors = [];\n          var continueWrites = [];\n          documentWrites.forEach(row => {\n            var documentId = row.document[primaryPath];\n            var validationErrors = validatorCached(row.document);\n            if (validationErrors.length > 0) {\n              errors.push({\n                status: 422,\n                isError: true,\n                documentId,\n                writeRow: row,\n                validationErrors\n              });\n            } else {\n              continueWrites.push(row);\n            }\n          });\n          var writePromise = continueWrites.length > 0 ? oldBulkWrite(continueWrites, context) : Promise.resolve({\n            error: {},\n            success: {}\n          });\n          return writePromise.then(writeResult => {\n            errors.forEach(validationError => {\n              writeResult.error[validationError.documentId] = validationError;\n            });\n            return writeResult;\n          });\n        };\n        return instance;\n      }\n    });\n  };\n}\n\n/**\n * Used in plugins to easily modify all in- and outgoing\n * data of that storage instance.\n */\nexport function wrapRxStorageInstance(instance, modifyToStorage, modifyFromStorage, modifyAttachmentFromStorage = v => v) {\n  async function toStorage(docData) {\n    if (!docData) {\n      return docData;\n    }\n    return await modifyToStorage(docData);\n  }\n  async function fromStorage(docData) {\n    if (!docData) {\n      return docData;\n    }\n    return await modifyFromStorage(docData);\n  }\n  async function errorFromStorage(error) {\n    var ret = flatClone(error);\n    ret.writeRow = flatClone(ret.writeRow);\n    if (ret.documentInDb) {\n      ret.documentInDb = await fromStorage(ret.documentInDb);\n    }\n    if (ret.writeRow.previous) {\n      ret.writeRow.previous = await fromStorage(ret.writeRow.previous);\n    }\n    ret.writeRow.document = await fromStorage(ret.writeRow.document);\n    return ret;\n  }\n  var processingChangesCount$ = new BehaviorSubject(0);\n  var wrappedInstance = {\n    databaseName: instance.databaseName,\n    internals: instance.internals,\n    cleanup: instance.cleanup.bind(instance),\n    options: instance.options,\n    close: instance.close.bind(instance),\n    schema: instance.schema,\n    collectionName: instance.collectionName,\n    count: instance.count.bind(instance),\n    remove: instance.remove.bind(instance),\n    originalStorageInstance: instance,\n    bulkWrite: async (documentWrites, context) => {\n      var useRows = [];\n      await Promise.all(documentWrites.map(async row => {\n        var [previous, document] = await Promise.all([row.previous ? toStorage(row.previous) : undefined, toStorage(row.document)]);\n        useRows.push({\n          previous,\n          document\n        });\n      }));\n      var writeResult = await instance.bulkWrite(useRows, context);\n      var ret = {\n        success: {},\n        error: {}\n      };\n      var promises = [];\n      Object.entries(writeResult.success).forEach(([k, v]) => {\n        promises.push(fromStorage(v).then(v2 => ret.success[k] = v2));\n      });\n      Object.entries(writeResult.error).forEach(([k, error]) => {\n        promises.push(errorFromStorage(error).then(err => ret.error[k] = err));\n      });\n      await Promise.all(promises);\n\n      /**\n       * By definition, all change events must be emitted\n       * BEFORE the write call resolves.\n       * To ensure that even when the modifiers are async,\n       * we wait here until the processing queue is empty.\n       */\n      await firstValueFrom(processingChangesCount$.pipe(filter(v => v === 0)));\n      return ret;\n    },\n    query: preparedQuery => {\n      return instance.query(preparedQuery).then(queryResult => {\n        return Promise.all(queryResult.documents.map(doc => fromStorage(doc)));\n      }).then(documents => ({\n        documents: documents\n      }));\n    },\n    getAttachmentData: async (documentId, attachmentId, digest) => {\n      var data = await instance.getAttachmentData(documentId, attachmentId, digest);\n      data = await modifyAttachmentFromStorage(data);\n      return data;\n    },\n    findDocumentsById: (ids, deleted) => {\n      return instance.findDocumentsById(ids, deleted).then(async findResult => {\n        var ret = {};\n        await Promise.all(Object.entries(findResult).map(async ([key, doc]) => {\n          ret[key] = await fromStorage(doc);\n        }));\n        return ret;\n      });\n    },\n    getChangedDocumentsSince: (limit, checkpoint) => {\n      return instance.getChangedDocumentsSince(limit, checkpoint).then(async result => {\n        return {\n          checkpoint: result.checkpoint,\n          documents: await Promise.all(result.documents.map(d => fromStorage(d)))\n        };\n      });\n    },\n    changeStream: () => {\n      return instance.changeStream().pipe(tap(() => processingChangesCount$.next(processingChangesCount$.getValue() + 1)), mergeMap(async eventBulk => {\n        var useEvents = await Promise.all(eventBulk.events.map(async event => {\n          var [documentData, previousDocumentData] = await Promise.all([fromStorage(event.documentData), fromStorage(event.previousDocumentData)]);\n          var ev = {\n            operation: event.operation,\n            eventId: event.eventId,\n            documentId: event.documentId,\n            endTime: event.endTime,\n            startTime: event.startTime,\n            documentData: documentData,\n            previousDocumentData: previousDocumentData,\n            isLocal: false\n          };\n          return ev;\n        }));\n        var ret = {\n          id: eventBulk.id,\n          events: useEvents,\n          checkpoint: eventBulk.checkpoint,\n          context: eventBulk.context\n        };\n        return ret;\n      }), tap(() => processingChangesCount$.next(processingChangesCount$.getValue() - 1)));\n    },\n    conflictResultionTasks: () => {\n      return instance.conflictResultionTasks().pipe(mergeMap(async task => {\n        var assumedMasterState = await fromStorage(task.input.assumedMasterState);\n        var newDocumentState = await fromStorage(task.input.newDocumentState);\n        var realMasterState = await fromStorage(task.input.realMasterState);\n        return {\n          id: task.id,\n          context: task.context,\n          input: {\n            assumedMasterState,\n            realMasterState,\n            newDocumentState\n          }\n        };\n      }));\n    },\n    resolveConflictResultionTask: taskSolution => {\n      if (taskSolution.output.isEqual) {\n        return instance.resolveConflictResultionTask(taskSolution);\n      }\n      var useSolution = {\n        id: taskSolution.id,\n        output: {\n          isEqual: false,\n          documentData: taskSolution.output.documentData\n        }\n      };\n      return instance.resolveConflictResultionTask(useSolution);\n    }\n  };\n  return wrappedInstance;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}