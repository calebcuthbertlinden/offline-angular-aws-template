{"ast":null,"code":"import { ComputeOptions, computeValue, getOperator, OperatorType } from \"../../core\";\nimport { assert, ensureArray, filterMissing, has, inArray, into, isEmpty, isNil, isNumber, isObject, isOperator, isString, merge, notInArray, removeValue, resolveGraph, setValue } from \"../../util\";\n/**\n * Reshapes a document stream.\n * $project can rename, add, or remove fields as well as create computed values and sub-documents.\n *\n * @param collection\n * @param expr\n * @param opt\n * @returns {Array}\n */\nexport function $project(collection, expr, options) {\n  if (isEmpty(expr)) return collection;\n  // result collection\n  let expressionKeys = Object.keys(expr);\n  let idOnlyExcluded = false;\n  // validate inclusion and exclusion\n  validateExpression(expr, options);\n  const ID_KEY = options.idKey;\n  if (inArray(expressionKeys, ID_KEY)) {\n    const id = expr[ID_KEY];\n    if (id === 0 || id === false) {\n      expressionKeys = expressionKeys.filter(notInArray.bind(null, [ID_KEY]));\n      idOnlyExcluded = expressionKeys.length == 0;\n    }\n  } else {\n    // if not specified the add the ID field\n    expressionKeys.push(ID_KEY);\n  }\n  const copts = ComputeOptions.init(options);\n  return collection.map(obj => processObject(obj, expr, copts.update(obj), expressionKeys, idOnlyExcluded));\n}\n/**\n * Process the expression value for $project operators\n *\n * @param {Object} obj The object to use as options\n * @param {Object} expr The experssion object of $project operator\n * @param {Array} expressionKeys The key in the 'expr' object\n * @param {Boolean} idOnlyExcluded Boolean value indicating whether only the ID key is excluded\n */\nfunction processObject(obj, expr, options, expressionKeys, idOnlyExcluded) {\n  let newObj = {};\n  let foundSlice = false;\n  let foundExclusion = false;\n  const dropKeys = [];\n  if (idOnlyExcluded) {\n    dropKeys.push(options.idKey);\n  }\n  for (const key of expressionKeys) {\n    // final computed value of the key\n    let value = undefined;\n    // expression to associate with key\n    const subExpr = expr[key];\n    if (key !== options.idKey && inArray([0, false], subExpr)) {\n      foundExclusion = true;\n    }\n    if (key === options.idKey && isEmpty(subExpr)) {\n      // tiny optimization here to skip over id\n      value = obj[key];\n    } else if (isString(subExpr)) {\n      value = computeValue(obj, subExpr, key, options);\n    } else if (inArray([1, true], subExpr)) {\n      // For direct projections, we use the resolved object value\n    } else if (subExpr instanceof Array) {\n      value = subExpr.map(v => {\n        const r = computeValue(obj, v, null, options);\n        if (isNil(r)) return null;\n        return r;\n      });\n    } else if (isObject(subExpr)) {\n      const subExprObj = subExpr;\n      const subExprKeys = Object.keys(subExpr);\n      const operator = subExprKeys.length == 1 ? subExprKeys[0] : null;\n      // first try a projection operator\n      const call = getOperator(OperatorType.PROJECTION, operator);\n      if (call) {\n        // apply the projection operator on the operator expression for the key\n        if (operator === \"$slice\") {\n          // $slice is handled differently for aggregation and projection operations\n          if (ensureArray(subExprObj[operator]).every(isNumber)) {\n            // $slice for projection operation\n            value = call(obj, subExprObj[operator], key);\n            foundSlice = true;\n          } else {\n            // $slice for aggregation operation\n            value = computeValue(obj, subExprObj, key, options);\n          }\n        } else {\n          value = call(obj, subExprObj[operator], key, options);\n        }\n      } else if (isOperator(operator)) {\n        // compute if operator key\n        value = computeValue(obj, subExprObj[operator], operator, options);\n      } else if (has(obj, key)) {\n        // compute the value for the sub expression for the key\n        validateExpression(subExprObj, options);\n        let target = obj[key];\n        if (target instanceof Array) {\n          value = target.map(o => processObject(o, subExprObj, options, subExprKeys, false));\n        } else {\n          target = isObject(target) ? target : obj;\n          value = processObject(target, subExprObj, options, subExprKeys, false);\n        }\n      } else {\n        // compute the value for the sub expression for the key\n        value = computeValue(obj, subExpr, null, options);\n      }\n    } else {\n      dropKeys.push(key);\n      continue;\n    }\n    // get value with object graph\n    const objPathGraph = resolveGraph(obj, key, {\n      preserveMissing: true\n    });\n    // add the value at the path\n    if (objPathGraph !== undefined) {\n      merge(newObj, objPathGraph, {\n        flatten: true\n      });\n    }\n    // if computed add/or remove accordingly\n    if (notInArray([0, 1, false, true], subExpr)) {\n      if (value === undefined) {\n        removeValue(newObj, key, {\n          descendArray: true\n        });\n      } else {\n        setValue(newObj, key, value);\n      }\n    }\n  }\n  // filter out all missing values preserved to support correct merging\n  filterMissing(newObj);\n  // For the following cases we include all keys on the object that were not explicitly excluded.\n  //\n  // 1. projection included $slice operator\n  // 2. some fields were explicitly excluded\n  // 3. only the id field was excluded\n  if (foundSlice || foundExclusion || idOnlyExcluded) {\n    newObj = into({}, obj, newObj);\n    if (dropKeys.length > 0) {\n      for (const k of dropKeys) {\n        removeValue(newObj, k, {\n          descendArray: true\n        });\n      }\n    }\n  }\n  return newObj;\n}\n/**\n * Validate inclusion and exclusion values in expression\n *\n * @param {Object} expr The expression given for the projection\n */\nfunction validateExpression(expr, options) {\n  const check = [false, false];\n  for (const [k, v] of Object.entries(expr)) {\n    if (k === options.idKey) return;\n    if (v === 0 || v === false) {\n      check[0] = true;\n    } else if (v === 1 || v === true) {\n      check[1] = true;\n    }\n    assert(!(check[0] && check[1]), \"Projection cannot have a mix of inclusion and exclusion.\");\n  }\n}","map":{"version":3,"names":["ComputeOptions","computeValue","getOperator","OperatorType","assert","ensureArray","filterMissing","has","inArray","into","isEmpty","isNil","isNumber","isObject","isOperator","isString","merge","notInArray","removeValue","resolveGraph","setValue","$project","collection","expr","options","expressionKeys","Object","keys","idOnlyExcluded","validateExpression","ID_KEY","idKey","id","filter","bind","length","push","copts","init","map","obj","processObject","update","newObj","foundSlice","foundExclusion","dropKeys","key","value","undefined","subExpr","Array","v","r","subExprObj","subExprKeys","operator","call","PROJECTION","every","target","o","objPathGraph","preserveMissing","flatten","descendArray","k","check","entries"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/mingo/es/operators/pipeline/project.js"],"sourcesContent":["import { ComputeOptions, computeValue, getOperator, OperatorType, } from \"../../core\";\nimport { assert, ensureArray, filterMissing, has, inArray, into, isEmpty, isNil, isNumber, isObject, isOperator, isString, merge, notInArray, removeValue, resolveGraph, setValue, } from \"../../util\";\n/**\n * Reshapes a document stream.\n * $project can rename, add, or remove fields as well as create computed values and sub-documents.\n *\n * @param collection\n * @param expr\n * @param opt\n * @returns {Array}\n */\nexport function $project(collection, expr, options) {\n    if (isEmpty(expr))\n        return collection;\n    // result collection\n    let expressionKeys = Object.keys(expr);\n    let idOnlyExcluded = false;\n    // validate inclusion and exclusion\n    validateExpression(expr, options);\n    const ID_KEY = options.idKey;\n    if (inArray(expressionKeys, ID_KEY)) {\n        const id = expr[ID_KEY];\n        if (id === 0 || id === false) {\n            expressionKeys = expressionKeys.filter(notInArray.bind(null, [ID_KEY]));\n            idOnlyExcluded = expressionKeys.length == 0;\n        }\n    }\n    else {\n        // if not specified the add the ID field\n        expressionKeys.push(ID_KEY);\n    }\n    const copts = ComputeOptions.init(options);\n    return collection.map((obj) => processObject(obj, expr, copts.update(obj), expressionKeys, idOnlyExcluded));\n}\n/**\n * Process the expression value for $project operators\n *\n * @param {Object} obj The object to use as options\n * @param {Object} expr The experssion object of $project operator\n * @param {Array} expressionKeys The key in the 'expr' object\n * @param {Boolean} idOnlyExcluded Boolean value indicating whether only the ID key is excluded\n */\nfunction processObject(obj, expr, options, expressionKeys, idOnlyExcluded) {\n    let newObj = {};\n    let foundSlice = false;\n    let foundExclusion = false;\n    const dropKeys = [];\n    if (idOnlyExcluded) {\n        dropKeys.push(options.idKey);\n    }\n    for (const key of expressionKeys) {\n        // final computed value of the key\n        let value = undefined;\n        // expression to associate with key\n        const subExpr = expr[key];\n        if (key !== options.idKey && inArray([0, false], subExpr)) {\n            foundExclusion = true;\n        }\n        if (key === options.idKey && isEmpty(subExpr)) {\n            // tiny optimization here to skip over id\n            value = obj[key];\n        }\n        else if (isString(subExpr)) {\n            value = computeValue(obj, subExpr, key, options);\n        }\n        else if (inArray([1, true], subExpr)) {\n            // For direct projections, we use the resolved object value\n        }\n        else if (subExpr instanceof Array) {\n            value = subExpr.map((v) => {\n                const r = computeValue(obj, v, null, options);\n                if (isNil(r))\n                    return null;\n                return r;\n            });\n        }\n        else if (isObject(subExpr)) {\n            const subExprObj = subExpr;\n            const subExprKeys = Object.keys(subExpr);\n            const operator = subExprKeys.length == 1 ? subExprKeys[0] : null;\n            // first try a projection operator\n            const call = getOperator(OperatorType.PROJECTION, operator);\n            if (call) {\n                // apply the projection operator on the operator expression for the key\n                if (operator === \"$slice\") {\n                    // $slice is handled differently for aggregation and projection operations\n                    if (ensureArray(subExprObj[operator]).every(isNumber)) {\n                        // $slice for projection operation\n                        value = call(obj, subExprObj[operator], key);\n                        foundSlice = true;\n                    }\n                    else {\n                        // $slice for aggregation operation\n                        value = computeValue(obj, subExprObj, key, options);\n                    }\n                }\n                else {\n                    value = call(obj, subExprObj[operator], key, options);\n                }\n            }\n            else if (isOperator(operator)) {\n                // compute if operator key\n                value = computeValue(obj, subExprObj[operator], operator, options);\n            }\n            else if (has(obj, key)) {\n                // compute the value for the sub expression for the key\n                validateExpression(subExprObj, options);\n                let target = obj[key];\n                if (target instanceof Array) {\n                    value = target.map((o) => processObject(o, subExprObj, options, subExprKeys, false));\n                }\n                else {\n                    target = isObject(target) ? target : obj;\n                    value = processObject(target, subExprObj, options, subExprKeys, false);\n                }\n            }\n            else {\n                // compute the value for the sub expression for the key\n                value = computeValue(obj, subExpr, null, options);\n            }\n        }\n        else {\n            dropKeys.push(key);\n            continue;\n        }\n        // get value with object graph\n        const objPathGraph = resolveGraph(obj, key, {\n            preserveMissing: true,\n        });\n        // add the value at the path\n        if (objPathGraph !== undefined) {\n            merge(newObj, objPathGraph, {\n                flatten: true,\n            });\n        }\n        // if computed add/or remove accordingly\n        if (notInArray([0, 1, false, true], subExpr)) {\n            if (value === undefined) {\n                removeValue(newObj, key, { descendArray: true });\n            }\n            else {\n                setValue(newObj, key, value);\n            }\n        }\n    }\n    // filter out all missing values preserved to support correct merging\n    filterMissing(newObj);\n    // For the following cases we include all keys on the object that were not explicitly excluded.\n    //\n    // 1. projection included $slice operator\n    // 2. some fields were explicitly excluded\n    // 3. only the id field was excluded\n    if (foundSlice || foundExclusion || idOnlyExcluded) {\n        newObj = into({}, obj, newObj);\n        if (dropKeys.length > 0) {\n            for (const k of dropKeys) {\n                removeValue(newObj, k, { descendArray: true });\n            }\n        }\n    }\n    return newObj;\n}\n/**\n * Validate inclusion and exclusion values in expression\n *\n * @param {Object} expr The expression given for the projection\n */\nfunction validateExpression(expr, options) {\n    const check = [false, false];\n    for (const [k, v] of Object.entries(expr)) {\n        if (k === options.idKey)\n            return;\n        if (v === 0 || v === false) {\n            check[0] = true;\n        }\n        else if (v === 1 || v === true) {\n            check[1] = true;\n        }\n        assert(!(check[0] && check[1]), \"Projection cannot have a mix of inclusion and exclusion.\");\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}