{"ast":null,"code":"/**\n * Creates a new Idle-Queue\n * @constructor\n * @param {number} [parallels=1] amount of parrallel runs of the limited-ressource\n */\nexport var IdleQueue = function IdleQueue() {\n  var parallels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  this._parallels = parallels || 1;\n  /**\n   * _queueCounter\n   * each lock() increased this number\n   * each unlock() decreases this number\n   * If _qC==0, the state is in idle\n   * @type {Number}\n   */\n\n  this._qC = 0;\n  /**\n   * _idleCalls\n   * contains all promises that where added via requestIdlePromise()\n   * and not have been resolved\n   * @type {Set<Promise>} _iC with oldest promise first\n   */\n\n  this._iC = new Set();\n  /**\n   * _lastHandleNumber\n   * @type {Number}\n   */\n\n  this._lHN = 0;\n  /**\n   * _handlePromiseMap\n   * Contains the handleNumber on the left\n   * And the assigned promise on the right.\n   * This is stored so you can use cancelIdleCallback(handleNumber)\n   * to stop executing the callback.\n   * @type {Map<Number><Promise>}\n   */\n\n  this._hPM = new Map();\n  this._pHM = new Map(); // _promiseHandleMap\n};\n\nIdleQueue.prototype = {\n  isIdle: function isIdle() {\n    return this._qC < this._parallels;\n  },\n  /**\n   * creates a lock in the queue\n   * and returns an unlock-function to remove the lock from the queue\n   * @return {function} unlock function than must be called afterwards\n   */\n  lock: function lock() {\n    this._qC++;\n  },\n  unlock: function unlock() {\n    this._qC--;\n    _tryIdleCall(this);\n  },\n  /**\n   * wraps a function with lock/unlock and runs it\n   * @param  {function}  fun\n   * @return {Promise<any>}\n   */\n  wrapCall: function wrapCall(fun) {\n    var _this = this;\n    this.lock();\n    var maybePromise;\n    try {\n      maybePromise = fun();\n    } catch (err) {\n      this.unlock();\n      throw err;\n    }\n    if (!maybePromise.then || typeof maybePromise.then !== 'function') {\n      // no promise\n      this.unlock();\n      return maybePromise;\n    } else {\n      // promise\n      return maybePromise.then(function (ret) {\n        // sucessfull -> unlock before return\n        _this.unlock();\n        return ret;\n      })[\"catch\"](function (err) {\n        // not sucessfull -> unlock before throwing\n        _this.unlock();\n        throw err;\n      });\n    }\n  },\n  /**\n   * does the same as requestIdleCallback() but uses promises instead of the callback\n   * @param {{timeout?: number}} options like timeout\n   * @return {Promise<void>} promise that resolves when the database is in idle-mode\n   */\n  requestIdlePromise: function requestIdlePromise(options) {\n    var _this2 = this;\n    options = options || {};\n    var resolve;\n    var prom = new Promise(function (res) {\n      return resolve = res;\n    });\n    var resolveFromOutside = function resolveFromOutside() {\n      _removeIdlePromise(_this2, prom);\n      resolve();\n    };\n    prom._manRes = resolveFromOutside;\n    if (options.timeout) {\n      // if timeout has passed, resolve promise even if not idle\n      var timeoutObj = setTimeout(function () {\n        prom._manRes();\n      }, options.timeout);\n      prom._timeoutObj = timeoutObj;\n    }\n    this._iC.add(prom);\n    _tryIdleCall(this);\n    return prom;\n  },\n  /**\n   * remove the promise so it will never be resolved\n   * @param  {Promise} promise from requestIdlePromise()\n   * @return {void}\n   */\n  cancelIdlePromise: function cancelIdlePromise(promise) {\n    _removeIdlePromise(this, promise);\n  },\n  /**\n   * api equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n   * @param  {Function} callback\n   * @param  {options}   options  [description]\n   * @return {number} handle which can be used with cancelIdleCallback()\n   */\n  requestIdleCallback: function requestIdleCallback(callback, options) {\n    var handle = this._lHN++;\n    var promise = this.requestIdlePromise(options);\n    this._hPM.set(handle, promise);\n    this._pHM.set(promise, handle);\n    promise.then(function () {\n      return callback();\n    });\n    return handle;\n  },\n  /**\n   * API equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback\n   * @param  {number} handle returned from requestIdleCallback()\n   * @return {void}\n   */\n  cancelIdleCallback: function cancelIdleCallback(handle) {\n    var promise = this._hPM.get(handle);\n    this.cancelIdlePromise(promise);\n  },\n  /**\n   * clears and resets everything\n   * @return {void}\n   */\n  clear: function clear() {\n    var _this3 = this;\n\n    // remove all non-cleared\n    this._iC.forEach(function (promise) {\n      return _removeIdlePromise(_this3, promise);\n    });\n    this._qC = 0;\n    this._iC.clear();\n    this._hPM = new Map();\n    this._pHM = new Map();\n  }\n};\n/**\n * processes the oldest call of the idleCalls-queue\n * @return {Promise<void>}\n */\n\nfunction _resolveOneIdleCall(idleQueue) {\n  if (idleQueue._iC.size === 0) return;\n  var iterator = idleQueue._iC.values();\n  var oldestPromise = iterator.next().value;\n  oldestPromise._manRes(); // try to call the next tick\n\n  setTimeout(function () {\n    return _tryIdleCall(idleQueue);\n  }, 0);\n}\n/**\n * removes the promise from the queue and maps and also its corresponding handle-number\n * @param  {Promise} promise from requestIdlePromise()\n * @return {void}\n */\n\nfunction _removeIdlePromise(idleQueue, promise) {\n  if (!promise) return; // remove timeout if exists\n\n  if (promise._timeoutObj) clearTimeout(promise._timeoutObj); // remove handle-nr if exists\n\n  if (idleQueue._pHM.has(promise)) {\n    var handle = idleQueue._pHM.get(promise);\n    idleQueue._hPM[\"delete\"](handle);\n    idleQueue._pHM[\"delete\"](promise);\n  } // remove from queue\n\n  idleQueue._iC[\"delete\"](promise);\n}\n/**\n * resolves the last entry of this._iC\n * but only if the queue is empty\n * @return {Promise}\n */\n\nfunction _tryIdleCall(idleQueue) {\n  // ensure this does not run in parallel\n  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;\n  idleQueue._tryIR = true; // w8 one tick\n\n  setTimeout(function () {\n    // check if queue empty\n    if (!idleQueue.isIdle()) {\n      idleQueue._tryIR = false;\n      return;\n    }\n    /**\n     * wait 1 tick here\n     * because many functions do IO->CPU->IO\n     * which means the queue is empty for a short time\n     * but the ressource is not idle\n     */\n\n    setTimeout(function () {\n      // check if queue still empty\n      if (!idleQueue.isIdle()) {\n        idleQueue._tryIR = false;\n        return;\n      } // ressource is idle\n\n      _resolveOneIdleCall(idleQueue);\n      idleQueue._tryIR = false;\n    }, 0);\n  }, 0);\n}","map":{"version":3,"names":["IdleQueue","parallels","arguments","length","undefined","_parallels","_qC","_iC","Set","_lHN","_hPM","Map","_pHM","prototype","isIdle","lock","unlock","_tryIdleCall","wrapCall","fun","_this","maybePromise","err","then","ret","requestIdlePromise","options","_this2","resolve","prom","Promise","res","resolveFromOutside","_removeIdlePromise","_manRes","timeout","timeoutObj","setTimeout","_timeoutObj","add","cancelIdlePromise","promise","requestIdleCallback","callback","handle","set","cancelIdleCallback","get","clear","_this3","forEach","_resolveOneIdleCall","idleQueue","size","iterator","values","oldestPromise","next","value","clearTimeout","has","_tryIR"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/custom-idle-queue/dist/es/index.js"],"sourcesContent":["/**\n * Creates a new Idle-Queue\n * @constructor\n * @param {number} [parallels=1] amount of parrallel runs of the limited-ressource\n */\nexport var IdleQueue = function IdleQueue() {\n  var parallels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  this._parallels = parallels || 1;\n  /**\n   * _queueCounter\n   * each lock() increased this number\n   * each unlock() decreases this number\n   * If _qC==0, the state is in idle\n   * @type {Number}\n   */\n\n  this._qC = 0;\n  /**\n   * _idleCalls\n   * contains all promises that where added via requestIdlePromise()\n   * and not have been resolved\n   * @type {Set<Promise>} _iC with oldest promise first\n   */\n\n  this._iC = new Set();\n  /**\n   * _lastHandleNumber\n   * @type {Number}\n   */\n\n  this._lHN = 0;\n  /**\n   * _handlePromiseMap\n   * Contains the handleNumber on the left\n   * And the assigned promise on the right.\n   * This is stored so you can use cancelIdleCallback(handleNumber)\n   * to stop executing the callback.\n   * @type {Map<Number><Promise>}\n   */\n\n  this._hPM = new Map();\n  this._pHM = new Map(); // _promiseHandleMap\n};\nIdleQueue.prototype = {\n  isIdle: function isIdle() {\n    return this._qC < this._parallels;\n  },\n\n  /**\n   * creates a lock in the queue\n   * and returns an unlock-function to remove the lock from the queue\n   * @return {function} unlock function than must be called afterwards\n   */\n  lock: function lock() {\n    this._qC++;\n  },\n  unlock: function unlock() {\n    this._qC--;\n\n    _tryIdleCall(this);\n  },\n\n  /**\n   * wraps a function with lock/unlock and runs it\n   * @param  {function}  fun\n   * @return {Promise<any>}\n   */\n  wrapCall: function wrapCall(fun) {\n    var _this = this;\n\n    this.lock();\n    var maybePromise;\n\n    try {\n      maybePromise = fun();\n    } catch (err) {\n      this.unlock();\n      throw err;\n    }\n\n    if (!maybePromise.then || typeof maybePromise.then !== 'function') {\n      // no promise\n      this.unlock();\n      return maybePromise;\n    } else {\n      // promise\n      return maybePromise.then(function (ret) {\n        // sucessfull -> unlock before return\n        _this.unlock();\n\n        return ret;\n      })[\"catch\"](function (err) {\n        // not sucessfull -> unlock before throwing\n        _this.unlock();\n\n        throw err;\n      });\n    }\n  },\n\n  /**\n   * does the same as requestIdleCallback() but uses promises instead of the callback\n   * @param {{timeout?: number}} options like timeout\n   * @return {Promise<void>} promise that resolves when the database is in idle-mode\n   */\n  requestIdlePromise: function requestIdlePromise(options) {\n    var _this2 = this;\n\n    options = options || {};\n    var resolve;\n    var prom = new Promise(function (res) {\n      return resolve = res;\n    });\n\n    var resolveFromOutside = function resolveFromOutside() {\n      _removeIdlePromise(_this2, prom);\n\n      resolve();\n    };\n\n    prom._manRes = resolveFromOutside;\n\n    if (options.timeout) {\n      // if timeout has passed, resolve promise even if not idle\n      var timeoutObj = setTimeout(function () {\n        prom._manRes();\n      }, options.timeout);\n      prom._timeoutObj = timeoutObj;\n    }\n\n    this._iC.add(prom);\n\n    _tryIdleCall(this);\n\n    return prom;\n  },\n\n  /**\n   * remove the promise so it will never be resolved\n   * @param  {Promise} promise from requestIdlePromise()\n   * @return {void}\n   */\n  cancelIdlePromise: function cancelIdlePromise(promise) {\n    _removeIdlePromise(this, promise);\n  },\n\n  /**\n   * api equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n   * @param  {Function} callback\n   * @param  {options}   options  [description]\n   * @return {number} handle which can be used with cancelIdleCallback()\n   */\n  requestIdleCallback: function requestIdleCallback(callback, options) {\n    var handle = this._lHN++;\n    var promise = this.requestIdlePromise(options);\n\n    this._hPM.set(handle, promise);\n\n    this._pHM.set(promise, handle);\n\n    promise.then(function () {\n      return callback();\n    });\n    return handle;\n  },\n\n  /**\n   * API equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback\n   * @param  {number} handle returned from requestIdleCallback()\n   * @return {void}\n   */\n  cancelIdleCallback: function cancelIdleCallback(handle) {\n    var promise = this._hPM.get(handle);\n\n    this.cancelIdlePromise(promise);\n  },\n\n  /**\n   * clears and resets everything\n   * @return {void}\n   */\n  clear: function clear() {\n    var _this3 = this;\n\n    // remove all non-cleared\n    this._iC.forEach(function (promise) {\n      return _removeIdlePromise(_this3, promise);\n    });\n\n    this._qC = 0;\n\n    this._iC.clear();\n\n    this._hPM = new Map();\n    this._pHM = new Map();\n  }\n};\n/**\n * processes the oldest call of the idleCalls-queue\n * @return {Promise<void>}\n */\n\nfunction _resolveOneIdleCall(idleQueue) {\n  if (idleQueue._iC.size === 0) return;\n\n  var iterator = idleQueue._iC.values();\n\n  var oldestPromise = iterator.next().value;\n\n  oldestPromise._manRes(); // try to call the next tick\n\n\n  setTimeout(function () {\n    return _tryIdleCall(idleQueue);\n  }, 0);\n}\n/**\n * removes the promise from the queue and maps and also its corresponding handle-number\n * @param  {Promise} promise from requestIdlePromise()\n * @return {void}\n */\n\n\nfunction _removeIdlePromise(idleQueue, promise) {\n  if (!promise) return; // remove timeout if exists\n\n  if (promise._timeoutObj) clearTimeout(promise._timeoutObj); // remove handle-nr if exists\n\n  if (idleQueue._pHM.has(promise)) {\n    var handle = idleQueue._pHM.get(promise);\n\n    idleQueue._hPM[\"delete\"](handle);\n\n    idleQueue._pHM[\"delete\"](promise);\n  } // remove from queue\n\n\n  idleQueue._iC[\"delete\"](promise);\n}\n/**\n * resolves the last entry of this._iC\n * but only if the queue is empty\n * @return {Promise}\n */\n\n\nfunction _tryIdleCall(idleQueue) {\n  // ensure this does not run in parallel\n  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;\n  idleQueue._tryIR = true; // w8 one tick\n\n  setTimeout(function () {\n    // check if queue empty\n    if (!idleQueue.isIdle()) {\n      idleQueue._tryIR = false;\n      return;\n    }\n    /**\n     * wait 1 tick here\n     * because many functions do IO->CPU->IO\n     * which means the queue is empty for a short time\n     * but the ressource is not idle\n     */\n\n\n    setTimeout(function () {\n      // check if queue still empty\n      if (!idleQueue.isIdle()) {\n        idleQueue._tryIR = false;\n        return;\n      } // ressource is idle\n\n\n      _resolveOneIdleCall(idleQueue);\n\n      idleQueue._tryIR = false;\n    }, 0);\n  }, 0);\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIA,SAAS,GAAG,SAASA,SAASA,CAAA,EAAG;EAC1C,IAAIC,SAAS,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;EACrF,IAAI,CAACG,UAAU,GAAGJ,SAAS,IAAI,CAAC;EAChC;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE,IAAI,CAACK,GAAG,GAAG,CAAC;EACZ;AACF;AACA;AACA;AACA;AACA;;EAEE,IAAI,CAACC,GAAG,GAAG,IAAIC,GAAG,CAAC,CAAC;EACpB;AACF;AACA;AACA;;EAEE,IAAI,CAACC,IAAI,GAAG,CAAC;EACb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE,IAAI,CAACC,IAAI,GAAG,IAAIC,GAAG,CAAC,CAAC;EACrB,IAAI,CAACC,IAAI,GAAG,IAAID,GAAG,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC;;AACDX,SAAS,CAACa,SAAS,GAAG;EACpBC,MAAM,EAAE,SAASA,MAAMA,CAAA,EAAG;IACxB,OAAO,IAAI,CAACR,GAAG,GAAG,IAAI,CAACD,UAAU;EACnC,CAAC;EAED;AACF;AACA;AACA;AACA;EACEU,IAAI,EAAE,SAASA,IAAIA,CAAA,EAAG;IACpB,IAAI,CAACT,GAAG,EAAE;EACZ,CAAC;EACDU,MAAM,EAAE,SAASA,MAAMA,CAAA,EAAG;IACxB,IAAI,CAACV,GAAG,EAAE;IAEVW,YAAY,CAAC,IAAI,CAAC;EACpB,CAAC;EAED;AACF;AACA;AACA;AACA;EACEC,QAAQ,EAAE,SAASA,QAAQA,CAACC,GAAG,EAAE;IAC/B,IAAIC,KAAK,GAAG,IAAI;IAEhB,IAAI,CAACL,IAAI,CAAC,CAAC;IACX,IAAIM,YAAY;IAEhB,IAAI;MACFA,YAAY,GAAGF,GAAG,CAAC,CAAC;IACtB,CAAC,CAAC,OAAOG,GAAG,EAAE;MACZ,IAAI,CAACN,MAAM,CAAC,CAAC;MACb,MAAMM,GAAG;IACX;IAEA,IAAI,CAACD,YAAY,CAACE,IAAI,IAAI,OAAOF,YAAY,CAACE,IAAI,KAAK,UAAU,EAAE;MACjE;MACA,IAAI,CAACP,MAAM,CAAC,CAAC;MACb,OAAOK,YAAY;IACrB,CAAC,MAAM;MACL;MACA,OAAOA,YAAY,CAACE,IAAI,CAAC,UAAUC,GAAG,EAAE;QACtC;QACAJ,KAAK,CAACJ,MAAM,CAAC,CAAC;QAEd,OAAOQ,GAAG;MACZ,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,UAAUF,GAAG,EAAE;QACzB;QACAF,KAAK,CAACJ,MAAM,CAAC,CAAC;QAEd,MAAMM,GAAG;MACX,CAAC,CAAC;IACJ;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;EACEG,kBAAkB,EAAE,SAASA,kBAAkBA,CAACC,OAAO,EAAE;IACvD,IAAIC,MAAM,GAAG,IAAI;IAEjBD,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;IACvB,IAAIE,OAAO;IACX,IAAIC,IAAI,GAAG,IAAIC,OAAO,CAAC,UAAUC,GAAG,EAAE;MACpC,OAAOH,OAAO,GAAGG,GAAG;IACtB,CAAC,CAAC;IAEF,IAAIC,kBAAkB,GAAG,SAASA,kBAAkBA,CAAA,EAAG;MACrDC,kBAAkB,CAACN,MAAM,EAAEE,IAAI,CAAC;MAEhCD,OAAO,CAAC,CAAC;IACX,CAAC;IAEDC,IAAI,CAACK,OAAO,GAAGF,kBAAkB;IAEjC,IAAIN,OAAO,CAACS,OAAO,EAAE;MACnB;MACA,IAAIC,UAAU,GAAGC,UAAU,CAAC,YAAY;QACtCR,IAAI,CAACK,OAAO,CAAC,CAAC;MAChB,CAAC,EAAER,OAAO,CAACS,OAAO,CAAC;MACnBN,IAAI,CAACS,WAAW,GAAGF,UAAU;IAC/B;IAEA,IAAI,CAAC7B,GAAG,CAACgC,GAAG,CAACV,IAAI,CAAC;IAElBZ,YAAY,CAAC,IAAI,CAAC;IAElB,OAAOY,IAAI;EACb,CAAC;EAED;AACF;AACA;AACA;AACA;EACEW,iBAAiB,EAAE,SAASA,iBAAiBA,CAACC,OAAO,EAAE;IACrDR,kBAAkB,CAAC,IAAI,EAAEQ,OAAO,CAAC;EACnC,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,mBAAmB,EAAE,SAASA,mBAAmBA,CAACC,QAAQ,EAAEjB,OAAO,EAAE;IACnE,IAAIkB,MAAM,GAAG,IAAI,CAACnC,IAAI,EAAE;IACxB,IAAIgC,OAAO,GAAG,IAAI,CAAChB,kBAAkB,CAACC,OAAO,CAAC;IAE9C,IAAI,CAAChB,IAAI,CAACmC,GAAG,CAACD,MAAM,EAAEH,OAAO,CAAC;IAE9B,IAAI,CAAC7B,IAAI,CAACiC,GAAG,CAACJ,OAAO,EAAEG,MAAM,CAAC;IAE9BH,OAAO,CAAClB,IAAI,CAAC,YAAY;MACvB,OAAOoB,QAAQ,CAAC,CAAC;IACnB,CAAC,CAAC;IACF,OAAOC,MAAM;EACf,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;EACEE,kBAAkB,EAAE,SAASA,kBAAkBA,CAACF,MAAM,EAAE;IACtD,IAAIH,OAAO,GAAG,IAAI,CAAC/B,IAAI,CAACqC,GAAG,CAACH,MAAM,CAAC;IAEnC,IAAI,CAACJ,iBAAiB,CAACC,OAAO,CAAC;EACjC,CAAC;EAED;AACF;AACA;AACA;EACEO,KAAK,EAAE,SAASA,KAAKA,CAAA,EAAG;IACtB,IAAIC,MAAM,GAAG,IAAI;;IAEjB;IACA,IAAI,CAAC1C,GAAG,CAAC2C,OAAO,CAAC,UAAUT,OAAO,EAAE;MAClC,OAAOR,kBAAkB,CAACgB,MAAM,EAAER,OAAO,CAAC;IAC5C,CAAC,CAAC;IAEF,IAAI,CAACnC,GAAG,GAAG,CAAC;IAEZ,IAAI,CAACC,GAAG,CAACyC,KAAK,CAAC,CAAC;IAEhB,IAAI,CAACtC,IAAI,GAAG,IAAIC,GAAG,CAAC,CAAC;IACrB,IAAI,CAACC,IAAI,GAAG,IAAID,GAAG,CAAC,CAAC;EACvB;AACF,CAAC;AACD;AACA;AACA;AACA;;AAEA,SAASwC,mBAAmBA,CAACC,SAAS,EAAE;EACtC,IAAIA,SAAS,CAAC7C,GAAG,CAAC8C,IAAI,KAAK,CAAC,EAAE;EAE9B,IAAIC,QAAQ,GAAGF,SAAS,CAAC7C,GAAG,CAACgD,MAAM,CAAC,CAAC;EAErC,IAAIC,aAAa,GAAGF,QAAQ,CAACG,IAAI,CAAC,CAAC,CAACC,KAAK;EAEzCF,aAAa,CAACtB,OAAO,CAAC,CAAC,CAAC,CAAC;;EAGzBG,UAAU,CAAC,YAAY;IACrB,OAAOpB,YAAY,CAACmC,SAAS,CAAC;EAChC,CAAC,EAAE,CAAC,CAAC;AACP;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASnB,kBAAkBA,CAACmB,SAAS,EAAEX,OAAO,EAAE;EAC9C,IAAI,CAACA,OAAO,EAAE,OAAO,CAAC;;EAEtB,IAAIA,OAAO,CAACH,WAAW,EAAEqB,YAAY,CAAClB,OAAO,CAACH,WAAW,CAAC,CAAC,CAAC;;EAE5D,IAAIc,SAAS,CAACxC,IAAI,CAACgD,GAAG,CAACnB,OAAO,CAAC,EAAE;IAC/B,IAAIG,MAAM,GAAGQ,SAAS,CAACxC,IAAI,CAACmC,GAAG,CAACN,OAAO,CAAC;IAExCW,SAAS,CAAC1C,IAAI,CAAC,QAAQ,CAAC,CAACkC,MAAM,CAAC;IAEhCQ,SAAS,CAACxC,IAAI,CAAC,QAAQ,CAAC,CAAC6B,OAAO,CAAC;EACnC,CAAC,CAAC;;EAGFW,SAAS,CAAC7C,GAAG,CAAC,QAAQ,CAAC,CAACkC,OAAO,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASxB,YAAYA,CAACmC,SAAS,EAAE;EAC/B;EACA,IAAIA,SAAS,CAACS,MAAM,IAAIT,SAAS,CAAC7C,GAAG,CAAC8C,IAAI,KAAK,CAAC,EAAE;EAClDD,SAAS,CAACS,MAAM,GAAG,IAAI,CAAC,CAAC;;EAEzBxB,UAAU,CAAC,YAAY;IACrB;IACA,IAAI,CAACe,SAAS,CAACtC,MAAM,CAAC,CAAC,EAAE;MACvBsC,SAAS,CAACS,MAAM,GAAG,KAAK;MACxB;IACF;IACA;AACJ;AACA;AACA;AACA;AACA;;IAGIxB,UAAU,CAAC,YAAY;MACrB;MACA,IAAI,CAACe,SAAS,CAACtC,MAAM,CAAC,CAAC,EAAE;QACvBsC,SAAS,CAACS,MAAM,GAAG,KAAK;QACxB;MACF,CAAC,CAAC;;MAGFV,mBAAmB,CAACC,SAAS,CAAC;MAE9BA,SAAS,CAACS,MAAM,GAAG,KAAK;IAC1B,CAAC,EAAE,CAAC,CAAC;EACP,CAAC,EAAE,CAAC,CAAC;AACP"},"metadata":{},"sourceType":"module","externalDependencies":[]}