{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * When a persistent RxStorage is used in more the one JavaScript process,\n * the even stream of the changestream() function must be broadcasted to the other\n * RxStorageInstances of the same databaseName+collectionName.\n *\n * In the past this was done by RxDB but it makes more sense to do this\n * at the RxStorage level so that the broadcasting etc can all happen inside of a WebWorker\n * and not on the main thread.\n * Also it makes it less complex to stack up different RxStorages onto each other\n * like what we do with the in-memory plugin.\n *\n * This is intended to be used inside of createStorageInstance() of a storage.\n * Do not use this if the storage anyway broadcasts the events like when using MongoDB\n * or in the future W3C might introduce a way to listen to IndexedDB changes.\n */\n\nimport { Subject } from 'rxjs';\nimport { mergeWith } from 'rxjs/operators';\nimport { BroadcastChannel } from 'broadcast-channel';\n\n/**\n * The broadcast-channel is reused by the databaseInstanceToken.\n * This is required so that it is easy to simulate multi-tab usage\n * in the test where different instances of the same RxDatabase must\n * have different broadcast channels.\n * But also it ensures that for each RxDatabase we only create a single\n * broadcast channel that can even be reused in the leader election plugin.\n *\n * TODO at the end of the unit tests,\n * we should ensure that all channels are closed and cleaned up.\n * Otherwise we have forgot something.\n */\nexport var BROADCAST_CHANNEL_BY_TOKEN = new Map();\nexport function getBroadcastChannelReference(databaseInstanceToken, databaseName, refObject) {\n  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);\n  if (!state) {\n    state = {\n      /**\n       * We have to use the databaseName instead of the databaseInstanceToken\n       * in the BroadcastChannel name because different instances must end with the same\n       * channel name to be able to broadcast messages between each other.\n       */\n      bc: new BroadcastChannel('RxDB:' + databaseName),\n      refs: new Set()\n    };\n    BROADCAST_CHANNEL_BY_TOKEN.set(databaseInstanceToken, state);\n  }\n  state.refs.add(refObject);\n  return state.bc;\n}\nexport function removeBroadcastChannelReference(databaseInstanceToken, refObject) {\n  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);\n  if (!state) {\n    return;\n  }\n  state.refs.delete(refObject);\n  if (state.refs.size === 0) {\n    BROADCAST_CHANNEL_BY_TOKEN.delete(databaseInstanceToken);\n    return state.bc.close();\n  }\n}\nexport function addRxStorageMultiInstanceSupport(storageName, instanceCreationParams, instance,\n/**\n * If provided, that channel will be used\n * instead of an own one.\n */\nprovidedBroadcastChannel) {\n  if (!instanceCreationParams.multiInstance) {\n    return;\n  }\n  var broadcastChannel = providedBroadcastChannel ? providedBroadcastChannel : getBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance.databaseName, instance);\n  var changesFromOtherInstances$ = new Subject();\n  var eventListener = msg => {\n    if (msg.storageName === storageName && msg.databaseName === instanceCreationParams.databaseName && msg.collectionName === instanceCreationParams.collectionName && msg.version === instanceCreationParams.schema.version) {\n      changesFromOtherInstances$.next(msg.eventBulk);\n    }\n  };\n  broadcastChannel.addEventListener('message', eventListener);\n  var oldChangestream$ = instance.changeStream();\n  var closed = false;\n  var sub = oldChangestream$.subscribe(eventBulk => {\n    if (closed) {\n      return;\n    }\n    broadcastChannel.postMessage({\n      storageName: storageName,\n      databaseName: instanceCreationParams.databaseName,\n      collectionName: instanceCreationParams.collectionName,\n      version: instanceCreationParams.schema.version,\n      eventBulk\n    });\n  });\n  instance.changeStream = function () {\n    return changesFromOtherInstances$.asObservable().pipe(mergeWith(oldChangestream$));\n  };\n  var oldClose = instance.close.bind(instance);\n  instance.close = /*#__PURE__*/_asyncToGenerator(function* () {\n    closed = true;\n    sub.unsubscribe();\n    broadcastChannel.removeEventListener('message', eventListener);\n    if (!providedBroadcastChannel) {\n      yield removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);\n    }\n    return oldClose();\n  });\n  var oldRemove = instance.remove.bind(instance);\n  instance.remove = /*#__PURE__*/_asyncToGenerator(function* () {\n    closed = true;\n    sub.unsubscribe();\n    broadcastChannel.removeEventListener('message', eventListener);\n    if (!providedBroadcastChannel) {\n      yield removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);\n    }\n    return oldRemove();\n  });\n}","map":{"version":3,"names":["Subject","mergeWith","BroadcastChannel","BROADCAST_CHANNEL_BY_TOKEN","Map","getBroadcastChannelReference","databaseInstanceToken","databaseName","refObject","state","get","bc","refs","Set","set","add","removeBroadcastChannelReference","delete","size","close","addRxStorageMultiInstanceSupport","storageName","instanceCreationParams","instance","providedBroadcastChannel","multiInstance","broadcastChannel","changesFromOtherInstances$","eventListener","msg","collectionName","version","schema","next","eventBulk","addEventListener","oldChangestream$","changeStream","closed","sub","subscribe","postMessage","asObservable","pipe","oldClose","bind","_asyncToGenerator","unsubscribe","removeEventListener","oldRemove","remove"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/rx-storage-multiinstance.js"],"sourcesContent":["/**\n * When a persistent RxStorage is used in more the one JavaScript process,\n * the even stream of the changestream() function must be broadcasted to the other\n * RxStorageInstances of the same databaseName+collectionName.\n *\n * In the past this was done by RxDB but it makes more sense to do this\n * at the RxStorage level so that the broadcasting etc can all happen inside of a WebWorker\n * and not on the main thread.\n * Also it makes it less complex to stack up different RxStorages onto each other\n * like what we do with the in-memory plugin.\n *\n * This is intended to be used inside of createStorageInstance() of a storage.\n * Do not use this if the storage anyway broadcasts the events like when using MongoDB\n * or in the future W3C might introduce a way to listen to IndexedDB changes.\n */\n\nimport { Subject } from 'rxjs';\nimport { mergeWith } from 'rxjs/operators';\nimport { BroadcastChannel } from 'broadcast-channel';\n\n/**\n * The broadcast-channel is reused by the databaseInstanceToken.\n * This is required so that it is easy to simulate multi-tab usage\n * in the test where different instances of the same RxDatabase must\n * have different broadcast channels.\n * But also it ensures that for each RxDatabase we only create a single\n * broadcast channel that can even be reused in the leader election plugin.\n *\n * TODO at the end of the unit tests,\n * we should ensure that all channels are closed and cleaned up.\n * Otherwise we have forgot something.\n */\nexport var BROADCAST_CHANNEL_BY_TOKEN = new Map();\nexport function getBroadcastChannelReference(databaseInstanceToken, databaseName, refObject) {\n  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);\n  if (!state) {\n    state = {\n      /**\n       * We have to use the databaseName instead of the databaseInstanceToken\n       * in the BroadcastChannel name because different instances must end with the same\n       * channel name to be able to broadcast messages between each other.\n       */\n      bc: new BroadcastChannel('RxDB:' + databaseName),\n      refs: new Set()\n    };\n    BROADCAST_CHANNEL_BY_TOKEN.set(databaseInstanceToken, state);\n  }\n  state.refs.add(refObject);\n  return state.bc;\n}\nexport function removeBroadcastChannelReference(databaseInstanceToken, refObject) {\n  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);\n  if (!state) {\n    return;\n  }\n  state.refs.delete(refObject);\n  if (state.refs.size === 0) {\n    BROADCAST_CHANNEL_BY_TOKEN.delete(databaseInstanceToken);\n    return state.bc.close();\n  }\n}\nexport function addRxStorageMultiInstanceSupport(storageName, instanceCreationParams, instance,\n/**\n * If provided, that channel will be used\n * instead of an own one.\n */\nprovidedBroadcastChannel) {\n  if (!instanceCreationParams.multiInstance) {\n    return;\n  }\n  var broadcastChannel = providedBroadcastChannel ? providedBroadcastChannel : getBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance.databaseName, instance);\n  var changesFromOtherInstances$ = new Subject();\n  var eventListener = msg => {\n    if (msg.storageName === storageName && msg.databaseName === instanceCreationParams.databaseName && msg.collectionName === instanceCreationParams.collectionName && msg.version === instanceCreationParams.schema.version) {\n      changesFromOtherInstances$.next(msg.eventBulk);\n    }\n  };\n  broadcastChannel.addEventListener('message', eventListener);\n  var oldChangestream$ = instance.changeStream();\n  var closed = false;\n  var sub = oldChangestream$.subscribe(eventBulk => {\n    if (closed) {\n      return;\n    }\n    broadcastChannel.postMessage({\n      storageName: storageName,\n      databaseName: instanceCreationParams.databaseName,\n      collectionName: instanceCreationParams.collectionName,\n      version: instanceCreationParams.schema.version,\n      eventBulk\n    });\n  });\n  instance.changeStream = function () {\n    return changesFromOtherInstances$.asObservable().pipe(mergeWith(oldChangestream$));\n  };\n  var oldClose = instance.close.bind(instance);\n  instance.close = async function () {\n    closed = true;\n    sub.unsubscribe();\n    broadcastChannel.removeEventListener('message', eventListener);\n    if (!providedBroadcastChannel) {\n      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);\n    }\n    return oldClose();\n  };\n  var oldRemove = instance.remove.bind(instance);\n  instance.remove = async function () {\n    closed = true;\n    sub.unsubscribe();\n    broadcastChannel.removeEventListener('message', eventListener);\n    if (!providedBroadcastChannel) {\n      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);\n    }\n    return oldRemove();\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}