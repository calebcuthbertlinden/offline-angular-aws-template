{"ast":null,"code":"import { AbstractNode } from './abstract-node';\nimport { Branches } from './branches';\nimport { lastOfArray, booleanToBooleanString } from './util';\nimport { bddToSimpleBdd } from './minimal-string';\nexport class RootNode extends AbstractNode {\n  constructor() {\n    super(0, null, 'RootNode');\n    this.branches = new Branches(this);\n    this.levels = [];\n    this.nodesByLevel = new Map();\n    this.levels.push(0);\n    const level0Set = new Set();\n    level0Set.add(this);\n    this.nodesByLevel.set(0, level0Set);\n  }\n  addNode(node) {\n    const level = node.level;\n    if (!this.levels.includes(level)) {\n      this.levels.push(level);\n    }\n    this.ensureLevelSetExists(level);\n    const set = this.nodesByLevel.get(level);\n    set === null || set === void 0 ? void 0 : set.add(node);\n  }\n  removeNode(node) {\n    const set = this.nodesByLevel.get(node.level);\n    if (!set.has(node)) {\n      throw new Error('removed non-existing node ' + node.id);\n    }\n    set.delete(node);\n  }\n  ensureLevelSetExists(level) {\n    if (!this.nodesByLevel.has(level)) {\n      this.nodesByLevel.set(level, new Set());\n    }\n  }\n  getLevels() {\n    return Array.from(this.levels).sort((a, b) => a - b);\n  }\n  getNodesOfLevel(level) {\n    this.ensureLevelSetExists(level);\n    const set = this.nodesByLevel.get(level);\n    return Array.from(set);\n  }\n  countNodes() {\n    let ret = 0;\n    this.getLevels().forEach(level => {\n      const nodesAmount = this.getNodesOfLevel(level).length;\n      ret = ret + nodesAmount;\n    });\n    return ret;\n  }\n  /**\n   * applies the reduction rules to the whole bdd\n   */\n  minimize(logState = false) {\n    // console.log('minimize(): START ###############');\n    let done = false;\n    while (!done) {\n      if (logState) {\n        console.log('minimize() itterate once');\n      }\n      let successCount = 0;\n      let lastLevel = lastOfArray(this.getLevels());\n      while (lastLevel > 0) {\n        const nodes = this.getNodesOfLevel(lastLevel);\n        if (logState) {\n          console.log('minimize() run for level ' + lastLevel + ' with ' + nodes.length + ' nodes');\n          // console.dir(nodes);\n        }\n\n        let nodeCount = 0;\n        for (const node of nodes) {\n          nodeCount++;\n          // do not run that often because it is expensive\n          if (logState && nodeCount % 4000 === 0) {\n            console.log('minimize() node #' + node.id);\n          }\n          if (node.isLeafNode()) {\n            // console.log('have leaf node ' + node.id);\n            const reductionDone = node.asLeafNode().applyEliminationRule();\n            if (reductionDone) {\n              successCount++;\n            }\n          }\n          if (!node.deleted && node.isInternalNode()) {\n            const useNode = node;\n            const reductionDone = useNode.applyReductionRule();\n            let eliminationDone = false;\n            if (!useNode.deleted) {\n              // not might now be deleted from reduction-rule\n              eliminationDone = useNode.applyEliminationRule(nodes);\n            }\n            if (reductionDone || eliminationDone) {\n              successCount++;\n            }\n          }\n        }\n        lastLevel--;\n      }\n      if (successCount === 0) {\n        // could do no more optimisations\n        done = true;\n      } else {\n        if (logState) {\n          console.log('minimize() itteration done with ' + successCount + ' minimisations');\n        }\n      }\n    }\n  }\n  getLeafNodes() {\n    const lastLevel = lastOfArray(this.getLevels());\n    const leafNodes = this.getNodesOfLevel(lastLevel).reverse();\n    return leafNodes;\n  }\n  /**\n   * strips all leaf-nodes\n   * with the given value\n   */\n  removeIrrelevantLeafNodes(leafNodeValue) {\n    let done = false;\n    while (!done) {\n      let countRemoved = 0;\n      const leafNodes = this.getLeafNodes();\n      for (const leafNode of leafNodes) {\n        const removed = leafNode.removeIfValueEquals(leafNodeValue);\n        if (removed) {\n          countRemoved++;\n        }\n      }\n      this.minimize();\n      if (countRemoved === 0) {\n        done = true;\n      }\n    }\n  }\n  resolve(fns, booleanFunctionInput) {\n    let currentNode = this;\n    while (true) {\n      const booleanResult = fns[currentNode.level](booleanFunctionInput);\n      const branchKey = booleanToBooleanString(booleanResult);\n      currentNode = currentNode.branches.getBranch(branchKey);\n      if (currentNode.isLeafNode()) {\n        return currentNode.asLeafNode().value;\n      }\n    }\n  }\n  toSimpleBdd() {\n    return bddToSimpleBdd(this);\n  }\n}","map":{"version":3,"names":["AbstractNode","Branches","lastOfArray","booleanToBooleanString","bddToSimpleBdd","RootNode","constructor","branches","levels","nodesByLevel","Map","push","level0Set","Set","add","set","addNode","node","level","includes","ensureLevelSetExists","get","removeNode","has","Error","id","delete","getLevels","Array","from","sort","a","b","getNodesOfLevel","countNodes","ret","forEach","nodesAmount","length","minimize","logState","done","console","log","successCount","lastLevel","nodes","nodeCount","isLeafNode","reductionDone","asLeafNode","applyEliminationRule","deleted","isInternalNode","useNode","applyReductionRule","eliminationDone","getLeafNodes","leafNodes","reverse","removeIrrelevantLeafNodes","leafNodeValue","countRemoved","leafNode","removed","removeIfValueEquals","resolve","fns","booleanFunctionInput","currentNode","booleanResult","branchKey","getBranch","value","toSimpleBdd"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/binary-decision-diagram/dist/es/root-node.js"],"sourcesContent":["import { AbstractNode } from './abstract-node';\nimport { Branches } from './branches';\nimport { lastOfArray, booleanToBooleanString } from './util';\nimport { bddToSimpleBdd } from './minimal-string';\nexport class RootNode extends AbstractNode {\n    constructor() {\n        super(0, null, 'RootNode');\n        this.branches = new Branches(this);\n        this.levels = [];\n        this.nodesByLevel = new Map();\n        this.levels.push(0);\n        const level0Set = new Set();\n        level0Set.add(this);\n        this.nodesByLevel.set(0, level0Set);\n    }\n    addNode(node) {\n        const level = node.level;\n        if (!this.levels.includes(level)) {\n            this.levels.push(level);\n        }\n        this.ensureLevelSetExists(level);\n        const set = this.nodesByLevel.get(level);\n        set === null || set === void 0 ? void 0 : set.add(node);\n    }\n    removeNode(node) {\n        const set = this.nodesByLevel.get(node.level);\n        if (!set.has(node)) {\n            throw new Error('removed non-existing node ' + node.id);\n        }\n        set.delete(node);\n    }\n    ensureLevelSetExists(level) {\n        if (!this.nodesByLevel.has(level)) {\n            this.nodesByLevel.set(level, new Set());\n        }\n    }\n    getLevels() {\n        return Array.from(this.levels).sort((a, b) => a - b);\n    }\n    getNodesOfLevel(level) {\n        this.ensureLevelSetExists(level);\n        const set = this.nodesByLevel.get(level);\n        return Array.from(set);\n    }\n    countNodes() {\n        let ret = 0;\n        this.getLevels().forEach(level => {\n            const nodesAmount = this.getNodesOfLevel(level).length;\n            ret = ret + nodesAmount;\n        });\n        return ret;\n    }\n    /**\n     * applies the reduction rules to the whole bdd\n     */\n    minimize(logState = false) {\n        // console.log('minimize(): START ###############');\n        let done = false;\n        while (!done) {\n            if (logState) {\n                console.log('minimize() itterate once');\n            }\n            let successCount = 0;\n            let lastLevel = lastOfArray(this.getLevels());\n            while (lastLevel > 0) {\n                const nodes = this.getNodesOfLevel(lastLevel);\n                if (logState) {\n                    console.log('minimize() run for level ' + lastLevel +\n                        ' with ' + nodes.length + ' nodes');\n                    // console.dir(nodes);\n                }\n                let nodeCount = 0;\n                for (const node of nodes) {\n                    nodeCount++;\n                    // do not run that often because it is expensive\n                    if (logState && nodeCount % 4000 === 0) {\n                        console.log('minimize() node #' + node.id);\n                    }\n                    if (node.isLeafNode()) {\n                        // console.log('have leaf node ' + node.id);\n                        const reductionDone = node.asLeafNode().applyEliminationRule();\n                        if (reductionDone) {\n                            successCount++;\n                        }\n                    }\n                    if (!node.deleted && node.isInternalNode()) {\n                        const useNode = node;\n                        const reductionDone = useNode.applyReductionRule();\n                        let eliminationDone = false;\n                        if (!useNode.deleted) {\n                            // not might now be deleted from reduction-rule\n                            eliminationDone = useNode.applyEliminationRule(nodes);\n                        }\n                        if (reductionDone || eliminationDone) {\n                            successCount++;\n                        }\n                    }\n                }\n                lastLevel--;\n            }\n            if (successCount === 0) {\n                // could do no more optimisations\n                done = true;\n            }\n            else {\n                if (logState) {\n                    console.log('minimize() itteration done with ' +\n                        successCount + ' minimisations');\n                }\n            }\n        }\n    }\n    getLeafNodes() {\n        const lastLevel = lastOfArray(this.getLevels());\n        const leafNodes = this.getNodesOfLevel(lastLevel).reverse();\n        return leafNodes;\n    }\n    /**\n     * strips all leaf-nodes\n     * with the given value\n     */\n    removeIrrelevantLeafNodes(leafNodeValue) {\n        let done = false;\n        while (!done) {\n            let countRemoved = 0;\n            const leafNodes = this.getLeafNodes();\n            for (const leafNode of leafNodes) {\n                const removed = leafNode.removeIfValueEquals(leafNodeValue);\n                if (removed) {\n                    countRemoved++;\n                }\n            }\n            this.minimize();\n            if (countRemoved === 0) {\n                done = true;\n            }\n        }\n    }\n    resolve(fns, booleanFunctionInput) {\n        let currentNode = this;\n        while (true) {\n            const booleanResult = fns[currentNode.level](booleanFunctionInput);\n            const branchKey = booleanToBooleanString(booleanResult);\n            currentNode = currentNode.branches.getBranch(branchKey);\n            if (currentNode.isLeafNode()) {\n                return currentNode.asLeafNode().value;\n            }\n        }\n    }\n    toSimpleBdd() {\n        return bddToSimpleBdd(this);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}