{"ast":null,"code":"/**\n * Predicates used for Query and Expression operators.\n */\nimport { computeValue } from \"../core\";\nimport { Query } from \"../query\";\nimport { ensureArray, flatten, getType, inArray, intersection, isArray, isBoolean, isDate, isEmpty, isEqual, isNil, isNumber, isObject, isOperator, isRegExp, isString, MAX_INT, MAX_LONG, MIN_INT, MIN_LONG, resolve, truthy } from \"../util\";\n/**\n * Returns a query operator created from the predicate\n *\n * @param predicate Predicate function\n */\nexport function createQueryOperator(predicate) {\n  return (selector, value, options) => {\n    const opts = {\n      unwrapArray: true\n    };\n    const depth = Math.max(1, selector.split(\".\").length - 1);\n    return obj => {\n      // value of field must be fully resolved.\n      const lhs = resolve(obj, selector, opts);\n      return predicate(lhs, value, {\n        ...options,\n        depth\n      });\n    };\n  };\n}\n/**\n * Returns an expression operator created from the predicate\n *\n * @param predicate Predicate function\n */\nexport function createExpressionOperator(predicate) {\n  return (obj, expr, options) => {\n    const args = computeValue(obj, expr, null, options);\n    return predicate(...args);\n  };\n}\n/**\n * Checks that two values are equal.\n *\n * @param a         The lhs operand as resolved from the object by the given selector\n * @param b         The rhs operand provided by the user\n * @returns {*}\n */\nexport function $eq(a, b, options) {\n  // start with simple equality check\n  if (isEqual(a, b)) return true;\n  // https://docs.mongodb.com/manual/tutorial/query-for-null-fields/\n  if (isNil(a) && isNil(b)) return true;\n  // check\n  if (a instanceof Array) {\n    const eq = isEqual.bind(null, b);\n    return a.some(eq) || flatten(a, options?.depth).some(eq);\n  }\n  return false;\n}\n/**\n * Matches all values that are not equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $ne(a, b, options) {\n  return !$eq(a, b, options);\n}\n/**\n * Matches any of the values that exist in an array specified in the query.\n *\n * @param a\n * @param b\n * @returns {*}\n */\nexport function $in(a, b, options) {\n  // queries for null should be able to find undefined fields\n  if (isNil(a)) return b.some(v => v === null);\n  return intersection([ensureArray(a), b], options?.hashFunction).length > 0;\n}\n/**\n * Matches values that do not exist in an array specified to the query.\n *\n * @param a\n * @param b\n * @returns {*|boolean}\n */\nexport function $nin(a, b, options) {\n  return !$in(a, b, options);\n}\n/**\n * Matches values that are less than the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $lt(a, b, options) {\n  return compare(a, b, (x, y) => x < y);\n}\n/**\n * Matches values that are less than or equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $lte(a, b, options) {\n  return compare(a, b, (x, y) => x <= y);\n}\n/**\n * Matches values that are greater than the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $gt(a, b, options) {\n  return compare(a, b, (x, y) => x > y);\n}\n/**\n * Matches values that are greater than or equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $gte(a, b, options) {\n  return compare(a, b, (x, y) => x >= y);\n}\n/**\n * Performs a modulo operation on the value of a field and selects documents with a specified result.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $mod(a, b, options) {\n  return ensureArray(a).some(x => b.length === 2 && x % b[0] === b[1]);\n}\n/**\n * Selects documents where values match a specified regular expression.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $regex(a, b, options) {\n  const lhs = ensureArray(a);\n  const match = x => isString(x) && truthy(b.exec(x), options.useStrictMode);\n  return lhs.some(match) || flatten(lhs, 1).some(match);\n}\n/**\n * Matches documents that have the specified field.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $exists(a, b, options) {\n  return (b === false || b === 0) && a === undefined || (b === true || b === 1) && a !== undefined;\n}\n/**\n * Matches arrays that contain all elements specified in the query.\n *\n * @param values\n * @param queries\n * @returns boolean\n */\nexport function $all(values, queries, options) {\n  if (!isArray(values) || !isArray(queries) || !values.length || !queries.length) {\n    return false;\n  }\n  let matched = true;\n  for (const query of queries) {\n    // no need to check all the queries.\n    if (!matched) break;\n    if (isObject(query) && inArray(Object.keys(query), \"$elemMatch\")) {\n      matched = $elemMatch(values, query[\"$elemMatch\"], options);\n    } else if (query instanceof RegExp) {\n      matched = values.some(s => typeof s === \"string\" && query.test(s));\n    } else {\n      matched = values.some(v => isEqual(query, v));\n    }\n  }\n  return matched;\n}\n/**\n * Selects documents if the array field is a specified size.\n *\n * @param a\n * @param b\n * @returns {*|boolean}\n */\nexport function $size(a, b, options) {\n  return Array.isArray(a) && a.length === b;\n}\nfunction isNonBooleanOperator(name) {\n  return isOperator(name) && [\"$and\", \"$or\", \"$nor\"].indexOf(name) === -1;\n}\n/**\n * Selects documents if element in the array field matches all the specified $elemMatch condition.\n *\n * @param a {Array} element to match against\n * @param b {Object} subquery\n */\nexport function $elemMatch(a, b, options) {\n  // should return false for non-matching input\n  if (isArray(a) && !isEmpty(a)) {\n    let format = x => x;\n    let criteria = b;\n    // If we find a boolean operator in the subquery, we fake a field to point to it. This is an\n    // attempt to ensure that it is a valid criteria. We cannot make this substitution for operators\n    // like $and/$or/$nor; as otherwise, this faking will break our query.\n    if (Object.keys(b).every(isNonBooleanOperator)) {\n      criteria = {\n        temp: b\n      };\n      format = x => ({\n        temp: x\n      });\n    }\n    const query = new Query(criteria, options);\n    for (let i = 0, len = a.length; i < len; i++) {\n      if (query.test(format(a[i]))) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n// helper functions\nconst isNull = a => a === null;\nconst isInt = a => isNumber(a) && a >= MIN_INT && a <= MAX_INT && a.toString().indexOf(\".\") === -1;\nconst isLong = a => isNumber(a) && a >= MIN_LONG && a <= MAX_LONG && a.toString().indexOf(\".\") === -1;\n/** Mapping of type to predicate */\nconst compareFuncs = {\n  array: isArray,\n  bool: isBoolean,\n  boolean: isBoolean,\n  date: isDate,\n  decimal: isNumber,\n  double: isNumber,\n  int: isInt,\n  long: isLong,\n  number: isNumber,\n  null: isNull,\n  object: isObject,\n  regex: isRegExp,\n  regexp: isRegExp,\n  string: isString,\n  // added for completeness\n  undefined: isNil,\n  function: _ => {\n    throw new Error(\"unsupported type key `function`.\");\n  },\n  // Mongo identifiers\n  1: isNumber,\n  2: isString,\n  3: isObject,\n  4: isArray,\n  6: isNil,\n  8: isBoolean,\n  9: isDate,\n  10: isNull,\n  11: isRegExp,\n  16: isInt,\n  18: isLong,\n  19: isNumber //decimal\n};\n/**\n * Selects documents if a field is of the specified type.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction compareType(a, b, _) {\n  const f = compareFuncs[b];\n  return f ? f(a) : false;\n}\n/**\n * Selects documents if a field is of the specified type.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $type(a, b, options) {\n  return Array.isArray(b) ? b.findIndex(t => compareType(a, t, options)) >= 0 : compareType(a, b, options);\n}\nfunction compare(a, b, f) {\n  return ensureArray(a).some(x => getType(x) === getType(b) && f(x, b));\n}","map":{"version":3,"names":["computeValue","Query","ensureArray","flatten","getType","inArray","intersection","isArray","isBoolean","isDate","isEmpty","isEqual","isNil","isNumber","isObject","isOperator","isRegExp","isString","MAX_INT","MAX_LONG","MIN_INT","MIN_LONG","resolve","truthy","createQueryOperator","predicate","selector","value","options","opts","unwrapArray","depth","Math","max","split","length","obj","lhs","createExpressionOperator","expr","args","$eq","a","b","Array","eq","bind","some","$ne","$in","v","hashFunction","$nin","$lt","compare","x","y","$lte","$gt","$gte","$mod","$regex","match","exec","useStrictMode","$exists","undefined","$all","values","queries","matched","query","Object","keys","$elemMatch","RegExp","s","test","$size","isNonBooleanOperator","name","indexOf","format","criteria","every","temp","i","len","isNull","isInt","toString","isLong","compareFuncs","array","bool","boolean","date","decimal","double","int","long","number","null","object","regex","regexp","string","function","_","Error","compareType","f","$type","findIndex","t"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/mingo/es/operators/_predicates.js"],"sourcesContent":["/**\n * Predicates used for Query and Expression operators.\n */\nimport { computeValue, } from \"../core\";\nimport { Query } from \"../query\";\nimport { ensureArray, flatten, getType, inArray, intersection, isArray, isBoolean, isDate, isEmpty, isEqual, isNil, isNumber, isObject, isOperator, isRegExp, isString, MAX_INT, MAX_LONG, MIN_INT, MIN_LONG, resolve, truthy, } from \"../util\";\n/**\n * Returns a query operator created from the predicate\n *\n * @param predicate Predicate function\n */\nexport function createQueryOperator(predicate) {\n    return (selector, value, options) => {\n        const opts = { unwrapArray: true };\n        const depth = Math.max(1, selector.split(\".\").length - 1);\n        return (obj) => {\n            // value of field must be fully resolved.\n            const lhs = resolve(obj, selector, opts);\n            return predicate(lhs, value, { ...options, depth });\n        };\n    };\n}\n/**\n * Returns an expression operator created from the predicate\n *\n * @param predicate Predicate function\n */\nexport function createExpressionOperator(predicate) {\n    return (obj, expr, options) => {\n        const args = computeValue(obj, expr, null, options);\n        return predicate(...args);\n    };\n}\n/**\n * Checks that two values are equal.\n *\n * @param a         The lhs operand as resolved from the object by the given selector\n * @param b         The rhs operand provided by the user\n * @returns {*}\n */\nexport function $eq(a, b, options) {\n    // start with simple equality check\n    if (isEqual(a, b))\n        return true;\n    // https://docs.mongodb.com/manual/tutorial/query-for-null-fields/\n    if (isNil(a) && isNil(b))\n        return true;\n    // check\n    if (a instanceof Array) {\n        const eq = isEqual.bind(null, b);\n        return a.some(eq) || flatten(a, options?.depth).some(eq);\n    }\n    return false;\n}\n/**\n * Matches all values that are not equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $ne(a, b, options) {\n    return !$eq(a, b, options);\n}\n/**\n * Matches any of the values that exist in an array specified in the query.\n *\n * @param a\n * @param b\n * @returns {*}\n */\nexport function $in(a, b, options) {\n    // queries for null should be able to find undefined fields\n    if (isNil(a))\n        return b.some((v) => v === null);\n    return intersection([ensureArray(a), b], options?.hashFunction).length > 0;\n}\n/**\n * Matches values that do not exist in an array specified to the query.\n *\n * @param a\n * @param b\n * @returns {*|boolean}\n */\nexport function $nin(a, b, options) {\n    return !$in(a, b, options);\n}\n/**\n * Matches values that are less than the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $lt(a, b, options) {\n    return compare(a, b, (x, y) => x < y);\n}\n/**\n * Matches values that are less than or equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $lte(a, b, options) {\n    return compare(a, b, (x, y) => x <= y);\n}\n/**\n * Matches values that are greater than the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $gt(a, b, options) {\n    return compare(a, b, (x, y) => x > y);\n}\n/**\n * Matches values that are greater than or equal to the value specified in the query.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $gte(a, b, options) {\n    return compare(a, b, (x, y) => x >= y);\n}\n/**\n * Performs a modulo operation on the value of a field and selects documents with a specified result.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $mod(a, b, options) {\n    return ensureArray(a).some((x) => b.length === 2 && x % b[0] === b[1]);\n}\n/**\n * Selects documents where values match a specified regular expression.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $regex(a, b, options) {\n    const lhs = ensureArray(a);\n    const match = (x) => isString(x) && truthy(b.exec(x), options.useStrictMode);\n    return lhs.some(match) || flatten(lhs, 1).some(match);\n}\n/**\n * Matches documents that have the specified field.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $exists(a, b, options) {\n    return (((b === false || b === 0) && a === undefined) ||\n        ((b === true || b === 1) && a !== undefined));\n}\n/**\n * Matches arrays that contain all elements specified in the query.\n *\n * @param values\n * @param queries\n * @returns boolean\n */\nexport function $all(values, queries, options) {\n    if (!isArray(values) ||\n        !isArray(queries) ||\n        !values.length ||\n        !queries.length) {\n        return false;\n    }\n    let matched = true;\n    for (const query of queries) {\n        // no need to check all the queries.\n        if (!matched)\n            break;\n        if (isObject(query) && inArray(Object.keys(query), \"$elemMatch\")) {\n            matched = $elemMatch(values, query[\"$elemMatch\"], options);\n        }\n        else if (query instanceof RegExp) {\n            matched = values.some((s) => typeof s === \"string\" && query.test(s));\n        }\n        else {\n            matched = values.some((v) => isEqual(query, v));\n        }\n    }\n    return matched;\n}\n/**\n * Selects documents if the array field is a specified size.\n *\n * @param a\n * @param b\n * @returns {*|boolean}\n */\nexport function $size(a, b, options) {\n    return Array.isArray(a) && a.length === b;\n}\nfunction isNonBooleanOperator(name) {\n    return isOperator(name) && [\"$and\", \"$or\", \"$nor\"].indexOf(name) === -1;\n}\n/**\n * Selects documents if element in the array field matches all the specified $elemMatch condition.\n *\n * @param a {Array} element to match against\n * @param b {Object} subquery\n */\nexport function $elemMatch(a, b, options) {\n    // should return false for non-matching input\n    if (isArray(a) && !isEmpty(a)) {\n        let format = (x) => x;\n        let criteria = b;\n        // If we find a boolean operator in the subquery, we fake a field to point to it. This is an\n        // attempt to ensure that it is a valid criteria. We cannot make this substitution for operators\n        // like $and/$or/$nor; as otherwise, this faking will break our query.\n        if (Object.keys(b).every(isNonBooleanOperator)) {\n            criteria = { temp: b };\n            format = (x) => ({ temp: x });\n        }\n        const query = new Query(criteria, options);\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (query.test(format(a[i]))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n// helper functions\nconst isNull = (a) => a === null;\nconst isInt = (a) => isNumber(a) &&\n    a >= MIN_INT &&\n    a <= MAX_INT &&\n    a.toString().indexOf(\".\") === -1;\nconst isLong = (a) => isNumber(a) &&\n    a >= MIN_LONG &&\n    a <= MAX_LONG &&\n    a.toString().indexOf(\".\") === -1;\n/** Mapping of type to predicate */\nconst compareFuncs = {\n    array: isArray,\n    bool: isBoolean,\n    boolean: isBoolean,\n    date: isDate,\n    decimal: isNumber,\n    double: isNumber,\n    int: isInt,\n    long: isLong,\n    number: isNumber,\n    null: isNull,\n    object: isObject,\n    regex: isRegExp,\n    regexp: isRegExp,\n    string: isString,\n    // added for completeness\n    undefined: isNil,\n    function: (_) => {\n        throw new Error(\"unsupported type key `function`.\");\n    },\n    // Mongo identifiers\n    1: isNumber,\n    2: isString,\n    3: isObject,\n    4: isArray,\n    6: isNil,\n    8: isBoolean,\n    9: isDate,\n    10: isNull,\n    11: isRegExp,\n    16: isInt,\n    18: isLong,\n    19: isNumber, //decimal\n};\n/**\n * Selects documents if a field is of the specified type.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction compareType(a, b, _) {\n    const f = compareFuncs[b];\n    return f ? f(a) : false;\n}\n/**\n * Selects documents if a field is of the specified type.\n *\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport function $type(a, b, options) {\n    return Array.isArray(b)\n        ? b.findIndex((t) => compareType(a, t, options)) >= 0\n        : compareType(a, b, options);\n}\nfunction compare(a, b, f) {\n    return ensureArray(a).some((x) => getType(x) === getType(b) && f(x, b));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}