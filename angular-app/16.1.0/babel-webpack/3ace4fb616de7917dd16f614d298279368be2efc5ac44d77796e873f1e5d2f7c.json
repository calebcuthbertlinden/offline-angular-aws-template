{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { getComposedPrimaryKeyOfDocumentData } from '../rx-schema-helper';\nimport { stackCheckpoints } from '../rx-storage-helper';\nimport { createRevision, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, getFromObjectOrThrow, now } from '../plugins/utils';\nexport function getLastCheckpointDoc(_x, _x2) {\n  return _getLastCheckpointDoc.apply(this, arguments);\n}\n\n/**\n * Sets the checkpoint,\n * automatically resolves conflicts that appear.\n */\nfunction _getLastCheckpointDoc() {\n  _getLastCheckpointDoc = _asyncToGenerator(function* (state, direction) {\n    var checkpointDocId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {\n      isCheckpoint: '1',\n      itemId: direction\n    });\n    var checkpointResult = yield state.input.metaInstance.findDocumentsById([checkpointDocId], false);\n    var checkpointDoc = checkpointResult[checkpointDocId];\n    state.lastCheckpointDoc[direction] = checkpointDoc;\n    if (checkpointDoc) {\n      return checkpointDoc.data;\n    } else {\n      return undefined;\n    }\n  });\n  return _getLastCheckpointDoc.apply(this, arguments);\n}\nexport function setCheckpoint(_x3, _x4, _x5) {\n  return _setCheckpoint.apply(this, arguments);\n}\nfunction _setCheckpoint() {\n  _setCheckpoint = _asyncToGenerator(function* (state, direction, checkpoint) {\n    var previousCheckpointDoc = state.lastCheckpointDoc[direction];\n    if (checkpoint &&\n    /**\n     * If the replication is already canceled,\n     * we do not write a checkpoint\n     * because that could mean we write a checkpoint\n     * for data that has been fetched from the master\n     * but not been written to the child.\n     */\n    !state.events.canceled.getValue() && (\n    /**\n     * Only write checkpoint if it is different from before\n     * to have less writes to the storage.\n     */\n\n    !previousCheckpointDoc || JSON.stringify(previousCheckpointDoc.data) !== JSON.stringify(checkpoint))) {\n      var newDoc = {\n        id: '',\n        isCheckpoint: '1',\n        itemId: direction,\n        _deleted: false,\n        _attachments: {},\n        data: checkpoint,\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision()\n      };\n      newDoc.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newDoc);\n      while (true) {\n        /**\n         * Instead of just storing the new checkpoint,\n         * we have to stack up the checkpoint with the previous one.\n         * This is required for plugins like the sharding RxStorage\n         * where the changeStream events only contain a Partial of the\n         * checkpoint.\n         */\n        if (previousCheckpointDoc) {\n          newDoc.data = stackCheckpoints([previousCheckpointDoc.data, newDoc.data]);\n        }\n        newDoc._meta.lwt = now();\n        newDoc._rev = createRevision(state.input.identifier, previousCheckpointDoc);\n        var result = yield state.input.metaInstance.bulkWrite([{\n          previous: previousCheckpointDoc,\n          document: newDoc\n        }], 'replication-set-checkpoint');\n        if (result.success[newDoc.id]) {\n          state.lastCheckpointDoc[direction] = getFromObjectOrThrow(result.success, newDoc.id);\n          return;\n        } else {\n          var error = getFromObjectOrThrow(result.error, newDoc.id);\n          if (error.status !== 409) {\n            throw error;\n          } else {\n            previousCheckpointDoc = ensureNotFalsy(error.documentInDb);\n            newDoc._rev = createRevision(state.input.identifier, previousCheckpointDoc);\n          }\n        }\n      }\n    }\n  });\n  return _setCheckpoint.apply(this, arguments);\n}\nexport function getCheckpointKey(input) {\n  var hash = input.hashFunction([input.identifier, input.forkInstance.databaseName, input.forkInstance.collectionName].join('||'));\n  return 'rx-storage-replication-' + hash;\n}","map":{"version":3,"names":["getComposedPrimaryKeyOfDocumentData","stackCheckpoints","createRevision","ensureNotFalsy","getDefaultRevision","getDefaultRxDocumentMeta","getFromObjectOrThrow","now","getLastCheckpointDoc","_x","_x2","_getLastCheckpointDoc","apply","arguments","_asyncToGenerator","state","direction","checkpointDocId","input","metaInstance","schema","isCheckpoint","itemId","checkpointResult","findDocumentsById","checkpointDoc","lastCheckpointDoc","data","undefined","setCheckpoint","_x3","_x4","_x5","_setCheckpoint","checkpoint","previousCheckpointDoc","events","canceled","getValue","JSON","stringify","newDoc","id","_deleted","_attachments","_meta","_rev","lwt","identifier","result","bulkWrite","previous","document","success","error","status","documentInDb","getCheckpointKey","hash","hashFunction","forkInstance","databaseName","collectionName","join"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/replication-protocol/checkpoint.js"],"sourcesContent":["import { getComposedPrimaryKeyOfDocumentData } from '../rx-schema-helper';\nimport { stackCheckpoints } from '../rx-storage-helper';\nimport { createRevision, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, getFromObjectOrThrow, now } from '../plugins/utils';\nexport async function getLastCheckpointDoc(state, direction) {\n  var checkpointDocId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {\n    isCheckpoint: '1',\n    itemId: direction\n  });\n  var checkpointResult = await state.input.metaInstance.findDocumentsById([checkpointDocId], false);\n  var checkpointDoc = checkpointResult[checkpointDocId];\n  state.lastCheckpointDoc[direction] = checkpointDoc;\n  if (checkpointDoc) {\n    return checkpointDoc.data;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Sets the checkpoint,\n * automatically resolves conflicts that appear.\n */\nexport async function setCheckpoint(state, direction, checkpoint) {\n  var previousCheckpointDoc = state.lastCheckpointDoc[direction];\n  if (checkpoint &&\n  /**\n   * If the replication is already canceled,\n   * we do not write a checkpoint\n   * because that could mean we write a checkpoint\n   * for data that has been fetched from the master\n   * but not been written to the child.\n   */\n  !state.events.canceled.getValue() && (\n  /**\n   * Only write checkpoint if it is different from before\n   * to have less writes to the storage.\n   */\n\n  !previousCheckpointDoc || JSON.stringify(previousCheckpointDoc.data) !== JSON.stringify(checkpoint))) {\n    var newDoc = {\n      id: '',\n      isCheckpoint: '1',\n      itemId: direction,\n      _deleted: false,\n      _attachments: {},\n      data: checkpoint,\n      _meta: getDefaultRxDocumentMeta(),\n      _rev: getDefaultRevision()\n    };\n    newDoc.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newDoc);\n    while (true) {\n      /**\n       * Instead of just storing the new checkpoint,\n       * we have to stack up the checkpoint with the previous one.\n       * This is required for plugins like the sharding RxStorage\n       * where the changeStream events only contain a Partial of the\n       * checkpoint.\n       */\n      if (previousCheckpointDoc) {\n        newDoc.data = stackCheckpoints([previousCheckpointDoc.data, newDoc.data]);\n      }\n      newDoc._meta.lwt = now();\n      newDoc._rev = createRevision(state.input.identifier, previousCheckpointDoc);\n      var result = await state.input.metaInstance.bulkWrite([{\n        previous: previousCheckpointDoc,\n        document: newDoc\n      }], 'replication-set-checkpoint');\n      if (result.success[newDoc.id]) {\n        state.lastCheckpointDoc[direction] = getFromObjectOrThrow(result.success, newDoc.id);\n        return;\n      } else {\n        var error = getFromObjectOrThrow(result.error, newDoc.id);\n        if (error.status !== 409) {\n          throw error;\n        } else {\n          previousCheckpointDoc = ensureNotFalsy(error.documentInDb);\n          newDoc._rev = createRevision(state.input.identifier, previousCheckpointDoc);\n        }\n      }\n    }\n  }\n}\nexport function getCheckpointKey(input) {\n  var hash = input.hashFunction([input.identifier, input.forkInstance.databaseName, input.forkInstance.collectionName].join('||'));\n  return 'rx-storage-replication-' + hash;\n}\n"],"mappings":";AAAA,SAASA,mCAAmC,QAAQ,qBAAqB;AACzE,SAASC,gBAAgB,QAAQ,sBAAsB;AACvD,SAASC,cAAc,EAAEC,cAAc,EAAEC,kBAAkB,EAAEC,wBAAwB,EAAEC,oBAAoB,EAAEC,GAAG,QAAQ,kBAAkB;AAC1I,gBAAsBC,oBAAoBA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,qBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;;AAe1C;AACA;AACA;AACA;AAHA,SAAAF,sBAAA;EAAAA,qBAAA,GAAAG,iBAAA,CAfO,WAAoCC,KAAK,EAAEC,SAAS,EAAE;IAC3D,IAAIC,eAAe,GAAGjB,mCAAmC,CAACe,KAAK,CAACG,KAAK,CAACC,YAAY,CAACC,MAAM,EAAE;MACzFC,YAAY,EAAE,GAAG;MACjBC,MAAM,EAAEN;IACV,CAAC,CAAC;IACF,IAAIO,gBAAgB,SAASR,KAAK,CAACG,KAAK,CAACC,YAAY,CAACK,iBAAiB,CAAC,CAACP,eAAe,CAAC,EAAE,KAAK,CAAC;IACjG,IAAIQ,aAAa,GAAGF,gBAAgB,CAACN,eAAe,CAAC;IACrDF,KAAK,CAACW,iBAAiB,CAACV,SAAS,CAAC,GAAGS,aAAa;IAClD,IAAIA,aAAa,EAAE;MACjB,OAAOA,aAAa,CAACE,IAAI;IAC3B,CAAC,MAAM;MACL,OAAOC,SAAS;IAClB;EACF,CAAC;EAAA,OAAAjB,qBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAMD,gBAAsBgB,aAAaA,CAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,cAAA,CAAArB,KAAA,OAAAC,SAAA;AAAA;AA2DlC,SAAAoB,eAAA;EAAAA,cAAA,GAAAnB,iBAAA,CA3DM,WAA6BC,KAAK,EAAEC,SAAS,EAAEkB,UAAU,EAAE;IAChE,IAAIC,qBAAqB,GAAGpB,KAAK,CAACW,iBAAiB,CAACV,SAAS,CAAC;IAC9D,IAAIkB,UAAU;IACd;AACF;AACA;AACA;AACA;AACA;AACA;IACE,CAACnB,KAAK,CAACqB,MAAM,CAACC,QAAQ,CAACC,QAAQ,CAAC,CAAC;IACjC;AACF;AACA;AACA;;IAEE,CAACH,qBAAqB,IAAII,IAAI,CAACC,SAAS,CAACL,qBAAqB,CAACR,IAAI,CAAC,KAAKY,IAAI,CAACC,SAAS,CAACN,UAAU,CAAC,CAAC,EAAE;MACpG,IAAIO,MAAM,GAAG;QACXC,EAAE,EAAE,EAAE;QACNrB,YAAY,EAAE,GAAG;QACjBC,MAAM,EAAEN,SAAS;QACjB2B,QAAQ,EAAE,KAAK;QACfC,YAAY,EAAE,CAAC,CAAC;QAChBjB,IAAI,EAAEO,UAAU;QAChBW,KAAK,EAAExC,wBAAwB,CAAC,CAAC;QACjCyC,IAAI,EAAE1C,kBAAkB,CAAC;MAC3B,CAAC;MACDqC,MAAM,CAACC,EAAE,GAAG1C,mCAAmC,CAACe,KAAK,CAACG,KAAK,CAACC,YAAY,CAACC,MAAM,EAAEqB,MAAM,CAAC;MACxF,OAAO,IAAI,EAAE;QACX;AACN;AACA;AACA;AACA;AACA;AACA;QACM,IAAIN,qBAAqB,EAAE;UACzBM,MAAM,CAACd,IAAI,GAAG1B,gBAAgB,CAAC,CAACkC,qBAAqB,CAACR,IAAI,EAAEc,MAAM,CAACd,IAAI,CAAC,CAAC;QAC3E;QACAc,MAAM,CAACI,KAAK,CAACE,GAAG,GAAGxC,GAAG,CAAC,CAAC;QACxBkC,MAAM,CAACK,IAAI,GAAG5C,cAAc,CAACa,KAAK,CAACG,KAAK,CAAC8B,UAAU,EAAEb,qBAAqB,CAAC;QAC3E,IAAIc,MAAM,SAASlC,KAAK,CAACG,KAAK,CAACC,YAAY,CAAC+B,SAAS,CAAC,CAAC;UACrDC,QAAQ,EAAEhB,qBAAqB;UAC/BiB,QAAQ,EAAEX;QACZ,CAAC,CAAC,EAAE,4BAA4B,CAAC;QACjC,IAAIQ,MAAM,CAACI,OAAO,CAACZ,MAAM,CAACC,EAAE,CAAC,EAAE;UAC7B3B,KAAK,CAACW,iBAAiB,CAACV,SAAS,CAAC,GAAGV,oBAAoB,CAAC2C,MAAM,CAACI,OAAO,EAAEZ,MAAM,CAACC,EAAE,CAAC;UACpF;QACF,CAAC,MAAM;UACL,IAAIY,KAAK,GAAGhD,oBAAoB,CAAC2C,MAAM,CAACK,KAAK,EAAEb,MAAM,CAACC,EAAE,CAAC;UACzD,IAAIY,KAAK,CAACC,MAAM,KAAK,GAAG,EAAE;YACxB,MAAMD,KAAK;UACb,CAAC,MAAM;YACLnB,qBAAqB,GAAGhC,cAAc,CAACmD,KAAK,CAACE,YAAY,CAAC;YAC1Df,MAAM,CAACK,IAAI,GAAG5C,cAAc,CAACa,KAAK,CAACG,KAAK,CAAC8B,UAAU,EAAEb,qBAAqB,CAAC;UAC7E;QACF;MACF;IACF;EACF,CAAC;EAAA,OAAAF,cAAA,CAAArB,KAAA,OAAAC,SAAA;AAAA;AACD,OAAO,SAAS4C,gBAAgBA,CAACvC,KAAK,EAAE;EACtC,IAAIwC,IAAI,GAAGxC,KAAK,CAACyC,YAAY,CAAC,CAACzC,KAAK,CAAC8B,UAAU,EAAE9B,KAAK,CAAC0C,YAAY,CAACC,YAAY,EAAE3C,KAAK,CAAC0C,YAAY,CAACE,cAAc,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;EAChI,OAAO,yBAAyB,GAAGL,IAAI;AACzC"},"metadata":{},"sourceType":"module","externalDependencies":[]}