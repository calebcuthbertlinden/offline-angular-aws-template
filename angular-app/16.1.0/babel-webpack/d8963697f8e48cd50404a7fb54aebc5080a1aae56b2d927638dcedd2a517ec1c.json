{"ast":null,"code":"import { sleep, randomToken, PROMISE_RESOLVED_VOID, PROMISE_RESOLVED_TRUE, supportsWebLockAPI } from './util.js';\nimport { sendLeaderMessage, beLeader } from './leader-election-util.js';\nimport { LeaderElectionWebLock } from './leader-election-web-lock.js';\nvar LeaderElection = function LeaderElection(broadcastChannel, options) {\n  var _this = this;\n  this.broadcastChannel = broadcastChannel;\n  this._options = options;\n  this.isLeader = false;\n  this._hasLeader = false;\n  this.isDead = false;\n  this.token = randomToken();\n\n  /**\n   * Apply Queue,\n   * used to ensure we do not run applyOnce()\n   * in parallel.\n   */\n  this._aplQ = PROMISE_RESOLVED_VOID;\n  // amount of unfinished applyOnce() calls\n  this._aplQC = 0;\n\n  // things to clean up\n  this._unl = []; // _unloads\n  this._lstns = []; // _listeners\n  this._dpL = function () {}; // onduplicate listener\n  this._dpLC = false; // true when onduplicate called\n\n  /**\n   * Even when the own instance is not applying,\n   * we still listen to messages to ensure the hasLeader flag\n   * is set correctly.\n   */\n  var hasLeaderListener = function hasLeaderListener(msg) {\n    if (msg.context === 'leader') {\n      if (msg.action === 'death') {\n        _this._hasLeader = false;\n      }\n      if (msg.action === 'tell') {\n        _this._hasLeader = true;\n      }\n    }\n  };\n  this.broadcastChannel.addEventListener('internal', hasLeaderListener);\n  this._lstns.push(hasLeaderListener);\n};\nLeaderElection.prototype = {\n  hasLeader: function hasLeader() {\n    return Promise.resolve(this._hasLeader);\n  },\n  /**\n   * Returns true if the instance is leader,\n   * false if not.\n   * @async\n   */\n  applyOnce: function applyOnce(\n  // true if the applyOnce() call came from the fallbackInterval cycle\n  isFromFallbackInterval) {\n    var _this2 = this;\n    if (this.isLeader) {\n      return sleep(0, true);\n    }\n    if (this.isDead) {\n      return sleep(0, false);\n    }\n\n    /**\n     * Already applying more than once,\n     * -> wait for the apply queue to be finished.\n     */\n    if (this._aplQC > 1) {\n      return this._aplQ;\n    }\n\n    /**\n     * Add a new apply-run\n     */\n    var applyRun = function applyRun() {\n      /**\n       * Optimization shortcuts.\n       * Directly return if a previous run\n       * has already elected a leader.\n       */\n      if (_this2.isLeader) {\n        return PROMISE_RESOLVED_TRUE;\n      }\n      var stopCriteria = false;\n      var stopCriteriaPromiseResolve;\n      /**\n       * Resolves when a stop criteria is reached.\n       * Uses as a performance shortcut so we do not\n       * have to await the responseTime when it is already clear\n       * that the election failed.\n       */\n      var stopCriteriaPromise = new Promise(function (res) {\n        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {\n          stopCriteria = true;\n          res();\n        };\n      });\n      var handleMessage = function handleMessage(msg) {\n        if (msg.context === 'leader' && msg.token != _this2.token) {\n          if (msg.action === 'apply') {\n            // other is applying\n            if (msg.token > _this2.token) {\n              /**\n               * other has higher token\n               * -> stop applying and let other become leader.\n               */\n              stopCriteriaPromiseResolve();\n            }\n          }\n          if (msg.action === 'tell') {\n            // other is already leader\n            stopCriteriaPromiseResolve();\n            _this2._hasLeader = true;\n          }\n        }\n      };\n      _this2.broadcastChannel.addEventListener('internal', handleMessage);\n\n      /**\n       * If the applyOnce() call came from the fallbackInterval,\n       * we can assume that the election runs in the background and\n       * not critical process is waiting for it.\n       * When this is true, we give the other instances\n       * more time to answer to messages in the election cycle.\n       * This makes it less likely to elect duplicate leaders.\n       * But also it takes longer which is not a problem because we anyway\n       * run in the background.\n       */\n      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;\n      return sendLeaderMessage(_this2, 'apply') // send out that this one is applying\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })\n      // send again in case another instance was just created\n      .then(function () {\n        return sendLeaderMessage(_this2, 'apply');\n      })\n      // let others time to respond\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })[\"catch\"](function () {}).then(function () {\n        _this2.broadcastChannel.removeEventListener('internal', handleMessage);\n        if (!stopCriteria) {\n          // no stop criteria -> own is leader\n          return beLeader(_this2).then(function () {\n            return true;\n          });\n        } else {\n          // other is leader\n          return false;\n        }\n      });\n    };\n    this._aplQC = this._aplQC + 1;\n    this._aplQ = this._aplQ.then(function () {\n      return applyRun();\n    }).then(function () {\n      _this2._aplQC = _this2._aplQC - 1;\n    });\n    return this._aplQ.then(function () {\n      return _this2.isLeader;\n    });\n  },\n  awaitLeadership: function awaitLeadership() {\n    if ( /* _awaitLeadershipPromise */\n    !this._aLP) {\n      this._aLP = _awaitLeadershipOnce(this);\n    }\n    return this._aLP;\n  },\n  set onduplicate(fn) {\n    this._dpL = fn;\n  },\n  die: function die() {\n    var _this3 = this;\n    this._lstns.forEach(function (listener) {\n      return _this3.broadcastChannel.removeEventListener('internal', listener);\n    });\n    this._lstns = [];\n    this._unl.forEach(function (uFn) {\n      return uFn.remove();\n    });\n    this._unl = [];\n    if (this.isLeader) {\n      this._hasLeader = false;\n      this.isLeader = false;\n    }\n    this.isDead = true;\n    return sendLeaderMessage(this, 'death');\n  }\n};\n\n/**\n * @param leaderElector {LeaderElector}\n */\nfunction _awaitLeadershipOnce(leaderElector) {\n  if (leaderElector.isLeader) {\n    return PROMISE_RESOLVED_VOID;\n  }\n  return new Promise(function (res) {\n    var resolved = false;\n    function finish() {\n      if (resolved) {\n        return;\n      }\n      resolved = true;\n      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);\n      res(true);\n    }\n\n    // try once now\n    leaderElector.applyOnce().then(function () {\n      if (leaderElector.isLeader) {\n        finish();\n      }\n    });\n\n    /**\n     * Try on fallbackInterval\n     * @recursive\n     */\n    var tryOnFallBack = function tryOnFallBack() {\n      return sleep(leaderElector._options.fallbackInterval).then(function () {\n        if (leaderElector.isDead || resolved) {\n          return;\n        }\n        if (leaderElector.isLeader) {\n          finish();\n        } else {\n          return leaderElector.applyOnce(true).then(function () {\n            if (leaderElector.isLeader) {\n              finish();\n            } else {\n              tryOnFallBack();\n            }\n          });\n        }\n      });\n    };\n    tryOnFallBack();\n\n    // try when other leader dies\n    var whenDeathListener = function whenDeathListener(msg) {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector._hasLeader = false;\n        leaderElector.applyOnce().then(function () {\n          if (leaderElector.isLeader) {\n            finish();\n          }\n        });\n      }\n    };\n    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);\n    leaderElector._lstns.push(whenDeathListener);\n  });\n}\nfunction fillOptionsWithDefaults(options, channel) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options));\n  if (!options.fallbackInterval) {\n    options.fallbackInterval = 3000;\n  }\n  if (!options.responseTime) {\n    options.responseTime = channel.method.averageResponseTime(channel.options);\n  }\n  return options;\n}\nexport function createLeaderElection(channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('BroadcastChannel already has a leader-elector');\n  }\n  options = fillOptionsWithDefaults(options, channel);\n  var elector = supportsWebLockAPI() ? new LeaderElectionWebLock(channel, options) : new LeaderElection(channel, options);\n  channel._befC.push(function () {\n    return elector.die();\n  });\n  channel._leaderElector = elector;\n  return elector;\n}","map":{"version":3,"names":["sleep","randomToken","PROMISE_RESOLVED_VOID","PROMISE_RESOLVED_TRUE","supportsWebLockAPI","sendLeaderMessage","beLeader","LeaderElectionWebLock","LeaderElection","broadcastChannel","options","_this","_options","isLeader","_hasLeader","isDead","token","_aplQ","_aplQC","_unl","_lstns","_dpL","_dpLC","hasLeaderListener","msg","context","action","addEventListener","push","prototype","hasLeader","Promise","resolve","applyOnce","isFromFallbackInterval","_this2","applyRun","stopCriteria","stopCriteriaPromiseResolve","stopCriteriaPromise","res","handleMessage","waitForAnswerTime","responseTime","then","race","reject","Error","removeEventListener","awaitLeadership","_aLP","_awaitLeadershipOnce","onduplicate","fn","die","_this3","forEach","listener","uFn","remove","leaderElector","resolved","finish","whenDeathListener","tryOnFallBack","fallbackInterval","fillOptionsWithDefaults","channel","JSON","parse","stringify","method","averageResponseTime","createLeaderElection","_leaderElector","elector","_befC"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/broadcast-channel/dist/esbrowser/leader-election.js"],"sourcesContent":["import { sleep, randomToken, PROMISE_RESOLVED_VOID, PROMISE_RESOLVED_TRUE, supportsWebLockAPI } from './util.js';\nimport { sendLeaderMessage, beLeader } from './leader-election-util.js';\nimport { LeaderElectionWebLock } from './leader-election-web-lock.js';\nvar LeaderElection = function LeaderElection(broadcastChannel, options) {\n  var _this = this;\n  this.broadcastChannel = broadcastChannel;\n  this._options = options;\n  this.isLeader = false;\n  this._hasLeader = false;\n  this.isDead = false;\n  this.token = randomToken();\n\n  /**\n   * Apply Queue,\n   * used to ensure we do not run applyOnce()\n   * in parallel.\n   */\n  this._aplQ = PROMISE_RESOLVED_VOID;\n  // amount of unfinished applyOnce() calls\n  this._aplQC = 0;\n\n  // things to clean up\n  this._unl = []; // _unloads\n  this._lstns = []; // _listeners\n  this._dpL = function () {}; // onduplicate listener\n  this._dpLC = false; // true when onduplicate called\n\n  /**\n   * Even when the own instance is not applying,\n   * we still listen to messages to ensure the hasLeader flag\n   * is set correctly.\n   */\n  var hasLeaderListener = function hasLeaderListener(msg) {\n    if (msg.context === 'leader') {\n      if (msg.action === 'death') {\n        _this._hasLeader = false;\n      }\n      if (msg.action === 'tell') {\n        _this._hasLeader = true;\n      }\n    }\n  };\n  this.broadcastChannel.addEventListener('internal', hasLeaderListener);\n  this._lstns.push(hasLeaderListener);\n};\nLeaderElection.prototype = {\n  hasLeader: function hasLeader() {\n    return Promise.resolve(this._hasLeader);\n  },\n  /**\n   * Returns true if the instance is leader,\n   * false if not.\n   * @async\n   */\n  applyOnce: function applyOnce(\n  // true if the applyOnce() call came from the fallbackInterval cycle\n  isFromFallbackInterval) {\n    var _this2 = this;\n    if (this.isLeader) {\n      return sleep(0, true);\n    }\n    if (this.isDead) {\n      return sleep(0, false);\n    }\n\n    /**\n     * Already applying more than once,\n     * -> wait for the apply queue to be finished.\n     */\n    if (this._aplQC > 1) {\n      return this._aplQ;\n    }\n\n    /**\n     * Add a new apply-run\n     */\n    var applyRun = function applyRun() {\n      /**\n       * Optimization shortcuts.\n       * Directly return if a previous run\n       * has already elected a leader.\n       */\n      if (_this2.isLeader) {\n        return PROMISE_RESOLVED_TRUE;\n      }\n      var stopCriteria = false;\n      var stopCriteriaPromiseResolve;\n      /**\n       * Resolves when a stop criteria is reached.\n       * Uses as a performance shortcut so we do not\n       * have to await the responseTime when it is already clear\n       * that the election failed.\n       */\n      var stopCriteriaPromise = new Promise(function (res) {\n        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {\n          stopCriteria = true;\n          res();\n        };\n      });\n      var handleMessage = function handleMessage(msg) {\n        if (msg.context === 'leader' && msg.token != _this2.token) {\n          if (msg.action === 'apply') {\n            // other is applying\n            if (msg.token > _this2.token) {\n              /**\n               * other has higher token\n               * -> stop applying and let other become leader.\n               */\n              stopCriteriaPromiseResolve();\n            }\n          }\n          if (msg.action === 'tell') {\n            // other is already leader\n            stopCriteriaPromiseResolve();\n            _this2._hasLeader = true;\n          }\n        }\n      };\n      _this2.broadcastChannel.addEventListener('internal', handleMessage);\n\n      /**\n       * If the applyOnce() call came from the fallbackInterval,\n       * we can assume that the election runs in the background and\n       * not critical process is waiting for it.\n       * When this is true, we give the other instances\n       * more time to answer to messages in the election cycle.\n       * This makes it less likely to elect duplicate leaders.\n       * But also it takes longer which is not a problem because we anyway\n       * run in the background.\n       */\n      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;\n      return sendLeaderMessage(_this2, 'apply') // send out that this one is applying\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })\n      // send again in case another instance was just created\n      .then(function () {\n        return sendLeaderMessage(_this2, 'apply');\n      })\n      // let others time to respond\n      .then(function () {\n        return Promise.race([sleep(waitForAnswerTime), stopCriteriaPromise.then(function () {\n          return Promise.reject(new Error());\n        })]);\n      })[\"catch\"](function () {}).then(function () {\n        _this2.broadcastChannel.removeEventListener('internal', handleMessage);\n        if (!stopCriteria) {\n          // no stop criteria -> own is leader\n          return beLeader(_this2).then(function () {\n            return true;\n          });\n        } else {\n          // other is leader\n          return false;\n        }\n      });\n    };\n    this._aplQC = this._aplQC + 1;\n    this._aplQ = this._aplQ.then(function () {\n      return applyRun();\n    }).then(function () {\n      _this2._aplQC = _this2._aplQC - 1;\n    });\n    return this._aplQ.then(function () {\n      return _this2.isLeader;\n    });\n  },\n  awaitLeadership: function awaitLeadership() {\n    if ( /* _awaitLeadershipPromise */\n    !this._aLP) {\n      this._aLP = _awaitLeadershipOnce(this);\n    }\n    return this._aLP;\n  },\n  set onduplicate(fn) {\n    this._dpL = fn;\n  },\n  die: function die() {\n    var _this3 = this;\n    this._lstns.forEach(function (listener) {\n      return _this3.broadcastChannel.removeEventListener('internal', listener);\n    });\n    this._lstns = [];\n    this._unl.forEach(function (uFn) {\n      return uFn.remove();\n    });\n    this._unl = [];\n    if (this.isLeader) {\n      this._hasLeader = false;\n      this.isLeader = false;\n    }\n    this.isDead = true;\n    return sendLeaderMessage(this, 'death');\n  }\n};\n\n/**\n * @param leaderElector {LeaderElector}\n */\nfunction _awaitLeadershipOnce(leaderElector) {\n  if (leaderElector.isLeader) {\n    return PROMISE_RESOLVED_VOID;\n  }\n  return new Promise(function (res) {\n    var resolved = false;\n    function finish() {\n      if (resolved) {\n        return;\n      }\n      resolved = true;\n      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);\n      res(true);\n    }\n\n    // try once now\n    leaderElector.applyOnce().then(function () {\n      if (leaderElector.isLeader) {\n        finish();\n      }\n    });\n\n    /**\n     * Try on fallbackInterval\n     * @recursive\n     */\n    var tryOnFallBack = function tryOnFallBack() {\n      return sleep(leaderElector._options.fallbackInterval).then(function () {\n        if (leaderElector.isDead || resolved) {\n          return;\n        }\n        if (leaderElector.isLeader) {\n          finish();\n        } else {\n          return leaderElector.applyOnce(true).then(function () {\n            if (leaderElector.isLeader) {\n              finish();\n            } else {\n              tryOnFallBack();\n            }\n          });\n        }\n      });\n    };\n    tryOnFallBack();\n\n    // try when other leader dies\n    var whenDeathListener = function whenDeathListener(msg) {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector._hasLeader = false;\n        leaderElector.applyOnce().then(function () {\n          if (leaderElector.isLeader) {\n            finish();\n          }\n        });\n      }\n    };\n    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);\n    leaderElector._lstns.push(whenDeathListener);\n  });\n}\nfunction fillOptionsWithDefaults(options, channel) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options));\n  if (!options.fallbackInterval) {\n    options.fallbackInterval = 3000;\n  }\n  if (!options.responseTime) {\n    options.responseTime = channel.method.averageResponseTime(channel.options);\n  }\n  return options;\n}\nexport function createLeaderElection(channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('BroadcastChannel already has a leader-elector');\n  }\n  options = fillOptionsWithDefaults(options, channel);\n  var elector = supportsWebLockAPI() ? new LeaderElectionWebLock(channel, options) : new LeaderElection(channel, options);\n  channel._befC.push(function () {\n    return elector.die();\n  });\n  channel._leaderElector = elector;\n  return elector;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}