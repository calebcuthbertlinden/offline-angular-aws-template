{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * this plugin adds the encryption-capabilities to rxdb\n * It's using crypto-js/aes for password-encryption\n * @link https://github.com/brix/crypto-js\n */\nimport AES from 'crypto-js/aes';\nimport * as cryptoEnc from 'crypto-js/enc-utf8';\nimport { wrapRxStorageInstance } from '../../plugin-helpers';\nimport { newRxError, newRxTypeError } from '../../rx-error';\nimport { hasEncryption } from '../../rx-storage-helper';\nimport { b64DecodeUnicode, b64EncodeUnicode, clone, ensureNotFalsy, flatClone, getProperty, setProperty } from '../../plugins/utils';\nexport var MINIMUM_PASSWORD_LENGTH = 8;\nexport function encryptString(value, password) {\n  var encrypted = AES.encrypt(value, password);\n  return encrypted.toString();\n}\nexport function decryptString(cipherText, password) {\n  /**\n   * Trying to decrypt non-strings\n   * will cause no errors and will be hard to debug.\n   * So instead we do this check here.\n   */\n  if (typeof cipherText !== 'string') {\n    throw newRxError('SNH', {\n      args: {\n        cipherText\n      }\n    });\n  }\n  var decrypted = AES.decrypt(cipherText, password);\n  var ret = decrypted.toString(cryptoEnc);\n  return ret;\n}\nexport function wrappedKeyEncryptionCryptoJsStorage(args) {\n  return Object.assign({}, args.storage, {\n    createStorageInstance(params) {\n      return _asyncToGenerator(function* () {\n        if (typeof params.password !== 'undefined') {\n          validatePassword(params.password);\n        }\n        if (!hasEncryption(params.schema)) {\n          var retInstance = yield args.storage.createStorageInstance(params);\n          return retInstance;\n        }\n        if (!params.password) {\n          throw newRxError('EN3', {\n            database: params.databaseName,\n            collection: params.collectionName,\n            schema: params.schema\n          });\n        }\n        var password = params.password;\n        var schemaWithoutEncrypted = clone(params.schema);\n        delete schemaWithoutEncrypted.encrypted;\n        if (schemaWithoutEncrypted.attachments) {\n          schemaWithoutEncrypted.attachments.encrypted = false;\n        }\n        var instance = yield args.storage.createStorageInstance(Object.assign({}, params, {\n          schema: schemaWithoutEncrypted\n        }));\n        function modifyToStorage(docData) {\n          docData = cloneWithoutAttachments(docData);\n          ensureNotFalsy(params.schema.encrypted).forEach(path => {\n            var value = getProperty(docData, path);\n            if (typeof value === 'undefined') {\n              return;\n            }\n            var stringValue = JSON.stringify(value);\n            var encrypted = encryptString(stringValue, password);\n            setProperty(docData, path, encrypted);\n          });\n\n          // handle attachments\n          if (params.schema.attachments && params.schema.attachments.encrypted) {\n            var newAttachments = {};\n            Object.entries(docData._attachments).forEach(([id, attachment]) => {\n              var useAttachment = flatClone(attachment);\n              if (useAttachment.data) {\n                var dataString = useAttachment.data;\n                useAttachment.data = b64EncodeUnicode(encryptString(dataString, password));\n              }\n              newAttachments[id] = useAttachment;\n            });\n            docData._attachments = newAttachments;\n          }\n          return docData;\n        }\n        function modifyFromStorage(docData) {\n          docData = cloneWithoutAttachments(docData);\n          ensureNotFalsy(params.schema.encrypted).forEach(path => {\n            var value = getProperty(docData, path);\n            if (typeof value === 'undefined') {\n              return;\n            }\n            var decrypted = decryptString(value, password);\n            var decryptedParsed = JSON.parse(decrypted);\n            setProperty(docData, path, decryptedParsed);\n          });\n          return docData;\n        }\n        function modifyAttachmentFromStorage(attachmentData) {\n          if (params.schema.attachments && params.schema.attachments.encrypted) {\n            var decrypted = decryptString(b64DecodeUnicode(attachmentData), password);\n            return decrypted;\n          } else {\n            return attachmentData;\n          }\n        }\n        return wrapRxStorageInstance(instance, modifyToStorage, modifyFromStorage, modifyAttachmentFromStorage);\n      })();\n    }\n  });\n}\nfunction cloneWithoutAttachments(data) {\n  var attachments = data._attachments;\n  data = flatClone(data);\n  delete data._attachments;\n  data = clone(data);\n  data._attachments = attachments;\n  return data;\n}\nfunction validatePassword(password) {\n  if (typeof password !== 'string') {\n    throw newRxTypeError('EN1', {\n      password\n    });\n  }\n  if (password.length < MINIMUM_PASSWORD_LENGTH) {\n    throw newRxError('EN2', {\n      minPassLength: MINIMUM_PASSWORD_LENGTH,\n      password\n    });\n  }\n}","map":{"version":3,"names":["AES","cryptoEnc","wrapRxStorageInstance","newRxError","newRxTypeError","hasEncryption","b64DecodeUnicode","b64EncodeUnicode","clone","ensureNotFalsy","flatClone","getProperty","setProperty","MINIMUM_PASSWORD_LENGTH","encryptString","value","password","encrypted","encrypt","toString","decryptString","cipherText","args","decrypted","decrypt","ret","wrappedKeyEncryptionCryptoJsStorage","Object","assign","storage","createStorageInstance","params","_asyncToGenerator","validatePassword","schema","retInstance","database","databaseName","collection","collectionName","schemaWithoutEncrypted","attachments","instance","modifyToStorage","docData","cloneWithoutAttachments","forEach","path","stringValue","JSON","stringify","newAttachments","entries","_attachments","id","attachment","useAttachment","data","dataString","modifyFromStorage","decryptedParsed","parse","modifyAttachmentFromStorage","attachmentData","length","minPassLength"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/plugins/encryption-crypto-js/index.js"],"sourcesContent":["/**\n * this plugin adds the encryption-capabilities to rxdb\n * It's using crypto-js/aes for password-encryption\n * @link https://github.com/brix/crypto-js\n */\nimport AES from 'crypto-js/aes';\nimport * as cryptoEnc from 'crypto-js/enc-utf8';\nimport { wrapRxStorageInstance } from '../../plugin-helpers';\nimport { newRxError, newRxTypeError } from '../../rx-error';\nimport { hasEncryption } from '../../rx-storage-helper';\nimport { b64DecodeUnicode, b64EncodeUnicode, clone, ensureNotFalsy, flatClone, getProperty, setProperty } from '../../plugins/utils';\nexport var MINIMUM_PASSWORD_LENGTH = 8;\nexport function encryptString(value, password) {\n  var encrypted = AES.encrypt(value, password);\n  return encrypted.toString();\n}\nexport function decryptString(cipherText, password) {\n  /**\n   * Trying to decrypt non-strings\n   * will cause no errors and will be hard to debug.\n   * So instead we do this check here.\n   */\n  if (typeof cipherText !== 'string') {\n    throw newRxError('SNH', {\n      args: {\n        cipherText\n      }\n    });\n  }\n  var decrypted = AES.decrypt(cipherText, password);\n  var ret = decrypted.toString(cryptoEnc);\n  return ret;\n}\nexport function wrappedKeyEncryptionCryptoJsStorage(args) {\n  return Object.assign({}, args.storage, {\n    async createStorageInstance(params) {\n      if (typeof params.password !== 'undefined') {\n        validatePassword(params.password);\n      }\n      if (!hasEncryption(params.schema)) {\n        var retInstance = await args.storage.createStorageInstance(params);\n        return retInstance;\n      }\n      if (!params.password) {\n        throw newRxError('EN3', {\n          database: params.databaseName,\n          collection: params.collectionName,\n          schema: params.schema\n        });\n      }\n      var password = params.password;\n      var schemaWithoutEncrypted = clone(params.schema);\n      delete schemaWithoutEncrypted.encrypted;\n      if (schemaWithoutEncrypted.attachments) {\n        schemaWithoutEncrypted.attachments.encrypted = false;\n      }\n      var instance = await args.storage.createStorageInstance(Object.assign({}, params, {\n        schema: schemaWithoutEncrypted\n      }));\n      function modifyToStorage(docData) {\n        docData = cloneWithoutAttachments(docData);\n        ensureNotFalsy(params.schema.encrypted).forEach(path => {\n          var value = getProperty(docData, path);\n          if (typeof value === 'undefined') {\n            return;\n          }\n          var stringValue = JSON.stringify(value);\n          var encrypted = encryptString(stringValue, password);\n          setProperty(docData, path, encrypted);\n        });\n\n        // handle attachments\n        if (params.schema.attachments && params.schema.attachments.encrypted) {\n          var newAttachments = {};\n          Object.entries(docData._attachments).forEach(([id, attachment]) => {\n            var useAttachment = flatClone(attachment);\n            if (useAttachment.data) {\n              var dataString = useAttachment.data;\n              useAttachment.data = b64EncodeUnicode(encryptString(dataString, password));\n            }\n            newAttachments[id] = useAttachment;\n          });\n          docData._attachments = newAttachments;\n        }\n        return docData;\n      }\n      function modifyFromStorage(docData) {\n        docData = cloneWithoutAttachments(docData);\n        ensureNotFalsy(params.schema.encrypted).forEach(path => {\n          var value = getProperty(docData, path);\n          if (typeof value === 'undefined') {\n            return;\n          }\n          var decrypted = decryptString(value, password);\n          var decryptedParsed = JSON.parse(decrypted);\n          setProperty(docData, path, decryptedParsed);\n        });\n        return docData;\n      }\n      function modifyAttachmentFromStorage(attachmentData) {\n        if (params.schema.attachments && params.schema.attachments.encrypted) {\n          var decrypted = decryptString(b64DecodeUnicode(attachmentData), password);\n          return decrypted;\n        } else {\n          return attachmentData;\n        }\n      }\n      return wrapRxStorageInstance(instance, modifyToStorage, modifyFromStorage, modifyAttachmentFromStorage);\n    }\n  });\n}\nfunction cloneWithoutAttachments(data) {\n  var attachments = data._attachments;\n  data = flatClone(data);\n  delete data._attachments;\n  data = clone(data);\n  data._attachments = attachments;\n  return data;\n}\nfunction validatePassword(password) {\n  if (typeof password !== 'string') {\n    throw newRxTypeError('EN1', {\n      password\n    });\n  }\n  if (password.length < MINIMUM_PASSWORD_LENGTH) {\n    throw newRxError('EN2', {\n      minPassLength: MINIMUM_PASSWORD_LENGTH,\n      password\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}