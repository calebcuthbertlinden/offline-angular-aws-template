{"ast":null,"code":"/**\n * Utility constants and functions\n */\nexport const MAX_INT = 2147483647;\nexport const MIN_INT = -2147483648;\nexport const MAX_LONG = Number.MAX_SAFE_INTEGER;\nexport const MIN_LONG = Number.MIN_SAFE_INTEGER;\n// special value to identify missing items. treated differently from undefined\nconst MISSING = Symbol(\"missing\");\n/**\n * Uses the simple hash method as described in Effective Java.\n * @see https://stackoverflow.com/a/113600/1370481\n * @param value The value to hash\n * @returns {number}\n */\nconst DEFAULT_HASH_FUNCTION = value => {\n  const s = stringify(value);\n  let hash = 0;\n  let i = s.length;\n  while (i) hash = (hash << 5) - hash ^ s.charCodeAt(--i);\n  return hash >>> 0;\n};\n// no array, object, or function types\nconst JS_SIMPLE_TYPES = new Set([\"null\", \"undefined\", \"boolean\", \"number\", \"string\", \"date\", \"regexp\"]);\n/** MongoDB sort comparison order. https://www.mongodb.com/docs/manual/reference/bson-type-comparison-order */\nconst SORT_ORDER_BY_TYPE = {\n  null: 0,\n  undefined: 0,\n  number: 1,\n  string: 2,\n  object: 3,\n  array: 4,\n  boolean: 5,\n  date: 6,\n  regexp: 7,\n  function: 8\n};\n/**\n * Compare function which adheres to MongoDB comparison order.\n *\n * @param a The first value\n * @param b The second value\n * @returns {Number}\n */\nexport const DEFAULT_COMPARATOR = (a, b) => {\n  if (a === MISSING) a = undefined;\n  if (b === MISSING) b = undefined;\n  const [ta, tb] = [a, b].map(n => getType(n).toLowerCase());\n  const u = SORT_ORDER_BY_TYPE[ta];\n  const v = SORT_ORDER_BY_TYPE[tb];\n  if (u !== v) return u - v;\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\nconst OBJECT_PROTOTYPE = Object.getPrototypeOf({});\nconst OBJECT_TAG = \"[object Object]\";\nconst OBJECT_TYPE_RE = /^\\[object ([a-zA-Z0-9]+)\\]$/;\nexport function assert(condition, message) {\n  if (!condition) throw new Error(message);\n}\n/**\n * Deep clone an object\n */\nexport function cloneDeep(obj) {\n  if (obj instanceof Array) return obj.map(cloneDeep);\n  if (obj instanceof Date) return new Date(obj);\n  if (isObject(obj)) return objectMap(obj, cloneDeep);\n  return obj;\n}\n/**\n * Returns the name of type as specified in the tag returned by a call to Object.prototype.toString\n * @param v A value\n */\nexport function getType(v) {\n  return OBJECT_TYPE_RE.exec(Object.prototype.toString.call(v))[1];\n}\nexport function isBoolean(v) {\n  return typeof v === \"boolean\";\n}\nexport function isString(v) {\n  return typeof v === \"string\";\n}\nexport function isNumber(v) {\n  return !isNaN(v) && typeof v === \"number\";\n}\nexport function isNotNaN(v) {\n  return !(isNaN(v) && typeof v === \"number\");\n}\nexport const isArray = Array.isArray;\nexport function isObject(v) {\n  if (!v) return false;\n  const proto = Object.getPrototypeOf(v);\n  return (proto === OBJECT_PROTOTYPE || proto === null) && OBJECT_TAG === Object.prototype.toString.call(v);\n}\nexport function isObjectLike(v) {\n  return v === Object(v);\n} // objects, arrays, functions, date, custom object\nexport function isDate(v) {\n  return v instanceof Date;\n}\nexport function isRegExp(v) {\n  return v instanceof RegExp;\n}\nexport function isFunction(v) {\n  return typeof v === \"function\";\n}\nexport function isNil(v) {\n  return v === null || v === undefined;\n}\nexport function inArray(arr, item) {\n  return arr.includes(item);\n}\nexport function notInArray(arr, item) {\n  return !inArray(arr, item);\n}\nexport function truthy(arg, strict) {\n  return !!arg || strict && arg === \"\";\n}\nexport function isEmpty(x) {\n  return isNil(x) || isString(x) && !x || x instanceof Array && x.length === 0 || isObject(x) && Object.keys(x).length === 0;\n}\nexport function isMissing(m) {\n  return m === MISSING;\n}\n// ensure a value is an array or wrapped within one\nexport function ensureArray(x) {\n  return x instanceof Array ? x : [x];\n}\nexport function has(obj, prop) {\n  return !!obj && Object.prototype.hasOwnProperty.call(obj, prop);\n}\n/**\n * Transform values in an object\n *\n * @param  {Object}   obj   An object whose values to transform\n * @param  {Function} fn The transform function\n * @return {Array|Object} Result object after applying the transform\n */\nexport function objectMap(obj, fn) {\n  const o = {};\n  const objKeys = Object.keys(obj);\n  for (let i = 0; i < objKeys.length; i++) {\n    const k = objKeys[i];\n    o[k] = fn(obj[k], k);\n  }\n  return o;\n}\n/**\n * Deep merge objects or arrays.\n * When the inputs have unmergeable types, the source value (right hand side) is returned.\n * If inputs are arrays of same length and all elements are mergable, elements in the same position are merged together.\n * If AnyVal of the elements are unmergeable, elements in the source are appended to the target.\n * @param target {Object|Array} the target to merge into\n * @param obj {Object|Array} the source object\n */\nexport function merge(target, obj, options) {\n  // take care of missing inputs\n  if (isMissing(target)) return obj;\n  if (isMissing(obj)) return target;\n  const inputs = [target, obj];\n  if (!(inputs.every(isObject) || inputs.every(isArray))) {\n    throw Error(\"mismatched types. must both be array or object\");\n  }\n  // default options\n  options = options || {\n    flatten: false\n  };\n  if (isArray(target)) {\n    const result = target;\n    const input = obj;\n    if (options.flatten) {\n      let i = 0;\n      let j = 0;\n      while (i < result.length && j < input.length) {\n        result[i] = merge(result[i++], input[j++], options);\n      }\n      while (j < input.length) {\n        result.push(obj[j++]);\n      }\n    } else {\n      into(result, input);\n    }\n  } else {\n    Object.keys(obj).forEach(k => {\n      if (has(obj, k)) {\n        if (has(target, k)) {\n          target[k] = merge(target[k], obj[k], options);\n        } else {\n          target[k] = obj[k];\n        }\n      }\n    });\n  }\n  return target;\n}\nfunction addIndex(root, key, index) {\n  if (root.key < key) {\n    if (root.right) {\n      addIndex(root.right, key, index);\n    } else {\n      root.right = {\n        key,\n        indexes: [index]\n      };\n    }\n  } else if (root.key > key) {\n    if (root.left) {\n      addIndex(root.left, key, index);\n    } else {\n      root.left = {\n        key,\n        indexes: [index]\n      };\n    }\n  } else {\n    root.indexes.push(index);\n  }\n}\nfunction getIndexes(root, key) {\n  if (root.key == key) {\n    return root.indexes;\n  } else if (root.key < key) {\n    return root.right ? getIndexes(root.right, key) : undefined;\n  } else if (root.key > key) {\n    return root.left ? getIndexes(root.left, key) : undefined;\n  }\n  return undefined;\n}\n/**\n * Returns the intersection of multiple arrays.\n *\n * @param  {Array} a The first array\n * @param  {Array} b The second array\n * @param  {Function} hashFunction Custom function to hash values, default the hashCode method\n * @return {Array}    Result array\n */\nexport function intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n  // if any array is empty, there is no intersection\n  if (input.some(arr => arr.length == 0)) return [];\n  // sort input arrays by size\n  const sortedIndex = input.map((a, i) => [i, a.length]);\n  sortedIndex.sort((a, b) => a[1] - b[1]);\n  // matched items index of first array for all other arrays.\n  const result = [];\n  const smallestArray = input[sortedIndex[0][0]];\n  const root = {\n    key: hashCode(smallestArray[0], hashFunction),\n    indexes: [0]\n  };\n  for (let i = 1; i < smallestArray.length; i++) {\n    const val = smallestArray[i];\n    const h = hashCode(val, hashFunction);\n    addIndex(root, h, i);\n  }\n  let maxResultSize = sortedIndex[0][1];\n  const orderedIndexes = [];\n  for (let i = 1; i < sortedIndex.length; i++) {\n    const arrayIndex = sortedIndex[i][0];\n    const data = input[arrayIndex];\n    // number of matched items\n    let size = 0;\n    for (let j = 0; j < data.length; j++) {\n      const h = hashCode(data[j], hashFunction);\n      const indexes = getIndexes(root, h);\n      // not included.\n      if (!indexes) continue;\n      // check items equality to mitigate hash collisions and select the matching index.\n      const idx = indexes.map(n => smallestArray[n]).findIndex(v => isEqual(v, data[j]));\n      // not included\n      if (idx == -1) continue;\n      // item matched. ensure map exist for marking index\n      if (result.length < i) result.push({});\n      // map to index of the actual value and set position\n      result[result.length - 1][indexes[idx]] = true;\n      // if we have seen max result items we can stop.\n      size = Object.keys(result[result.length - 1]).length;\n      // ensure stabilty\n      if (arrayIndex == 0) {\n        if (orderedIndexes.indexOf(indexes[idx]) == -1) {\n          orderedIndexes.push(indexes[idx]);\n        }\n      }\n    }\n    // no intersection if nothing found\n    if (size == 0) return [];\n    // new max result size\n    maxResultSize = Math.min(maxResultSize, size);\n  }\n  const freq = {};\n  // count occurrences\n  result.forEach(m => {\n    Object.keys(m).forEach(k => {\n      const n = parseFloat(k);\n      freq[n] = freq[n] || 0;\n      freq[n]++;\n    });\n  });\n  const keys = orderedIndexes;\n  if (keys.length == 0) {\n    // note: cannot use parseInt due to second argument for radix.\n    keys.push(...Object.keys(freq).map(parseFloat));\n    keys.sort();\n  }\n  return keys.filter(n => freq[n] == input.length - 1).map(n => smallestArray[n]);\n}\n/**\n * Flatten the array\n *\n * @param  {Array} xs The array to flatten\n * @param {Number} depth The number of nested lists to iterate\n */\nexport function flatten(xs, depth) {\n  const arr = [];\n  function flatten2(ys, n) {\n    for (let i = 0, len = ys.length; i < len; i++) {\n      if (isArray(ys[i]) && (n > 0 || n < 0)) {\n        flatten2(ys[i], Math.max(-1, n - 1));\n      } else {\n        arr.push(ys[i]);\n      }\n    }\n  }\n  flatten2(xs, depth);\n  return arr;\n}\n/**\n * Determine whether two values are the same or strictly equivalent\n *\n * @param  {*}  a The first value\n * @param  {*}  b The second value\n * @return {Boolean}   Result of comparison\n */\nexport function isEqual(a, b) {\n  const lhs = [a];\n  const rhs = [b];\n  while (lhs.length > 0) {\n    a = lhs.pop();\n    b = rhs.pop();\n    // strictly equal must be equal.\n    if (a === b) continue;\n    // unequal types and functions cannot be equal.\n    const nativeType = getType(a).toLowerCase();\n    if (nativeType !== getType(b).toLowerCase() || nativeType === \"function\") {\n      return false;\n    }\n    // leverage toString for Date and RegExp types\n    if (nativeType === \"array\") {\n      const xs = a;\n      const ys = b;\n      if (xs.length !== ys.length) return false;\n      if (xs.length === ys.length && xs.length === 0) continue;\n      into(lhs, xs);\n      into(rhs, ys);\n    } else if (nativeType === \"object\") {\n      // deep compare objects\n      const aKeys = Object.keys(a);\n      const bKeys = Object.keys(b);\n      // check length of keys early\n      if (aKeys.length !== bKeys.length) return false;\n      // compare keys\n      for (let i = 0, len = aKeys.length; i < len; i++) {\n        const k = aKeys[i];\n        // not found\n        if (!has(b, k)) return false;\n        // key found\n        lhs.push(a[k]);\n        rhs.push(b[k]);\n      }\n    } else {\n      // compare encoded values\n      if (stringify(a) !== stringify(b)) return false;\n    }\n  }\n  return lhs.length === 0;\n}\n/**\n * Return a new unique version of the collection\n * @param  {Array} xs The input collection\n * @return {Array}\n */\nexport function unique(xs, hashFunction = DEFAULT_HASH_FUNCTION) {\n  if (xs.length == 0) return [];\n  const root = {\n    key: hashCode(xs[0], hashFunction),\n    indexes: [0]\n  };\n  // hash items on to tree to track collisions\n  for (let i = 1; i < xs.length; i++) {\n    addIndex(root, hashCode(xs[i], hashFunction), i);\n  }\n  const result = [];\n  // walk tree and remove duplicates\n  const stack = [root];\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (node.indexes.length == 1) {\n      result.push(node.indexes[0]);\n    } else {\n      // handle collisions by matching all items\n      const arr = node.indexes;\n      // we start by search from the back so we maintain the smaller index when there is a duplicate.\n      while (arr.length > 0) {\n        for (let j = 1; j < arr.length; j++) {\n          // if last item matches any remove the last item.\n          if (isEqual(xs[arr[arr.length - 1]], xs[arr[arr.length - 1 - j]])) {\n            // remove last item\n            arr.pop();\n            // reset position\n            j = 0;\n          }\n        }\n        // add the unique item\n        result.push(arr.pop());\n      }\n    }\n    // add children\n    if (node.left) stack.push(node.left);\n    if (node.right) stack.push(node.right);\n  }\n  // sort indexes for stability\n  result.sort();\n  // return the unique items\n  return result.map(i => xs[i]);\n}\n/**\n * Encode value to string using a simple non-colliding stable scheme.\n *\n * @param value\n * @returns {*}\n */\nexport function stringify(value) {\n  const type = getType(value).toLowerCase();\n  switch (type) {\n    case \"boolean\":\n    case \"number\":\n    case \"regexp\":\n      return value.toString();\n    case \"string\":\n      return JSON.stringify(value);\n    case \"date\":\n      return value.toISOString();\n    case \"null\":\n    case \"undefined\":\n      return type;\n    case \"array\":\n      return \"[\" + value.map(stringify).join(\",\") + \"]\";\n    default:\n      break;\n  }\n  // default case\n  const prefix = type === \"object\" ? \"\" : `${getType(value)}`;\n  const objKeys = Object.keys(value);\n  objKeys.sort();\n  return `${prefix}{` + objKeys.map(k => `${stringify(k)}:${stringify(value[k])}`).join(\",\") + \"}\";\n}\n/**\n * Generate hash code\n * This selected function is the result of benchmarking various hash functions.\n * This version performs well and can hash 10^6 documents in ~3s with on average 100 collisions.\n *\n * @param value\n * @returns {number|null}\n */\nexport function hashCode(value, hashFunction = DEFAULT_HASH_FUNCTION) {\n  if (isNil(value)) return null;\n  return hashFunction(value).toString();\n}\n/**\n * Returns a (stably) sorted copy of list, ranked in ascending order by the results of running each value through iteratee\n *\n * This implementation treats null/undefined sort keys as less than every other type\n *\n * @param {Array}   collection\n * @param {Function} keyFn The sort key function used to resolve sort keys\n * @param {Function} comparator The comparator function to use for comparing keys. Defaults to standard comparison via `compare(...)`\n * @return {Array} Returns a new sorted array by the given key and comparator function\n */\nexport function sortBy(collection, keyFn, comparator = DEFAULT_COMPARATOR) {\n  const sorted = [];\n  const result = [];\n  if (isEmpty(collection)) return collection;\n  for (let i = 0; i < collection.length; i++) {\n    const obj = collection[i];\n    const key = keyFn(obj, i);\n    if (isNil(key)) {\n      result.push(obj);\n    } else {\n      sorted.push([key, obj]);\n    }\n  }\n  // use native array sorting but enforce stableness\n  sorted.sort((a, b) => comparator(a[0], b[0]));\n  result.push(...sorted.map(o => o[1]));\n  return result;\n}\n/**\n * Groups the collection into sets by the returned key\n *\n * @param collection\n * @param keyFn {Function} to compute the group key of an item in the collection\n * @returns {{keys: Array, groups: Array}}\n */\nexport function groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {\n  const result = {\n    keys: new Array(),\n    groups: new Array()\n  };\n  const lookup = {};\n  for (let i = 0; i < collection.length; i++) {\n    const obj = collection[i];\n    const key = keyFn(obj, i);\n    const hash = hashCode(key, hashFunction);\n    let index = -1;\n    if (lookup[hash] === undefined) {\n      index = result.keys.length;\n      lookup[hash] = index;\n      result.keys.push(key);\n      result.groups.push([]);\n    }\n    index = lookup[hash];\n    result.groups[index].push(obj);\n  }\n  return result;\n}\n// max elements to push.\n// See argument limit https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\nconst MAX_ARRAY_PUSH = 50000;\n/**\n * Merge elements into the dest\n *\n * @param {*} target The target object\n * @param {*} rest The array of elements to merge into dest\n */\nexport function into(target, ...rest) {\n  if (target instanceof Array) {\n    return rest.reduce((acc, arr) => {\n      // push arrary in batches to handle large inputs\n      let i = Math.ceil(arr.length / MAX_ARRAY_PUSH);\n      let begin = 0;\n      while (i-- > 0) {\n        Array.prototype.push.apply(acc, arr.slice(begin, begin + MAX_ARRAY_PUSH));\n        begin += MAX_ARRAY_PUSH;\n      }\n      return acc;\n    }, target);\n  } else {\n    // merge objects. same behaviour as Object.assign\n    return rest.filter(isObjectLike).reduce((acc, item) => {\n      Object.assign(acc, item);\n      return acc;\n    }, target);\n  }\n}\n/**\n * This is a generic memoization function\n *\n * This implementation uses a cache independent of the function being memoized\n * to allow old values to be garbage collected when the memoized function goes out of scope.\n *\n * @param {*} fn The function object to memoize\n */\nexport function memoize(fn, hashFunction = DEFAULT_HASH_FUNCTION) {\n  return (memo => {\n    return (...args) => {\n      const key = hashCode(args, hashFunction);\n      if (!has(memo, key)) {\n        memo[key] = fn.apply(this, args);\n      }\n      return memo[key];\n    };\n  })({\n    /* storage */\n  });\n}\n// mingo internal\n/**\n * Retrieve the value of a given key on an object\n * @param obj\n * @param key\n * @returns {*}\n * @private\n */\nfunction getValue(obj, key) {\n  return isObjectLike(obj) ? obj[key] : undefined;\n}\n/**\n * Unwrap a single element array to specified depth\n * @param {Array} arr\n * @param {Number} depth\n */\nfunction unwrap(arr, depth) {\n  if (depth < 1) return arr;\n  while (depth-- && arr.length === 1) arr = arr[0];\n  return arr;\n}\n/**\n * Resolve the value of the field (dot separated) on the given object\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n * @returns {*}\n */\nexport function resolve(obj, selector, options) {\n  let depth = 0;\n  function resolve2(o, path) {\n    let value = o;\n    for (let i = 0; i < path.length; i++) {\n      const field = path[i];\n      const isText = /^\\d+$/.exec(field) === null;\n      // using instanceof to aid typescript compiler\n      if (isText && value instanceof Array) {\n        // On the first iteration, we check if we received a stop flag.\n        // If so, we stop to prevent iterating over a nested array value\n        // on consecutive object keys in the selector.\n        if (i === 0 && depth > 0) break;\n        depth += 1;\n        // only look at the rest of the path\n        const subpath = path.slice(i);\n        value = value.reduce((acc, item) => {\n          const v = resolve2(item, subpath);\n          if (v !== undefined) acc.push(v);\n          return acc;\n        }, []);\n        break;\n      } else {\n        value = getValue(value, field);\n      }\n      if (value === undefined) break;\n    }\n    return value;\n  }\n  const result = JS_SIMPLE_TYPES.has(getType(obj).toLowerCase()) ? obj : resolve2(obj, selector.split(\".\"));\n  return result instanceof Array && options?.unwrapArray ? unwrap(result, depth) : result;\n}\n/**\n * Returns the full object to the resolved value given by the selector.\n * This function excludes empty values as they aren't practically useful.\n *\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n */\nexport function resolveGraph(obj, selector, options) {\n  const names = selector.split(\".\");\n  const key = names[0];\n  // get the next part of the selector\n  const next = names.slice(1).join(\".\");\n  const isIndex = /^\\d+$/.exec(key) !== null;\n  const hasNext = names.length > 1;\n  let result;\n  let value;\n  if (obj instanceof Array) {\n    if (isIndex) {\n      result = getValue(obj, Number(key));\n      if (hasNext) {\n        result = resolveGraph(result, next, options);\n      }\n      result = [result];\n    } else {\n      result = [];\n      for (const item of obj) {\n        value = resolveGraph(item, selector, options);\n        if (options?.preserveMissing) {\n          if (value === undefined) {\n            value = MISSING;\n          }\n          result.push(value);\n        } else if (value !== undefined) {\n          result.push(value);\n        }\n      }\n    }\n  } else {\n    value = getValue(obj, key);\n    if (hasNext) {\n      value = resolveGraph(value, next, options);\n    }\n    if (value === undefined) return undefined;\n    result = options?.preserveKeys ? {\n      ...obj\n    } : {};\n    result[key] = value;\n  }\n  return result;\n}\n/**\n * Filter out all MISSING values from the object in-place\n *\n * @param obj The object to filter\n */\nexport function filterMissing(obj) {\n  if (obj instanceof Array) {\n    for (let i = obj.length - 1; i >= 0; i--) {\n      if (obj[i] === MISSING) {\n        obj.splice(i, 1);\n      } else {\n        filterMissing(obj[i]);\n      }\n    }\n  } else if (isObject(obj)) {\n    for (const k in obj) {\n      if (has(obj, k)) {\n        filterMissing(obj[k]);\n      }\n    }\n  }\n}\n/**\n * Walk the object graph and execute the given transform function\n *\n * @param  {Object|Array} obj   The object to traverse\n * @param  {String} selector    The selector\n * @param  {Function} fn Function to execute for value at the end the traversal\n * @return {*}\n */\nfunction walk(obj, selector, fn, options) {\n  if (isNil(obj)) return;\n  const names = selector.split(\".\");\n  const key = names[0];\n  const next = names.slice(1).join(\".\");\n  if (names.length === 1) {\n    fn(obj, key);\n  } else {\n    // force the rest of the graph while traversing\n    if (options?.buildGraph && isNil(obj[key])) {\n      obj[key] = {};\n    }\n    // get the next item\n    const item = obj[key];\n    // we peek to see if next key is an array index.\n    const isNextArrayIndex = !!(names.length > 1 && names[1].match(/^\\d+$/));\n    // if we have an array value but the next key is not an index and the 'descendArray' option is set,\n    // we walk each item in the array separately. This allows for handling traversing keys for objects\n    // nested within an array.\n    //\n    // Eg: Given { array: [ {k:1}, {k:2}, {k:3} ] }\n    //  - individual objecs can be traversed with \"array.k\"\n    //  - a specific object can be traversed with \"array.1\"\n    if (item instanceof Array && options?.descendArray && !isNextArrayIndex) {\n      item.forEach(e => walk(e, next, fn, options));\n    } else {\n      walk(item, next, fn, options);\n    }\n  }\n}\n/**\n * Set the value of the given object field\n *\n * @param obj {Object|Array} the object context\n * @param selector {String} path to field\n * @param value {*} the value to set\n */\nexport function setValue(obj, selector, value) {\n  walk(obj, selector, (item, key) => {\n    item[key] = value;\n  }, {\n    buildGraph: true\n  });\n}\n/**\n * Removes an element from the container.\n * If the selector resolves to an array and the leaf is a non-numeric key,\n * the remove operation will be performed on objects of the array.\n *\n * @param obj {ArrayOrObject} object or array\n * @param selector {String} dot separated path to element to remove\n */\nexport function removeValue(obj, selector, options) {\n  walk(obj, selector, (item, key) => {\n    if (item instanceof Array) {\n      if (/^\\d+$/.test(key)) {\n        item.splice(parseInt(key), 1);\n      } else if (options && options.descendArray) {\n        for (const elem of item) {\n          if (isObject(elem)) {\n            delete elem[key];\n          }\n        }\n      }\n    } else if (isObject(item)) {\n      delete item[key];\n    }\n  }, options);\n}\nconst OPERATOR_NAME_PATTERN = /^\\$[a-zA-Z0-9_]+$/;\n/**\n * Check whether the given name passes for an operator. We assume AnyVal field name starting with '$' is an operator.\n * This is cheap and safe to do since keys beginning with '$' should be reserved for internal use.\n * @param {String} name\n */\nexport function isOperator(name) {\n  return OPERATOR_NAME_PATTERN.test(name);\n}\n/**\n * Simplify expression for easy evaluation with query operators map\n * @param expr\n * @returns {*}\n */\nexport function normalize(expr) {\n  // normalized primitives\n  if (JS_SIMPLE_TYPES.has(getType(expr).toLowerCase())) {\n    return isRegExp(expr) ? {\n      $regex: expr\n    } : {\n      $eq: expr\n    };\n  }\n  // normalize object expression. using ObjectLike handles custom types\n  if (isObjectLike(expr)) {\n    // no valid query operator found, so we do simple comparison\n    if (!Object.keys(expr).some(isOperator)) {\n      return {\n        $eq: expr\n      };\n    }\n    // ensure valid regex\n    if (has(expr, \"$regex\")) {\n      return {\n        $regex: new RegExp(expr[\"$regex\"], expr[\"$options\"])\n      };\n    }\n  }\n  return expr;\n}","map":{"version":3,"names":["MAX_INT","MIN_INT","MAX_LONG","Number","MAX_SAFE_INTEGER","MIN_LONG","MIN_SAFE_INTEGER","MISSING","Symbol","DEFAULT_HASH_FUNCTION","value","s","stringify","hash","i","length","charCodeAt","JS_SIMPLE_TYPES","Set","SORT_ORDER_BY_TYPE","null","undefined","number","string","object","array","boolean","date","regexp","function","DEFAULT_COMPARATOR","a","b","ta","tb","map","n","getType","toLowerCase","u","v","OBJECT_PROTOTYPE","Object","getPrototypeOf","OBJECT_TAG","OBJECT_TYPE_RE","assert","condition","message","Error","cloneDeep","obj","Array","Date","isObject","objectMap","exec","prototype","toString","call","isBoolean","isString","isNumber","isNaN","isNotNaN","isArray","proto","isObjectLike","isDate","isRegExp","RegExp","isFunction","isNil","inArray","arr","item","includes","notInArray","truthy","arg","strict","isEmpty","x","keys","isMissing","m","ensureArray","has","prop","hasOwnProperty","fn","o","objKeys","k","merge","target","options","inputs","every","flatten","result","input","j","push","into","forEach","addIndex","root","key","index","right","indexes","left","getIndexes","intersection","hashFunction","some","sortedIndex","sort","smallestArray","hashCode","val","h","maxResultSize","orderedIndexes","arrayIndex","data","size","idx","findIndex","isEqual","indexOf","Math","min","freq","parseFloat","filter","xs","depth","flatten2","ys","len","max","lhs","rhs","pop","nativeType","aKeys","bKeys","unique","stack","node","type","JSON","toISOString","join","prefix","sortBy","collection","keyFn","comparator","sorted","groupBy","groups","lookup","MAX_ARRAY_PUSH","rest","reduce","acc","ceil","begin","apply","slice","assign","memoize","memo","args","getValue","unwrap","resolve","selector","resolve2","path","field","isText","subpath","split","unwrapArray","resolveGraph","names","next","isIndex","hasNext","preserveMissing","preserveKeys","filterMissing","splice","walk","buildGraph","isNextArrayIndex","match","descendArray","e","setValue","removeValue","test","parseInt","elem","OPERATOR_NAME_PATTERN","isOperator","name","normalize","expr","$regex","$eq"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/mingo/es/util.js"],"sourcesContent":["/**\n * Utility constants and functions\n */\nexport const MAX_INT = 2147483647;\nexport const MIN_INT = -2147483648;\nexport const MAX_LONG = Number.MAX_SAFE_INTEGER;\nexport const MIN_LONG = Number.MIN_SAFE_INTEGER;\n// special value to identify missing items. treated differently from undefined\nconst MISSING = Symbol(\"missing\");\n/**\n * Uses the simple hash method as described in Effective Java.\n * @see https://stackoverflow.com/a/113600/1370481\n * @param value The value to hash\n * @returns {number}\n */\nconst DEFAULT_HASH_FUNCTION = (value) => {\n    const s = stringify(value);\n    let hash = 0;\n    let i = s.length;\n    while (i)\n        hash = ((hash << 5) - hash) ^ s.charCodeAt(--i);\n    return hash >>> 0;\n};\n// no array, object, or function types\nconst JS_SIMPLE_TYPES = new Set([\n    \"null\",\n    \"undefined\",\n    \"boolean\",\n    \"number\",\n    \"string\",\n    \"date\",\n    \"regexp\",\n]);\n/** MongoDB sort comparison order. https://www.mongodb.com/docs/manual/reference/bson-type-comparison-order */\nconst SORT_ORDER_BY_TYPE = {\n    null: 0,\n    undefined: 0,\n    number: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    boolean: 5,\n    date: 6,\n    regexp: 7,\n    function: 8,\n};\n/**\n * Compare function which adheres to MongoDB comparison order.\n *\n * @param a The first value\n * @param b The second value\n * @returns {Number}\n */\nexport const DEFAULT_COMPARATOR = (a, b) => {\n    if (a === MISSING)\n        a = undefined;\n    if (b === MISSING)\n        b = undefined;\n    const [ta, tb] = [a, b].map((n) => getType(n).toLowerCase());\n    const u = SORT_ORDER_BY_TYPE[ta];\n    const v = SORT_ORDER_BY_TYPE[tb];\n    if (u !== v)\n        return u - v;\n    if (a < b)\n        return -1;\n    if (a > b)\n        return 1;\n    return 0;\n};\nconst OBJECT_PROTOTYPE = Object.getPrototypeOf({});\nconst OBJECT_TAG = \"[object Object]\";\nconst OBJECT_TYPE_RE = /^\\[object ([a-zA-Z0-9]+)\\]$/;\nexport function assert(condition, message) {\n    if (!condition)\n        throw new Error(message);\n}\n/**\n * Deep clone an object\n */\nexport function cloneDeep(obj) {\n    if (obj instanceof Array)\n        return obj.map(cloneDeep);\n    if (obj instanceof Date)\n        return new Date(obj);\n    if (isObject(obj))\n        return objectMap(obj, cloneDeep);\n    return obj;\n}\n/**\n * Returns the name of type as specified in the tag returned by a call to Object.prototype.toString\n * @param v A value\n */\nexport function getType(v) {\n    return OBJECT_TYPE_RE.exec(Object.prototype.toString.call(v))[1];\n}\nexport function isBoolean(v) {\n    return typeof v === \"boolean\";\n}\nexport function isString(v) {\n    return typeof v === \"string\";\n}\nexport function isNumber(v) {\n    return !isNaN(v) && typeof v === \"number\";\n}\nexport function isNotNaN(v) {\n    return !(isNaN(v) && typeof v === \"number\");\n}\nexport const isArray = Array.isArray;\nexport function isObject(v) {\n    if (!v)\n        return false;\n    const proto = Object.getPrototypeOf(v);\n    return ((proto === OBJECT_PROTOTYPE || proto === null) &&\n        OBJECT_TAG === Object.prototype.toString.call(v));\n}\nexport function isObjectLike(v) {\n    return v === Object(v);\n} // objects, arrays, functions, date, custom object\nexport function isDate(v) {\n    return v instanceof Date;\n}\nexport function isRegExp(v) {\n    return v instanceof RegExp;\n}\nexport function isFunction(v) {\n    return typeof v === \"function\";\n}\nexport function isNil(v) {\n    return v === null || v === undefined;\n}\nexport function inArray(arr, item) {\n    return arr.includes(item);\n}\nexport function notInArray(arr, item) {\n    return !inArray(arr, item);\n}\nexport function truthy(arg, strict) {\n    return !!arg || (strict && arg === \"\");\n}\nexport function isEmpty(x) {\n    return (isNil(x) ||\n        (isString(x) && !x) ||\n        (x instanceof Array && x.length === 0) ||\n        (isObject(x) && Object.keys(x).length === 0));\n}\nexport function isMissing(m) {\n    return m === MISSING;\n}\n// ensure a value is an array or wrapped within one\nexport function ensureArray(x) {\n    return x instanceof Array ? x : [x];\n}\nexport function has(obj, prop) {\n    return !!obj && Object.prototype.hasOwnProperty.call(obj, prop);\n}\n/**\n * Transform values in an object\n *\n * @param  {Object}   obj   An object whose values to transform\n * @param  {Function} fn The transform function\n * @return {Array|Object} Result object after applying the transform\n */\nexport function objectMap(obj, fn) {\n    const o = {};\n    const objKeys = Object.keys(obj);\n    for (let i = 0; i < objKeys.length; i++) {\n        const k = objKeys[i];\n        o[k] = fn(obj[k], k);\n    }\n    return o;\n}\n/**\n * Deep merge objects or arrays.\n * When the inputs have unmergeable types, the source value (right hand side) is returned.\n * If inputs are arrays of same length and all elements are mergable, elements in the same position are merged together.\n * If AnyVal of the elements are unmergeable, elements in the source are appended to the target.\n * @param target {Object|Array} the target to merge into\n * @param obj {Object|Array} the source object\n */\nexport function merge(target, obj, options) {\n    // take care of missing inputs\n    if (isMissing(target))\n        return obj;\n    if (isMissing(obj))\n        return target;\n    const inputs = [target, obj];\n    if (!(inputs.every(isObject) || inputs.every(isArray))) {\n        throw Error(\"mismatched types. must both be array or object\");\n    }\n    // default options\n    options = options || { flatten: false };\n    if (isArray(target)) {\n        const result = target;\n        const input = obj;\n        if (options.flatten) {\n            let i = 0;\n            let j = 0;\n            while (i < result.length && j < input.length) {\n                result[i] = merge(result[i++], input[j++], options);\n            }\n            while (j < input.length) {\n                result.push(obj[j++]);\n            }\n        }\n        else {\n            into(result, input);\n        }\n    }\n    else {\n        Object.keys(obj).forEach((k) => {\n            if (has(obj, k)) {\n                if (has(target, k)) {\n                    target[k] = merge(target[k], obj[k], options);\n                }\n                else {\n                    target[k] = obj[k];\n                }\n            }\n        });\n    }\n    return target;\n}\nfunction addIndex(root, key, index) {\n    if (root.key < key) {\n        if (root.right) {\n            addIndex(root.right, key, index);\n        }\n        else {\n            root.right = { key, indexes: [index] };\n        }\n    }\n    else if (root.key > key) {\n        if (root.left) {\n            addIndex(root.left, key, index);\n        }\n        else {\n            root.left = { key, indexes: [index] };\n        }\n    }\n    else {\n        root.indexes.push(index);\n    }\n}\nfunction getIndexes(root, key) {\n    if (root.key == key) {\n        return root.indexes;\n    }\n    else if (root.key < key) {\n        return root.right ? getIndexes(root.right, key) : undefined;\n    }\n    else if (root.key > key) {\n        return root.left ? getIndexes(root.left, key) : undefined;\n    }\n    return undefined;\n}\n/**\n * Returns the intersection of multiple arrays.\n *\n * @param  {Array} a The first array\n * @param  {Array} b The second array\n * @param  {Function} hashFunction Custom function to hash values, default the hashCode method\n * @return {Array}    Result array\n */\nexport function intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n    // if any array is empty, there is no intersection\n    if (input.some((arr) => arr.length == 0))\n        return [];\n    // sort input arrays by size\n    const sortedIndex = input.map((a, i) => [i, a.length]);\n    sortedIndex.sort((a, b) => a[1] - b[1]);\n    // matched items index of first array for all other arrays.\n    const result = [];\n    const smallestArray = input[sortedIndex[0][0]];\n    const root = {\n        key: hashCode(smallestArray[0], hashFunction),\n        indexes: [0],\n    };\n    for (let i = 1; i < smallestArray.length; i++) {\n        const val = smallestArray[i];\n        const h = hashCode(val, hashFunction);\n        addIndex(root, h, i);\n    }\n    let maxResultSize = sortedIndex[0][1];\n    const orderedIndexes = [];\n    for (let i = 1; i < sortedIndex.length; i++) {\n        const arrayIndex = sortedIndex[i][0];\n        const data = input[arrayIndex];\n        // number of matched items\n        let size = 0;\n        for (let j = 0; j < data.length; j++) {\n            const h = hashCode(data[j], hashFunction);\n            const indexes = getIndexes(root, h);\n            // not included.\n            if (!indexes)\n                continue;\n            // check items equality to mitigate hash collisions and select the matching index.\n            const idx = indexes\n                .map((n) => smallestArray[n])\n                .findIndex((v) => isEqual(v, data[j]));\n            // not included\n            if (idx == -1)\n                continue;\n            // item matched. ensure map exist for marking index\n            if (result.length < i)\n                result.push({});\n            // map to index of the actual value and set position\n            result[result.length - 1][indexes[idx]] = true;\n            // if we have seen max result items we can stop.\n            size = Object.keys(result[result.length - 1]).length;\n            // ensure stabilty\n            if (arrayIndex == 0) {\n                if (orderedIndexes.indexOf(indexes[idx]) == -1) {\n                    orderedIndexes.push(indexes[idx]);\n                }\n            }\n        }\n        // no intersection if nothing found\n        if (size == 0)\n            return [];\n        // new max result size\n        maxResultSize = Math.min(maxResultSize, size);\n    }\n    const freq = {};\n    // count occurrences\n    result.forEach((m) => {\n        Object.keys(m).forEach((k) => {\n            const n = parseFloat(k);\n            freq[n] = freq[n] || 0;\n            freq[n]++;\n        });\n    });\n    const keys = orderedIndexes;\n    if (keys.length == 0) {\n        // note: cannot use parseInt due to second argument for radix.\n        keys.push(...Object.keys(freq).map(parseFloat));\n        keys.sort();\n    }\n    return keys\n        .filter((n) => freq[n] == input.length - 1)\n        .map((n) => smallestArray[n]);\n}\n/**\n * Flatten the array\n *\n * @param  {Array} xs The array to flatten\n * @param {Number} depth The number of nested lists to iterate\n */\nexport function flatten(xs, depth) {\n    const arr = [];\n    function flatten2(ys, n) {\n        for (let i = 0, len = ys.length; i < len; i++) {\n            if (isArray(ys[i]) && (n > 0 || n < 0)) {\n                flatten2(ys[i], Math.max(-1, n - 1));\n            }\n            else {\n                arr.push(ys[i]);\n            }\n        }\n    }\n    flatten2(xs, depth);\n    return arr;\n}\n/**\n * Determine whether two values are the same or strictly equivalent\n *\n * @param  {*}  a The first value\n * @param  {*}  b The second value\n * @return {Boolean}   Result of comparison\n */\nexport function isEqual(a, b) {\n    const lhs = [a];\n    const rhs = [b];\n    while (lhs.length > 0) {\n        a = lhs.pop();\n        b = rhs.pop();\n        // strictly equal must be equal.\n        if (a === b)\n            continue;\n        // unequal types and functions cannot be equal.\n        const nativeType = getType(a).toLowerCase();\n        if (nativeType !== getType(b).toLowerCase() || nativeType === \"function\") {\n            return false;\n        }\n        // leverage toString for Date and RegExp types\n        if (nativeType === \"array\") {\n            const xs = a;\n            const ys = b;\n            if (xs.length !== ys.length)\n                return false;\n            if (xs.length === ys.length && xs.length === 0)\n                continue;\n            into(lhs, xs);\n            into(rhs, ys);\n        }\n        else if (nativeType === \"object\") {\n            // deep compare objects\n            const aKeys = Object.keys(a);\n            const bKeys = Object.keys(b);\n            // check length of keys early\n            if (aKeys.length !== bKeys.length)\n                return false;\n            // compare keys\n            for (let i = 0, len = aKeys.length; i < len; i++) {\n                const k = aKeys[i];\n                // not found\n                if (!has(b, k))\n                    return false;\n                // key found\n                lhs.push(a[k]);\n                rhs.push(b[k]);\n            }\n        }\n        else {\n            // compare encoded values\n            if (stringify(a) !== stringify(b))\n                return false;\n        }\n    }\n    return lhs.length === 0;\n}\n/**\n * Return a new unique version of the collection\n * @param  {Array} xs The input collection\n * @return {Array}\n */\nexport function unique(xs, hashFunction = DEFAULT_HASH_FUNCTION) {\n    if (xs.length == 0)\n        return [];\n    const root = {\n        key: hashCode(xs[0], hashFunction),\n        indexes: [0],\n    };\n    // hash items on to tree to track collisions\n    for (let i = 1; i < xs.length; i++) {\n        addIndex(root, hashCode(xs[i], hashFunction), i);\n    }\n    const result = [];\n    // walk tree and remove duplicates\n    const stack = [root];\n    while (stack.length > 0) {\n        const node = stack.pop();\n        if (node.indexes.length == 1) {\n            result.push(node.indexes[0]);\n        }\n        else {\n            // handle collisions by matching all items\n            const arr = node.indexes;\n            // we start by search from the back so we maintain the smaller index when there is a duplicate.\n            while (arr.length > 0) {\n                for (let j = 1; j < arr.length; j++) {\n                    // if last item matches any remove the last item.\n                    if (isEqual(xs[arr[arr.length - 1]], xs[arr[arr.length - 1 - j]])) {\n                        // remove last item\n                        arr.pop();\n                        // reset position\n                        j = 0;\n                    }\n                }\n                // add the unique item\n                result.push(arr.pop());\n            }\n        }\n        // add children\n        if (node.left)\n            stack.push(node.left);\n        if (node.right)\n            stack.push(node.right);\n    }\n    // sort indexes for stability\n    result.sort();\n    // return the unique items\n    return result.map((i) => xs[i]);\n}\n/**\n * Encode value to string using a simple non-colliding stable scheme.\n *\n * @param value\n * @returns {*}\n */\nexport function stringify(value) {\n    const type = getType(value).toLowerCase();\n    switch (type) {\n        case \"boolean\":\n        case \"number\":\n        case \"regexp\":\n            return value.toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"date\":\n            return value.toISOString();\n        case \"null\":\n        case \"undefined\":\n            return type;\n        case \"array\":\n            return \"[\" + value.map(stringify).join(\",\") + \"]\";\n        default:\n            break;\n    }\n    // default case\n    const prefix = type === \"object\" ? \"\" : `${getType(value)}`;\n    const objKeys = Object.keys(value);\n    objKeys.sort();\n    return (`${prefix}{` +\n        objKeys.map((k) => `${stringify(k)}:${stringify(value[k])}`).join(\",\") +\n        \"}\");\n}\n/**\n * Generate hash code\n * This selected function is the result of benchmarking various hash functions.\n * This version performs well and can hash 10^6 documents in ~3s with on average 100 collisions.\n *\n * @param value\n * @returns {number|null}\n */\nexport function hashCode(value, hashFunction = DEFAULT_HASH_FUNCTION) {\n    if (isNil(value))\n        return null;\n    return hashFunction(value).toString();\n}\n/**\n * Returns a (stably) sorted copy of list, ranked in ascending order by the results of running each value through iteratee\n *\n * This implementation treats null/undefined sort keys as less than every other type\n *\n * @param {Array}   collection\n * @param {Function} keyFn The sort key function used to resolve sort keys\n * @param {Function} comparator The comparator function to use for comparing keys. Defaults to standard comparison via `compare(...)`\n * @return {Array} Returns a new sorted array by the given key and comparator function\n */\nexport function sortBy(collection, keyFn, comparator = DEFAULT_COMPARATOR) {\n    const sorted = [];\n    const result = [];\n    if (isEmpty(collection))\n        return collection;\n    for (let i = 0; i < collection.length; i++) {\n        const obj = collection[i];\n        const key = keyFn(obj, i);\n        if (isNil(key)) {\n            result.push(obj);\n        }\n        else {\n            sorted.push([key, obj]);\n        }\n    }\n    // use native array sorting but enforce stableness\n    sorted.sort((a, b) => comparator(a[0], b[0]));\n    result.push(...sorted.map((o) => o[1]));\n    return result;\n}\n/**\n * Groups the collection into sets by the returned key\n *\n * @param collection\n * @param keyFn {Function} to compute the group key of an item in the collection\n * @returns {{keys: Array, groups: Array}}\n */\nexport function groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {\n    const result = {\n        keys: new Array(),\n        groups: new Array(),\n    };\n    const lookup = {};\n    for (let i = 0; i < collection.length; i++) {\n        const obj = collection[i];\n        const key = keyFn(obj, i);\n        const hash = hashCode(key, hashFunction);\n        let index = -1;\n        if (lookup[hash] === undefined) {\n            index = result.keys.length;\n            lookup[hash] = index;\n            result.keys.push(key);\n            result.groups.push([]);\n        }\n        index = lookup[hash];\n        result.groups[index].push(obj);\n    }\n    return result;\n}\n// max elements to push.\n// See argument limit https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\nconst MAX_ARRAY_PUSH = 50000;\n/**\n * Merge elements into the dest\n *\n * @param {*} target The target object\n * @param {*} rest The array of elements to merge into dest\n */\nexport function into(target, ...rest) {\n    if (target instanceof Array) {\n        return rest.reduce((acc, arr) => {\n            // push arrary in batches to handle large inputs\n            let i = Math.ceil(arr.length / MAX_ARRAY_PUSH);\n            let begin = 0;\n            while (i-- > 0) {\n                Array.prototype.push.apply(acc, arr.slice(begin, begin + MAX_ARRAY_PUSH));\n                begin += MAX_ARRAY_PUSH;\n            }\n            return acc;\n        }, target);\n    }\n    else {\n        // merge objects. same behaviour as Object.assign\n        return rest.filter(isObjectLike).reduce((acc, item) => {\n            Object.assign(acc, item);\n            return acc;\n        }, target);\n    }\n}\n/**\n * This is a generic memoization function\n *\n * This implementation uses a cache independent of the function being memoized\n * to allow old values to be garbage collected when the memoized function goes out of scope.\n *\n * @param {*} fn The function object to memoize\n */\nexport function memoize(fn, hashFunction = DEFAULT_HASH_FUNCTION) {\n    return ((memo) => {\n        return (...args) => {\n            const key = hashCode(args, hashFunction);\n            if (!has(memo, key)) {\n                memo[key] = fn.apply(this, args);\n            }\n            return memo[key];\n        };\n    })({\n    /* storage */\n    });\n}\n// mingo internal\n/**\n * Retrieve the value of a given key on an object\n * @param obj\n * @param key\n * @returns {*}\n * @private\n */\nfunction getValue(obj, key) {\n    return isObjectLike(obj) ? obj[key] : undefined;\n}\n/**\n * Unwrap a single element array to specified depth\n * @param {Array} arr\n * @param {Number} depth\n */\nfunction unwrap(arr, depth) {\n    if (depth < 1)\n        return arr;\n    while (depth-- && arr.length === 1)\n        arr = arr[0];\n    return arr;\n}\n/**\n * Resolve the value of the field (dot separated) on the given object\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n * @returns {*}\n */\nexport function resolve(obj, selector, options) {\n    let depth = 0;\n    function resolve2(o, path) {\n        let value = o;\n        for (let i = 0; i < path.length; i++) {\n            const field = path[i];\n            const isText = /^\\d+$/.exec(field) === null;\n            // using instanceof to aid typescript compiler\n            if (isText && value instanceof Array) {\n                // On the first iteration, we check if we received a stop flag.\n                // If so, we stop to prevent iterating over a nested array value\n                // on consecutive object keys in the selector.\n                if (i === 0 && depth > 0)\n                    break;\n                depth += 1;\n                // only look at the rest of the path\n                const subpath = path.slice(i);\n                value = value.reduce((acc, item) => {\n                    const v = resolve2(item, subpath);\n                    if (v !== undefined)\n                        acc.push(v);\n                    return acc;\n                }, []);\n                break;\n            }\n            else {\n                value = getValue(value, field);\n            }\n            if (value === undefined)\n                break;\n        }\n        return value;\n    }\n    const result = JS_SIMPLE_TYPES.has(getType(obj).toLowerCase())\n        ? obj\n        : resolve2(obj, selector.split(\".\"));\n    return result instanceof Array && options?.unwrapArray\n        ? unwrap(result, depth)\n        : result;\n}\n/**\n * Returns the full object to the resolved value given by the selector.\n * This function excludes empty values as they aren't practically useful.\n *\n * @param obj {Object} the object context\n * @param selector {String} dot separated path to field\n */\nexport function resolveGraph(obj, selector, options) {\n    const names = selector.split(\".\");\n    const key = names[0];\n    // get the next part of the selector\n    const next = names.slice(1).join(\".\");\n    const isIndex = /^\\d+$/.exec(key) !== null;\n    const hasNext = names.length > 1;\n    let result;\n    let value;\n    if (obj instanceof Array) {\n        if (isIndex) {\n            result = getValue(obj, Number(key));\n            if (hasNext) {\n                result = resolveGraph(result, next, options);\n            }\n            result = [result];\n        }\n        else {\n            result = [];\n            for (const item of obj) {\n                value = resolveGraph(item, selector, options);\n                if (options?.preserveMissing) {\n                    if (value === undefined) {\n                        value = MISSING;\n                    }\n                    result.push(value);\n                }\n                else if (value !== undefined) {\n                    result.push(value);\n                }\n            }\n        }\n    }\n    else {\n        value = getValue(obj, key);\n        if (hasNext) {\n            value = resolveGraph(value, next, options);\n        }\n        if (value === undefined)\n            return undefined;\n        result = options?.preserveKeys ? { ...obj } : {};\n        result[key] = value;\n    }\n    return result;\n}\n/**\n * Filter out all MISSING values from the object in-place\n *\n * @param obj The object to filter\n */\nexport function filterMissing(obj) {\n    if (obj instanceof Array) {\n        for (let i = obj.length - 1; i >= 0; i--) {\n            if (obj[i] === MISSING) {\n                obj.splice(i, 1);\n            }\n            else {\n                filterMissing(obj[i]);\n            }\n        }\n    }\n    else if (isObject(obj)) {\n        for (const k in obj) {\n            if (has(obj, k)) {\n                filterMissing(obj[k]);\n            }\n        }\n    }\n}\n/**\n * Walk the object graph and execute the given transform function\n *\n * @param  {Object|Array} obj   The object to traverse\n * @param  {String} selector    The selector\n * @param  {Function} fn Function to execute for value at the end the traversal\n * @return {*}\n */\nfunction walk(obj, selector, fn, options) {\n    if (isNil(obj))\n        return;\n    const names = selector.split(\".\");\n    const key = names[0];\n    const next = names.slice(1).join(\".\");\n    if (names.length === 1) {\n        fn(obj, key);\n    }\n    else {\n        // force the rest of the graph while traversing\n        if (options?.buildGraph && isNil(obj[key])) {\n            obj[key] = {};\n        }\n        // get the next item\n        const item = obj[key];\n        // we peek to see if next key is an array index.\n        const isNextArrayIndex = !!(names.length > 1 && names[1].match(/^\\d+$/));\n        // if we have an array value but the next key is not an index and the 'descendArray' option is set,\n        // we walk each item in the array separately. This allows for handling traversing keys for objects\n        // nested within an array.\n        //\n        // Eg: Given { array: [ {k:1}, {k:2}, {k:3} ] }\n        //  - individual objecs can be traversed with \"array.k\"\n        //  - a specific object can be traversed with \"array.1\"\n        if (item instanceof Array && options?.descendArray && !isNextArrayIndex) {\n            item.forEach((e) => walk(e, next, fn, options));\n        }\n        else {\n            walk(item, next, fn, options);\n        }\n    }\n}\n/**\n * Set the value of the given object field\n *\n * @param obj {Object|Array} the object context\n * @param selector {String} path to field\n * @param value {*} the value to set\n */\nexport function setValue(obj, selector, value) {\n    walk(obj, selector, (item, key) => {\n        item[key] = value;\n    }, { buildGraph: true });\n}\n/**\n * Removes an element from the container.\n * If the selector resolves to an array and the leaf is a non-numeric key,\n * the remove operation will be performed on objects of the array.\n *\n * @param obj {ArrayOrObject} object or array\n * @param selector {String} dot separated path to element to remove\n */\nexport function removeValue(obj, selector, options) {\n    walk(obj, selector, (item, key) => {\n        if (item instanceof Array) {\n            if (/^\\d+$/.test(key)) {\n                item.splice(parseInt(key), 1);\n            }\n            else if (options && options.descendArray) {\n                for (const elem of item) {\n                    if (isObject(elem)) {\n                        delete elem[key];\n                    }\n                }\n            }\n        }\n        else if (isObject(item)) {\n            delete item[key];\n        }\n    }, options);\n}\nconst OPERATOR_NAME_PATTERN = /^\\$[a-zA-Z0-9_]+$/;\n/**\n * Check whether the given name passes for an operator. We assume AnyVal field name starting with '$' is an operator.\n * This is cheap and safe to do since keys beginning with '$' should be reserved for internal use.\n * @param {String} name\n */\nexport function isOperator(name) {\n    return OPERATOR_NAME_PATTERN.test(name);\n}\n/**\n * Simplify expression for easy evaluation with query operators map\n * @param expr\n * @returns {*}\n */\nexport function normalize(expr) {\n    // normalized primitives\n    if (JS_SIMPLE_TYPES.has(getType(expr).toLowerCase())) {\n        return isRegExp(expr) ? { $regex: expr } : { $eq: expr };\n    }\n    // normalize object expression. using ObjectLike handles custom types\n    if (isObjectLike(expr)) {\n        // no valid query operator found, so we do simple comparison\n        if (!Object.keys(expr).some(isOperator)) {\n            return { $eq: expr };\n        }\n        // ensure valid regex\n        if (has(expr, \"$regex\")) {\n            return {\n                $regex: new RegExp(expr[\"$regex\"], expr[\"$options\"]),\n            };\n        }\n    }\n    return expr;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}