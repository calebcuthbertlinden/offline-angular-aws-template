{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { isBulkWriteConflictError, rxStorageWriteErrorToRxError } from './rx-error';\nimport { clone, ensureNotFalsy, getFromMapOrCreate, getFromMapOrThrow, parseRevision, stripMetaDataFromDocument } from './plugins/utils';\n/**\n * The incremental write queue\n * batches up all incremental writes to a collection\n * so that performance can be improved by:\n * - Running only one write even when there are multiple modifications to the same document.\n * - Run all writes ins a single bulkWrite() call even when there are writes to many documents.\n */\nexport var IncrementalWriteQueue = /*#__PURE__*/function () {\n  function IncrementalWriteQueue(storageInstance, primaryPath,\n  // can be used to run hooks etc.\n  preWrite, postWrite) {\n    this.queueByDocId = new Map();\n    this.isRunning = false;\n    this.storageInstance = storageInstance;\n    this.primaryPath = primaryPath;\n    this.preWrite = preWrite;\n    this.postWrite = postWrite;\n  }\n  var _proto = IncrementalWriteQueue.prototype;\n  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {\n    var docId = lastKnownDocumentState[this.primaryPath];\n    var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n    var ret = new Promise((resolve, reject) => {\n      var item = {\n        lastKnownDocumentState,\n        modifier,\n        resolve,\n        reject\n      };\n      ensureNotFalsy(ar).push(item);\n      this.triggerRun();\n    });\n    return ret;\n  };\n  _proto.triggerRun = /*#__PURE__*/function () {\n    var _triggerRun = _asyncToGenerator(function* () {\n      var _this = this;\n      if (this.isRunning === true || this.queueByDocId.size === 0) {\n        // already running\n        return;\n      }\n      this.isRunning = true;\n      var writeRows = [];\n\n      /**\n       * 'take over' so that while the async functions runs,\n       * new incremental updates could be added from the outside.\n       */\n      var itemsById = this.queueByDocId;\n      this.queueByDocId = new Map();\n      yield Promise.all(Array.from(itemsById.entries()).map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* ([_docId, items]) {\n          var oldData = findNewestOfDocumentStates(items.map(i => i.lastKnownDocumentState));\n          var newData = oldData;\n          for (var item of items) {\n            try {\n              newData = yield item.modifier(\n              /**\n               * We have to clone() each time because the modifier\n               * might throw while it already changed some properties\n               * of the document.\n               */\n              clone(newData));\n            } catch (err) {\n              item.reject(err);\n              item.reject = () => {};\n              item.resolve = () => {};\n            }\n          }\n          try {\n            yield _this.preWrite(newData, oldData);\n          } catch (err) {\n            /**\n             * If the before-hooks fail,\n             * we reject all of the writes because it is\n             * not possible to determine which one is to blame.\n             */\n            items.forEach(item => item.reject(err));\n            return;\n          }\n          writeRows.push({\n            previous: oldData,\n            document: newData\n          });\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      var writeResult = writeRows.length > 0 ? yield this.storageInstance.bulkWrite(writeRows, 'incremental-write') : {\n        error: {},\n        success: {}\n      };\n\n      // process success\n      yield Promise.all(Array.from(Object.entries(writeResult.success)).map(([docId, result]) => {\n        this.postWrite(result);\n        var items = getFromMapOrThrow(itemsById, docId);\n        items.forEach(item => item.resolve(result));\n      }));\n\n      // process errors\n      Array.from(Object.entries(writeResult.error)).forEach(([docId, error]) => {\n        var items = getFromMapOrThrow(itemsById, docId);\n        var isConflict = isBulkWriteConflictError(error);\n        if (isConflict) {\n          // had conflict -> retry afterwards\n          var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n          /**\n           * Add the items back to this.queueByDocId\n           * by maintaining the original order.\n           */\n          items.reverse().forEach(item => {\n            item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);\n            ensureNotFalsy(ar).unshift(item);\n          });\n        } else {\n          // other error -> must be thrown\n          var rxError = rxStorageWriteErrorToRxError(error);\n          items.forEach(item => item.reject(rxError));\n        }\n      });\n      this.isRunning = false;\n\n      /**\n       * Always trigger another run\n       * because in between there might be new items\n       * been added to the queue.\n       */\n      return this.triggerRun();\n    });\n    function triggerRun() {\n      return _triggerRun.apply(this, arguments);\n    }\n    return triggerRun;\n  }();\n  return IncrementalWriteQueue;\n}();\nexport function modifierFromPublicToInternal(publicModifier) {\n  var ret = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* (docData) {\n      var withoutMeta = stripMetaDataFromDocument(docData);\n      withoutMeta._deleted = docData._deleted;\n      var modified = yield publicModifier(withoutMeta);\n      var reattachedMeta = Object.assign({}, modified, {\n        _meta: docData._meta,\n        _attachments: docData._attachments,\n        _rev: docData._rev,\n        _deleted: typeof modified._deleted !== 'undefined' ? modified._deleted : docData._deleted\n      });\n      if (typeof reattachedMeta._deleted === 'undefined') {\n        reattachedMeta._deleted = false;\n      }\n      return reattachedMeta;\n    });\n    return function ret(_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  return ret;\n}\nexport function findNewestOfDocumentStates(docs) {\n  var newest = docs[0];\n  var newestRevisionHeight = parseRevision(newest._rev).height;\n  docs.forEach(doc => {\n    var height = parseRevision(doc._rev).height;\n    if (height > newestRevisionHeight) {\n      newest = doc;\n      newestRevisionHeight = height;\n    }\n  });\n  return newest;\n}","map":{"version":3,"names":["isBulkWriteConflictError","rxStorageWriteErrorToRxError","clone","ensureNotFalsy","getFromMapOrCreate","getFromMapOrThrow","parseRevision","stripMetaDataFromDocument","IncrementalWriteQueue","storageInstance","primaryPath","preWrite","postWrite","queueByDocId","Map","isRunning","_proto","prototype","addWrite","lastKnownDocumentState","modifier","docId","ar","ret","Promise","resolve","reject","item","push","triggerRun","_triggerRun","_asyncToGenerator","_this","size","writeRows","itemsById","all","Array","from","entries","map","_ref","_docId","items","oldData","findNewestOfDocumentStates","i","newData","err","forEach","previous","document","_x","apply","arguments","writeResult","length","bulkWrite","error","success","Object","result","isConflict","reverse","documentInDb","unshift","rxError","modifierFromPublicToInternal","publicModifier","_ref2","docData","withoutMeta","_deleted","modified","reattachedMeta","assign","_meta","_attachments","_rev","_x2","docs","newest","newestRevisionHeight","height","doc"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/incremental-write.js"],"sourcesContent":["import { isBulkWriteConflictError, rxStorageWriteErrorToRxError } from './rx-error';\nimport { clone, ensureNotFalsy, getFromMapOrCreate, getFromMapOrThrow, parseRevision, stripMetaDataFromDocument } from './plugins/utils';\n/**\n * The incremental write queue\n * batches up all incremental writes to a collection\n * so that performance can be improved by:\n * - Running only one write even when there are multiple modifications to the same document.\n * - Run all writes ins a single bulkWrite() call even when there are writes to many documents.\n */\nexport var IncrementalWriteQueue = /*#__PURE__*/function () {\n  function IncrementalWriteQueue(storageInstance, primaryPath,\n  // can be used to run hooks etc.\n  preWrite, postWrite) {\n    this.queueByDocId = new Map();\n    this.isRunning = false;\n    this.storageInstance = storageInstance;\n    this.primaryPath = primaryPath;\n    this.preWrite = preWrite;\n    this.postWrite = postWrite;\n  }\n  var _proto = IncrementalWriteQueue.prototype;\n  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {\n    var docId = lastKnownDocumentState[this.primaryPath];\n    var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n    var ret = new Promise((resolve, reject) => {\n      var item = {\n        lastKnownDocumentState,\n        modifier,\n        resolve,\n        reject\n      };\n      ensureNotFalsy(ar).push(item);\n      this.triggerRun();\n    });\n    return ret;\n  };\n  _proto.triggerRun = async function triggerRun() {\n    if (this.isRunning === true || this.queueByDocId.size === 0) {\n      // already running\n      return;\n    }\n    this.isRunning = true;\n    var writeRows = [];\n\n    /**\n     * 'take over' so that while the async functions runs,\n     * new incremental updates could be added from the outside.\n     */\n    var itemsById = this.queueByDocId;\n    this.queueByDocId = new Map();\n    await Promise.all(Array.from(itemsById.entries()).map(async ([_docId, items]) => {\n      var oldData = findNewestOfDocumentStates(items.map(i => i.lastKnownDocumentState));\n      var newData = oldData;\n      for (var item of items) {\n        try {\n          newData = await item.modifier(\n          /**\n           * We have to clone() each time because the modifier\n           * might throw while it already changed some properties\n           * of the document.\n           */\n          clone(newData));\n        } catch (err) {\n          item.reject(err);\n          item.reject = () => {};\n          item.resolve = () => {};\n        }\n      }\n      try {\n        await this.preWrite(newData, oldData);\n      } catch (err) {\n        /**\n         * If the before-hooks fail,\n         * we reject all of the writes because it is\n         * not possible to determine which one is to blame.\n         */\n        items.forEach(item => item.reject(err));\n        return;\n      }\n      writeRows.push({\n        previous: oldData,\n        document: newData\n      });\n    }));\n    var writeResult = writeRows.length > 0 ? await this.storageInstance.bulkWrite(writeRows, 'incremental-write') : {\n      error: {},\n      success: {}\n    };\n\n    // process success\n    await Promise.all(Array.from(Object.entries(writeResult.success)).map(([docId, result]) => {\n      this.postWrite(result);\n      var items = getFromMapOrThrow(itemsById, docId);\n      items.forEach(item => item.resolve(result));\n    }));\n\n    // process errors\n    Array.from(Object.entries(writeResult.error)).forEach(([docId, error]) => {\n      var items = getFromMapOrThrow(itemsById, docId);\n      var isConflict = isBulkWriteConflictError(error);\n      if (isConflict) {\n        // had conflict -> retry afterwards\n        var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n        /**\n         * Add the items back to this.queueByDocId\n         * by maintaining the original order.\n         */\n        items.reverse().forEach(item => {\n          item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);\n          ensureNotFalsy(ar).unshift(item);\n        });\n      } else {\n        // other error -> must be thrown\n        var rxError = rxStorageWriteErrorToRxError(error);\n        items.forEach(item => item.reject(rxError));\n      }\n    });\n    this.isRunning = false;\n\n    /**\n     * Always trigger another run\n     * because in between there might be new items\n     * been added to the queue.\n     */\n    return this.triggerRun();\n  };\n  return IncrementalWriteQueue;\n}();\nexport function modifierFromPublicToInternal(publicModifier) {\n  var ret = async docData => {\n    var withoutMeta = stripMetaDataFromDocument(docData);\n    withoutMeta._deleted = docData._deleted;\n    var modified = await publicModifier(withoutMeta);\n    var reattachedMeta = Object.assign({}, modified, {\n      _meta: docData._meta,\n      _attachments: docData._attachments,\n      _rev: docData._rev,\n      _deleted: typeof modified._deleted !== 'undefined' ? modified._deleted : docData._deleted\n    });\n    if (typeof reattachedMeta._deleted === 'undefined') {\n      reattachedMeta._deleted = false;\n    }\n    return reattachedMeta;\n  };\n  return ret;\n}\nexport function findNewestOfDocumentStates(docs) {\n  var newest = docs[0];\n  var newestRevisionHeight = parseRevision(newest._rev).height;\n  docs.forEach(doc => {\n    var height = parseRevision(doc._rev).height;\n    if (height > newestRevisionHeight) {\n      newest = doc;\n      newestRevisionHeight = height;\n    }\n  });\n  return newest;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}