{"ast":null,"code":"/**\n * For some RxStorage implementations,\n * we need to use our custom crafted indexes\n * so we can easily iterate over them. And sort plain arrays of document data.\n *\n * We really often have to craft an index string for a given document.\n * Performance of everything in this file is very important\n * which is why the code sometimes looks strange.\n * Run performance tests before and after you touch anything here!\n */\n\nimport { getSchemaByObjectPath } from './rx-schema-helper';\nimport { ensureNotFalsy, objectPathMonad } from './plugins/utils';\nimport { INDEX_MAX, INDEX_MIN } from './query-planner';\n\n/**\n * Prepare all relevant information\n * outside of the returned function\n * from getIndexableStringMonad()\n * to save performance when the returned\n * function is called many times.\n */\n\nexport function getIndexMeta(schema, index) {\n  var fieldNameProperties = index.map(fieldName => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    if (!schemaPart) {\n      throw new Error('not in schema: ' + fieldName);\n    }\n    var type = schemaPart.type;\n    var parsedLengths;\n    if (type === 'number' || type === 'integer') {\n      parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n    }\n    var getValue = objectPathMonad(fieldName);\n    var maxLength = schemaPart.maxLength ? schemaPart.maxLength : 0;\n    var getIndexStringPart;\n    if (type === 'string') {\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        if (!fieldValue) {\n          fieldValue = '';\n        }\n        return fieldValue.padEnd(maxLength, ' ');\n      };\n    } else if (type === 'boolean') {\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        return fieldValue ? '1' : '0';\n      };\n    } else {\n      // number\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        return getNumberIndexString(parsedLengths, fieldValue);\n      };\n    }\n    var ret = {\n      fieldName,\n      schemaPart,\n      parsedLengths,\n      getValue,\n      getIndexStringPart\n    };\n    return ret;\n  });\n  return fieldNameProperties;\n}\n\n/**\n * Crafts an indexable string that can be used\n * to check if a document would be sorted below or above\n * another documents, dependent on the index values.\n * @monad for better performance\n *\n * IMPORTANT: Performance is really important here\n * which is why we code so 'strange'.\n * Always run performance tests when you want to\n * change something in this method.\n */\nexport function getIndexableStringMonad(schema, index) {\n  var fieldNameProperties = getIndexMeta(schema, index);\n  var fieldNamePropertiesAmount = fieldNameProperties.length;\n  var indexPartsFunctions = fieldNameProperties.map(r => r.getIndexStringPart);\n\n  /**\n   * @hotPath Performance of this function is very critical!\n   */\n  var ret = function (docData) {\n    var str = '';\n    for (var i = 0; i < fieldNamePropertiesAmount; ++i) {\n      str += indexPartsFunctions[i](docData);\n    }\n    return str;\n  };\n  return ret;\n}\nexport function getStringLengthOfIndexNumber(schemaPart) {\n  var minimum = Math.floor(schemaPart.minimum);\n  var maximum = Math.ceil(schemaPart.maximum);\n  var multipleOf = schemaPart.multipleOf;\n  var valueSpan = maximum - minimum;\n  var nonDecimals = valueSpan.toString().length;\n  var multipleOfParts = multipleOf.toString().split('.');\n  var decimals = 0;\n  if (multipleOfParts.length > 1) {\n    decimals = multipleOfParts[1].length;\n  }\n  return {\n    minimum,\n    maximum,\n    nonDecimals,\n    decimals,\n    roundedMinimum: minimum\n  };\n}\nexport function getIndexStringLength(schema, index) {\n  var fieldNameProperties = getIndexMeta(schema, index);\n  var length = 0;\n  fieldNameProperties.forEach(props => {\n    var schemaPart = props.schemaPart;\n    var type = schemaPart.type;\n    if (type === 'string') {\n      length += schemaPart.maxLength;\n    } else if (type === 'boolean') {\n      length += 1;\n    } else {\n      var parsedLengths = props.parsedLengths;\n      length = length + parsedLengths.nonDecimals + parsedLengths.decimals;\n    }\n  });\n  return length;\n}\nexport function getPrimaryKeyFromIndexableString(indexableString, primaryKeyLength) {\n  var paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);\n  // we can safely trim here because the primary key is not allowed to start or end with a space char.\n  var primaryKey = paddedPrimaryKey.trim();\n  return primaryKey;\n}\nexport function getNumberIndexString(parsedLengths, fieldValue) {\n  /**\n   * Ensure that the given value is in the boundaries\n   * of the schema, otherwise it would create a broken index string.\n   * This can happen for example if you have a minimum of 0\n   * and run a query like\n   * selector {\n   *  numField: { $gt: -1000 }\n   * }\n   */\n  if (typeof fieldValue === 'undefined') {\n    fieldValue = 0;\n  }\n  if (fieldValue < parsedLengths.minimum) {\n    fieldValue = parsedLengths.minimum;\n  }\n  if (fieldValue > parsedLengths.maximum) {\n    fieldValue = parsedLengths.maximum;\n  }\n  var nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\n  var str = nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\n  if (parsedLengths.decimals > 0) {\n    var splitByDecimalPoint = fieldValue.toString().split('.');\n    var decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : '0';\n    str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\n  }\n  return str;\n}\nexport function getStartIndexStringFromLowerBound(schema, index, lowerBound, inclusiveStart) {\n  var str = '';\n  index.forEach((fieldName, idx) => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    var bound = lowerBound[idx];\n    var type = schemaPart.type;\n    switch (type) {\n      case 'string':\n        var maxLength = ensureNotFalsy(schemaPart.maxLength);\n        if (typeof bound === 'string') {\n          str += bound.padEnd(maxLength, ' ');\n        } else {\n          // str += ''.padStart(maxLength, inclusiveStart ? ' ' : INDEX_MAX);\n          str += ''.padEnd(maxLength, ' ');\n        }\n        break;\n      case 'boolean':\n        if (bound === null) {\n          str += inclusiveStart ? '0' : INDEX_MAX;\n        } else {\n          var boolToStr = bound ? '1' : '0';\n          str += boolToStr;\n        }\n        break;\n      case 'number':\n      case 'integer':\n        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n        if (bound === null || bound === INDEX_MIN) {\n          var fillChar = inclusiveStart ? '0' : INDEX_MAX;\n          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else {\n          str += getNumberIndexString(parsedLengths, bound);\n        }\n        break;\n      default:\n        throw new Error('unknown index type ' + type);\n    }\n  });\n  return str;\n}\nexport function getStartIndexStringFromUpperBound(schema, index, upperBound, inclusiveEnd) {\n  var str = '';\n  index.forEach((fieldName, idx) => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    var bound = upperBound[idx];\n    var type = schemaPart.type;\n    switch (type) {\n      case 'string':\n        var maxLength = ensureNotFalsy(schemaPart.maxLength);\n        if (typeof bound === 'string') {\n          str += bound.padEnd(maxLength, inclusiveEnd ? INDEX_MAX : ' ');\n        } else {\n          str += ''.padEnd(maxLength, inclusiveEnd ? INDEX_MAX : ' ');\n        }\n        break;\n      case 'boolean':\n        if (bound === null) {\n          str += inclusiveEnd ? '0' : '1';\n        } else {\n          var boolToStr = bound ? '1' : '0';\n          str += boolToStr;\n        }\n        break;\n      case 'number':\n      case 'integer':\n        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n        if (bound === null || bound === INDEX_MAX) {\n          var fillChar = inclusiveEnd ? '9' : '0';\n          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else {\n          str += getNumberIndexString(parsedLengths, bound);\n        }\n        break;\n      default:\n        throw new Error('unknown index type ' + type);\n    }\n  });\n  return str;\n}","map":{"version":3,"names":["getSchemaByObjectPath","ensureNotFalsy","objectPathMonad","INDEX_MAX","INDEX_MIN","getIndexMeta","schema","index","fieldNameProperties","map","fieldName","schemaPart","Error","type","parsedLengths","getStringLengthOfIndexNumber","getValue","maxLength","getIndexStringPart","docData","fieldValue","padEnd","getNumberIndexString","ret","getIndexableStringMonad","fieldNamePropertiesAmount","length","indexPartsFunctions","r","str","i","minimum","Math","floor","maximum","ceil","multipleOf","valueSpan","nonDecimals","toString","multipleOfParts","split","decimals","roundedMinimum","getIndexStringLength","forEach","props","getPrimaryKeyFromIndexableString","indexableString","primaryKeyLength","paddedPrimaryKey","slice","primaryKey","trim","nonDecimalsValueAsString","padStart","splitByDecimalPoint","decimalValueAsString","getStartIndexStringFromLowerBound","lowerBound","inclusiveStart","idx","bound","boolToStr","fillChar","repeat","getStartIndexStringFromUpperBound","upperBound","inclusiveEnd"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/custom-index.js"],"sourcesContent":["/**\n * For some RxStorage implementations,\n * we need to use our custom crafted indexes\n * so we can easily iterate over them. And sort plain arrays of document data.\n *\n * We really often have to craft an index string for a given document.\n * Performance of everything in this file is very important\n * which is why the code sometimes looks strange.\n * Run performance tests before and after you touch anything here!\n */\n\nimport { getSchemaByObjectPath } from './rx-schema-helper';\nimport { ensureNotFalsy, objectPathMonad } from './plugins/utils';\nimport { INDEX_MAX, INDEX_MIN } from './query-planner';\n\n/**\n * Prepare all relevant information\n * outside of the returned function\n * from getIndexableStringMonad()\n * to save performance when the returned\n * function is called many times.\n */\n\nexport function getIndexMeta(schema, index) {\n  var fieldNameProperties = index.map(fieldName => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    if (!schemaPart) {\n      throw new Error('not in schema: ' + fieldName);\n    }\n    var type = schemaPart.type;\n    var parsedLengths;\n    if (type === 'number' || type === 'integer') {\n      parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n    }\n    var getValue = objectPathMonad(fieldName);\n    var maxLength = schemaPart.maxLength ? schemaPart.maxLength : 0;\n    var getIndexStringPart;\n    if (type === 'string') {\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        if (!fieldValue) {\n          fieldValue = '';\n        }\n        return fieldValue.padEnd(maxLength, ' ');\n      };\n    } else if (type === 'boolean') {\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        return fieldValue ? '1' : '0';\n      };\n    } else {\n      // number\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        return getNumberIndexString(parsedLengths, fieldValue);\n      };\n    }\n    var ret = {\n      fieldName,\n      schemaPart,\n      parsedLengths,\n      getValue,\n      getIndexStringPart\n    };\n    return ret;\n  });\n  return fieldNameProperties;\n}\n\n/**\n * Crafts an indexable string that can be used\n * to check if a document would be sorted below or above\n * another documents, dependent on the index values.\n * @monad for better performance\n *\n * IMPORTANT: Performance is really important here\n * which is why we code so 'strange'.\n * Always run performance tests when you want to\n * change something in this method.\n */\nexport function getIndexableStringMonad(schema, index) {\n  var fieldNameProperties = getIndexMeta(schema, index);\n  var fieldNamePropertiesAmount = fieldNameProperties.length;\n  var indexPartsFunctions = fieldNameProperties.map(r => r.getIndexStringPart);\n\n  /**\n   * @hotPath Performance of this function is very critical!\n   */\n  var ret = function (docData) {\n    var str = '';\n    for (var i = 0; i < fieldNamePropertiesAmount; ++i) {\n      str += indexPartsFunctions[i](docData);\n    }\n    return str;\n  };\n  return ret;\n}\nexport function getStringLengthOfIndexNumber(schemaPart) {\n  var minimum = Math.floor(schemaPart.minimum);\n  var maximum = Math.ceil(schemaPart.maximum);\n  var multipleOf = schemaPart.multipleOf;\n  var valueSpan = maximum - minimum;\n  var nonDecimals = valueSpan.toString().length;\n  var multipleOfParts = multipleOf.toString().split('.');\n  var decimals = 0;\n  if (multipleOfParts.length > 1) {\n    decimals = multipleOfParts[1].length;\n  }\n  return {\n    minimum,\n    maximum,\n    nonDecimals,\n    decimals,\n    roundedMinimum: minimum\n  };\n}\nexport function getIndexStringLength(schema, index) {\n  var fieldNameProperties = getIndexMeta(schema, index);\n  var length = 0;\n  fieldNameProperties.forEach(props => {\n    var schemaPart = props.schemaPart;\n    var type = schemaPart.type;\n    if (type === 'string') {\n      length += schemaPart.maxLength;\n    } else if (type === 'boolean') {\n      length += 1;\n    } else {\n      var parsedLengths = props.parsedLengths;\n      length = length + parsedLengths.nonDecimals + parsedLengths.decimals;\n    }\n  });\n  return length;\n}\nexport function getPrimaryKeyFromIndexableString(indexableString, primaryKeyLength) {\n  var paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);\n  // we can safely trim here because the primary key is not allowed to start or end with a space char.\n  var primaryKey = paddedPrimaryKey.trim();\n  return primaryKey;\n}\nexport function getNumberIndexString(parsedLengths, fieldValue) {\n  /**\n   * Ensure that the given value is in the boundaries\n   * of the schema, otherwise it would create a broken index string.\n   * This can happen for example if you have a minimum of 0\n   * and run a query like\n   * selector {\n   *  numField: { $gt: -1000 }\n   * }\n   */\n  if (typeof fieldValue === 'undefined') {\n    fieldValue = 0;\n  }\n  if (fieldValue < parsedLengths.minimum) {\n    fieldValue = parsedLengths.minimum;\n  }\n  if (fieldValue > parsedLengths.maximum) {\n    fieldValue = parsedLengths.maximum;\n  }\n  var nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\n  var str = nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\n  if (parsedLengths.decimals > 0) {\n    var splitByDecimalPoint = fieldValue.toString().split('.');\n    var decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : '0';\n    str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\n  }\n  return str;\n}\nexport function getStartIndexStringFromLowerBound(schema, index, lowerBound, inclusiveStart) {\n  var str = '';\n  index.forEach((fieldName, idx) => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    var bound = lowerBound[idx];\n    var type = schemaPart.type;\n    switch (type) {\n      case 'string':\n        var maxLength = ensureNotFalsy(schemaPart.maxLength);\n        if (typeof bound === 'string') {\n          str += bound.padEnd(maxLength, ' ');\n        } else {\n          // str += ''.padStart(maxLength, inclusiveStart ? ' ' : INDEX_MAX);\n          str += ''.padEnd(maxLength, ' ');\n        }\n        break;\n      case 'boolean':\n        if (bound === null) {\n          str += inclusiveStart ? '0' : INDEX_MAX;\n        } else {\n          var boolToStr = bound ? '1' : '0';\n          str += boolToStr;\n        }\n        break;\n      case 'number':\n      case 'integer':\n        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n        if (bound === null || bound === INDEX_MIN) {\n          var fillChar = inclusiveStart ? '0' : INDEX_MAX;\n          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else {\n          str += getNumberIndexString(parsedLengths, bound);\n        }\n        break;\n      default:\n        throw new Error('unknown index type ' + type);\n    }\n  });\n  return str;\n}\nexport function getStartIndexStringFromUpperBound(schema, index, upperBound, inclusiveEnd) {\n  var str = '';\n  index.forEach((fieldName, idx) => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    var bound = upperBound[idx];\n    var type = schemaPart.type;\n    switch (type) {\n      case 'string':\n        var maxLength = ensureNotFalsy(schemaPart.maxLength);\n        if (typeof bound === 'string') {\n          str += bound.padEnd(maxLength, inclusiveEnd ? INDEX_MAX : ' ');\n        } else {\n          str += ''.padEnd(maxLength, inclusiveEnd ? INDEX_MAX : ' ');\n        }\n        break;\n      case 'boolean':\n        if (bound === null) {\n          str += inclusiveEnd ? '0' : '1';\n        } else {\n          var boolToStr = bound ? '1' : '0';\n          str += boolToStr;\n        }\n        break;\n      case 'number':\n      case 'integer':\n        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n        if (bound === null || bound === INDEX_MAX) {\n          var fillChar = inclusiveEnd ? '9' : '0';\n          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else {\n          str += getNumberIndexString(parsedLengths, bound);\n        }\n        break;\n      default:\n        throw new Error('unknown index type ' + type);\n    }\n  });\n  return str;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}