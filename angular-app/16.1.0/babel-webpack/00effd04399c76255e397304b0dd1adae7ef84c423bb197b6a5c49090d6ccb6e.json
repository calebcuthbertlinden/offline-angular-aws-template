{"ast":null,"code":"/**\n * We use 1 as minimum so that the value is never falsy.\n * This const is used in several places because querying\n * with a value lower then the minimum could give false results.\n */\nexport var RX_META_LWT_MINIMUM = 1;\nexport function getDefaultRxDocumentMeta() {\n  return {\n    /**\n     * Set this to 1 to not waste performance\n     * while calling new Date()..\n     * The storage wrappers will anyway update\n     * the lastWrite time while calling transformDocumentDataFromRxDBToRxStorage()\n     */\n    lwt: RX_META_LWT_MINIMUM\n  };\n}\n\n/**\n * Returns a revision that is not valid.\n * Use this to have correct typings\n * while the storage wrapper anyway will overwrite the revision.\n */\nexport function getDefaultRevision() {\n  /**\n   * Use a non-valid revision format,\n   * to ensure that the RxStorage will throw\n   * when the revision is not replaced downstream.\n   */\n  return '';\n}\nexport function stripMetaDataFromDocument(docData) {\n  return Object.assign({}, docData, {\n    _meta: undefined,\n    _deleted: undefined,\n    _rev: undefined\n  });\n}\n\n/**\n * Faster way to check the equality of document lists\n * compared to doing a deep-equal.\n * Here we only check the ids and revisions.\n */\nexport function areRxDocumentArraysEqual(primaryPath, ar1, ar2) {\n  if (ar1.length !== ar2.length) {\n    return false;\n  }\n  var i = 0;\n  var len = ar1.length;\n  while (i < len) {\n    var row1 = ar1[i];\n    var row2 = ar2[i];\n    i++;\n    if (row1._rev !== row2._rev || row1[primaryPath] !== row2[primaryPath]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function getSortDocumentsByLastWriteTimeComparator(primaryPath) {\n  return (a, b) => {\n    if (a._meta.lwt === b._meta.lwt) {\n      if (b[primaryPath] < a[primaryPath]) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else {\n      return a._meta.lwt - b._meta.lwt;\n    }\n  };\n}\nexport function sortDocumentsByLastWriteTime(primaryPath, docs) {\n  return docs.sort(getSortDocumentsByLastWriteTimeComparator(primaryPath));\n}","map":{"version":3,"names":["RX_META_LWT_MINIMUM","getDefaultRxDocumentMeta","lwt","getDefaultRevision","stripMetaDataFromDocument","docData","Object","assign","_meta","undefined","_deleted","_rev","areRxDocumentArraysEqual","primaryPath","ar1","ar2","length","i","len","row1","row2","getSortDocumentsByLastWriteTimeComparator","a","b","sortDocumentsByLastWriteTime","docs","sort"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/plugins/utils/utils-document.js"],"sourcesContent":["/**\n * We use 1 as minimum so that the value is never falsy.\n * This const is used in several places because querying\n * with a value lower then the minimum could give false results.\n */\nexport var RX_META_LWT_MINIMUM = 1;\nexport function getDefaultRxDocumentMeta() {\n  return {\n    /**\n     * Set this to 1 to not waste performance\n     * while calling new Date()..\n     * The storage wrappers will anyway update\n     * the lastWrite time while calling transformDocumentDataFromRxDBToRxStorage()\n     */\n    lwt: RX_META_LWT_MINIMUM\n  };\n}\n\n/**\n * Returns a revision that is not valid.\n * Use this to have correct typings\n * while the storage wrapper anyway will overwrite the revision.\n */\nexport function getDefaultRevision() {\n  /**\n   * Use a non-valid revision format,\n   * to ensure that the RxStorage will throw\n   * when the revision is not replaced downstream.\n   */\n  return '';\n}\nexport function stripMetaDataFromDocument(docData) {\n  return Object.assign({}, docData, {\n    _meta: undefined,\n    _deleted: undefined,\n    _rev: undefined\n  });\n}\n\n/**\n * Faster way to check the equality of document lists\n * compared to doing a deep-equal.\n * Here we only check the ids and revisions.\n */\nexport function areRxDocumentArraysEqual(primaryPath, ar1, ar2) {\n  if (ar1.length !== ar2.length) {\n    return false;\n  }\n  var i = 0;\n  var len = ar1.length;\n  while (i < len) {\n    var row1 = ar1[i];\n    var row2 = ar2[i];\n    i++;\n    if (row1._rev !== row2._rev || row1[primaryPath] !== row2[primaryPath]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function getSortDocumentsByLastWriteTimeComparator(primaryPath) {\n  return (a, b) => {\n    if (a._meta.lwt === b._meta.lwt) {\n      if (b[primaryPath] < a[primaryPath]) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else {\n      return a._meta.lwt - b._meta.lwt;\n    }\n  };\n}\nexport function sortDocumentsByLastWriteTime(primaryPath, docs) {\n  return docs.sort(getSortDocumentsByLastWriteTimeComparator(primaryPath));\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIA,mBAAmB,GAAG,CAAC;AAClC,OAAO,SAASC,wBAAwBA,CAAA,EAAG;EACzC,OAAO;IACL;AACJ;AACA;AACA;AACA;AACA;IACIC,GAAG,EAAEF;EACP,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,kBAAkBA,CAAA,EAAG;EACnC;AACF;AACA;AACA;AACA;EACE,OAAO,EAAE;AACX;AACA,OAAO,SAASC,yBAAyBA,CAACC,OAAO,EAAE;EACjD,OAAOC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEF,OAAO,EAAE;IAChCG,KAAK,EAAEC,SAAS;IAChBC,QAAQ,EAAED,SAAS;IACnBE,IAAI,EAAEF;EACR,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,wBAAwBA,CAACC,WAAW,EAAEC,GAAG,EAAEC,GAAG,EAAE;EAC9D,IAAID,GAAG,CAACE,MAAM,KAAKD,GAAG,CAACC,MAAM,EAAE;IAC7B,OAAO,KAAK;EACd;EACA,IAAIC,CAAC,GAAG,CAAC;EACT,IAAIC,GAAG,GAAGJ,GAAG,CAACE,MAAM;EACpB,OAAOC,CAAC,GAAGC,GAAG,EAAE;IACd,IAAIC,IAAI,GAAGL,GAAG,CAACG,CAAC,CAAC;IACjB,IAAIG,IAAI,GAAGL,GAAG,CAACE,CAAC,CAAC;IACjBA,CAAC,EAAE;IACH,IAAIE,IAAI,CAACR,IAAI,KAAKS,IAAI,CAACT,IAAI,IAAIQ,IAAI,CAACN,WAAW,CAAC,KAAKO,IAAI,CAACP,WAAW,CAAC,EAAE;MACtE,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb;AACA,OAAO,SAASQ,yCAAyCA,CAACR,WAAW,EAAE;EACrE,OAAO,CAACS,CAAC,EAAEC,CAAC,KAAK;IACf,IAAID,CAAC,CAACd,KAAK,CAACN,GAAG,KAAKqB,CAAC,CAACf,KAAK,CAACN,GAAG,EAAE;MAC/B,IAAIqB,CAAC,CAACV,WAAW,CAAC,GAAGS,CAAC,CAACT,WAAW,CAAC,EAAE;QACnC,OAAO,CAAC;MACV,CAAC,MAAM;QACL,OAAO,CAAC,CAAC;MACX;IACF,CAAC,MAAM;MACL,OAAOS,CAAC,CAACd,KAAK,CAACN,GAAG,GAAGqB,CAAC,CAACf,KAAK,CAACN,GAAG;IAClC;EACF,CAAC;AACH;AACA,OAAO,SAASsB,4BAA4BA,CAACX,WAAW,EAAEY,IAAI,EAAE;EAC9D,OAAOA,IAAI,CAACC,IAAI,CAACL,yCAAyC,CAACR,WAAW,CAAC,CAAC;AAC1E"},"metadata":{},"sourceType":"module","externalDependencies":[]}