{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { IdleQueue } from 'custom-idle-queue';\nimport { pluginMissing, flatClone, PROMISE_RESOLVE_FALSE, randomCouchString, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, defaultHashSha256 } from './plugins/utils';\nimport { newRxError } from './rx-error';\nimport { createRxSchema } from './rx-schema';\nimport { runPluginHooks, runAsyncPluginHooks } from './hooks';\nimport { Subject } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\nimport { createRxCollection } from './rx-collection';\nimport { flatCloneDocWithMeta, getSingleDocument, getWrappedStorageInstance, INTERNAL_STORAGE_NAME } from './rx-storage-helper';\nimport { ObliviousSet } from 'oblivious-set';\nimport { ensureStorageTokenDocumentExists, getAllCollectionDocuments, getPrimaryKeyOfInternalDocument, INTERNAL_CONTEXT_COLLECTION, INTERNAL_STORE_SCHEMA, _collectionNamePrimary } from './rx-database-internal-store';\nimport { removeCollectionStorages } from './rx-collection-helper';\nimport { overwritable } from './overwritable';\n\n/**\n * stores the used database names\n * so we can throw when the same database is created more then once.\n */\nvar USED_DATABASE_NAMES = new Set();\nvar DB_COUNT = 0;\nexport var RxDatabaseBase = /*#__PURE__*/function () {\n  /**\n   * Contains all known non-closed storage instances\n   * that belong to this database.\n   * Used in plugins and unit tests.\n   */\n\n  function RxDatabaseBase(name,\n  /**\n   * Uniquely identifies the instance\n   * of this RxDatabase.\n   */\n  token, storage, instanceCreationOptions, password, multiInstance, eventReduce = false, options = {},\n  /**\n   * Stores information documents about the collections of the database\n   */\n  internalStore, hashFunction, cleanupPolicy, allowSlowCount) {\n    this.idleQueue = new IdleQueue();\n    this.storageInstances = new Set();\n    this._subs = [];\n    this.startupErrors = [];\n    this.onDestroy = [];\n    this.destroyed = false;\n    this.collections = {};\n    this.eventBulks$ = new Subject();\n    this.observable$ = this.eventBulks$.pipe(mergeMap(changeEventBulk => changeEventBulk.events));\n    this.storageToken = PROMISE_RESOLVE_FALSE;\n    this.storageTokenDocument = PROMISE_RESOLVE_FALSE;\n    this.emittedEventBulkIds = new ObliviousSet(60 * 1000);\n    this.name = name;\n    this.token = token;\n    this.storage = storage;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.password = password;\n    this.multiInstance = multiInstance;\n    this.eventReduce = eventReduce;\n    this.options = options;\n    this.internalStore = internalStore;\n    this.hashFunction = hashFunction;\n    this.cleanupPolicy = cleanupPolicy;\n    this.allowSlowCount = allowSlowCount;\n    DB_COUNT++;\n\n    /**\n     * In the dev-mode, we create a pseudoInstance\n     * to get all properties of RxDatabase and ensure they do not\n     * conflict with the collection names etc.\n     * So only if it is not pseudoInstance,\n     * we have all values to prepare a real RxDatabase.\n     *\n     * TODO this is ugly, we should use a different way in the dev-mode\n     * so that all non-dev-mode code can be cleaner.\n     */\n    if (this.name !== 'pseudoInstance') {\n      /**\n       * Wrap the internal store\n       * to ensure that calls to it also end up in\n       * calculation of the idle state and the hooks.\n       */\n      this.internalStore = getWrappedStorageInstance(this.asRxDatabase, internalStore, INTERNAL_STORE_SCHEMA);\n\n      /**\n       * Start writing the storage token.\n       * Do not await the creation because it would run\n       * in a critical path that increases startup time.\n       *\n       * Writing the token takes about 20 milliseconds\n       * even on a fast adapter, so this is worth it.\n       */\n      this.storageTokenDocument = ensureStorageTokenDocumentExists(this.asRxDatabase).catch(err => this.startupErrors.push(err));\n      this.storageToken = this.storageTokenDocument.then(doc => doc.data.token).catch(err => this.startupErrors.push(err));\n    }\n  }\n  var _proto = RxDatabaseBase.prototype;\n  /**\n   * This is the main handle-point for all change events\n   * ChangeEvents created by this instance go:\n   * RxDocument -> RxCollection -> RxDatabase.$emit -> MultiInstance\n   * ChangeEvents created by other instances go:\n   * MultiInstance -> RxDatabase.$emit -> RxCollection -> RxDatabase\n   */\n  _proto.$emit = function $emit(changeEventBulk) {\n    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {\n      return;\n    }\n    this.emittedEventBulkIds.add(changeEventBulk.id);\n\n    // emit into own stream\n    this.eventBulks$.next(changeEventBulk);\n  }\n\n  /**\n   * removes the collection-doc from the internalStore\n   */;\n  _proto.removeCollectionDoc = /*#__PURE__*/function () {\n    var _removeCollectionDoc = _asyncToGenerator(function* (name, schema) {\n      var doc = yield getSingleDocument(this.internalStore, getPrimaryKeyOfInternalDocument(_collectionNamePrimary(name, schema), INTERNAL_CONTEXT_COLLECTION));\n      if (!doc) {\n        throw newRxError('SNH', {\n          name,\n          schema\n        });\n      }\n      var writeDoc = flatCloneDocWithMeta(doc);\n      writeDoc._deleted = true;\n      yield this.internalStore.bulkWrite([{\n        document: writeDoc,\n        previous: doc\n      }], 'rx-database-remove-collection');\n    });\n    function removeCollectionDoc(_x, _x2) {\n      return _removeCollectionDoc.apply(this, arguments);\n    }\n    return removeCollectionDoc;\n  }()\n\n  /**\n   * creates multiple RxCollections at once\n   * to be much faster by saving db txs and doing stuff in bulk-operations\n   * This function is not called often, but mostly in the critical path at the initial page load\n   * So it must be as fast as possible.\n   */;\n  _proto.addCollections = /*#__PURE__*/function () {\n    var _addCollections = _asyncToGenerator(function* (collectionCreators) {\n      var _this = this;\n      var jsonSchemas = {};\n      var schemas = {};\n      var bulkPutDocs = [];\n      var useArgsByCollectionName = {};\n      Object.entries(collectionCreators).forEach(([name, args]) => {\n        var collectionName = name;\n        var rxJsonSchema = args.schema;\n        jsonSchemas[collectionName] = rxJsonSchema;\n        var schema = createRxSchema(rxJsonSchema, this.hashFunction);\n        schemas[collectionName] = schema;\n\n        // collection already exists\n        if (this.collections[name]) {\n          throw newRxError('DB3', {\n            name\n          });\n        }\n        var collectionNameWithVersion = _collectionNamePrimary(name, rxJsonSchema);\n        var collectionDocData = {\n          id: getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION),\n          key: collectionNameWithVersion,\n          context: INTERNAL_CONTEXT_COLLECTION,\n          data: {\n            name: collectionName,\n            schemaHash: schema.hash,\n            schema: schema.jsonSchema,\n            version: schema.version,\n            connectedStorages: []\n          },\n          _deleted: false,\n          _meta: getDefaultRxDocumentMeta(),\n          _rev: getDefaultRevision(),\n          _attachments: {}\n        };\n        bulkPutDocs.push({\n          document: collectionDocData\n        });\n        var useArgs = Object.assign({}, args, {\n          name: collectionName,\n          schema,\n          database: this\n        });\n\n        // run hooks\n        var hookData = flatClone(args);\n        hookData.database = this;\n        hookData.name = name;\n        runPluginHooks('preCreateRxCollection', hookData);\n        useArgs.conflictHandler = hookData.conflictHandler;\n        useArgsByCollectionName[collectionName] = useArgs;\n      });\n      var putDocsResult = yield this.internalStore.bulkWrite(bulkPutDocs, 'rx-database-add-collection');\n      yield ensureNoStartupErrors(this);\n      Object.entries(putDocsResult.error).forEach(([_id, error]) => {\n        if (error.status !== 409) {\n          throw newRxError('DB12', {\n            database: this.name,\n            writeError: error\n          });\n        }\n        var docInDb = ensureNotFalsy(error.documentInDb);\n        var collectionName = docInDb.data.name;\n        var schema = schemas[collectionName];\n        // collection already exists but has different schema\n        if (docInDb.data.schemaHash !== schema.hash) {\n          throw newRxError('DB6', {\n            database: this.name,\n            collection: collectionName,\n            previousSchemaHash: docInDb.data.schemaHash,\n            schemaHash: schema.hash,\n            previousSchema: docInDb.data.schema,\n            schema: ensureNotFalsy(jsonSchemas[collectionName])\n          });\n        }\n      });\n      var ret = {};\n      yield Promise.all(Object.keys(collectionCreators).map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (collectionName) {\n          var useArgs = useArgsByCollectionName[collectionName];\n          var collection = yield createRxCollection(useArgs);\n          ret[collectionName] = collection;\n\n          // set as getter to the database\n          _this.collections[collectionName] = collection;\n          if (!_this[collectionName]) {\n            Object.defineProperty(_this, collectionName, {\n              get: () => _this.collections[collectionName]\n            });\n          }\n        });\n        return function (_x4) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      return ret;\n    });\n    function addCollections(_x3) {\n      return _addCollections.apply(this, arguments);\n    }\n    return addCollections;\n  }()\n\n  /**\n   * runs the given function between idleQueue-locking\n   */;\n  _proto.lockedRun = function lockedRun(fn) {\n    return this.idleQueue.wrapCall(fn);\n  };\n  _proto.requestIdlePromise = function requestIdlePromise() {\n    return this.idleQueue.requestIdlePromise();\n  }\n\n  /**\n   * Export database to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON(_collections) {\n    throw pluginMissing('json-dump');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<db>.exportJSON()` method.\n   * @note When an interface is loaded in this collection all base properties of the type are typed as `any`\n   * since data could be encrypted.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.backup = function backup(_options) {\n    throw pluginMissing('backup');\n  };\n  _proto.leaderElector = function leaderElector() {\n    throw pluginMissing('leader-election');\n  };\n  _proto.isLeader = function isLeader() {\n    throw pluginMissing('leader-election');\n  }\n  /**\n   * returns a promise which resolves when the instance becomes leader\n   */;\n  _proto.waitForLeadership = function waitForLeadership() {\n    throw pluginMissing('leader-election');\n  };\n  _proto.migrationStates = function migrationStates() {\n    throw pluginMissing('migration');\n  }\n\n  /**\n   * destroys the database-instance and all collections\n   */;\n  _proto.destroy = /*#__PURE__*/function () {\n    var _destroy = _asyncToGenerator(function* () {\n      if (this.destroyed) {\n        return PROMISE_RESOLVE_FALSE;\n      }\n\n      // settings destroyed = true must be the first thing to do.\n      this.destroyed = true;\n      yield runAsyncPluginHooks('preDestroyRxDatabase', this);\n      /**\n       * Complete the event stream\n       * to stop all subscribers who forgot to unsubscribe.\n       */\n      this.eventBulks$.complete();\n      DB_COUNT--;\n      this._subs.map(sub => sub.unsubscribe());\n\n      /**\n       * Destroying the pseudo instance will throw\n       * because stuff is missing\n       * TODO we should not need the pseudo instance on runtime.\n       * we should generate the property list on build time.\n       */\n      if (this.name === 'pseudoInstance') {\n        return PROMISE_RESOLVE_FALSE;\n      }\n\n      /**\n       * First wait until the database is idle\n       */\n      return this.requestIdlePromise().then(() => Promise.all(this.onDestroy.map(fn => fn())))\n      // destroy all collections\n      .then(() => Promise.all(Object.keys(this.collections).map(key => this.collections[key]).map(col => col.destroy())))\n      // destroy internal storage instances\n      .then(() => this.internalStore.close())\n      // remove combination from USED_COMBINATIONS-map\n      .then(() => USED_DATABASE_NAMES.delete(this.name)).then(() => true);\n    });\n    function destroy() {\n      return _destroy.apply(this, arguments);\n    }\n    return destroy;\n  }()\n\n  /**\n   * deletes the database and its stored data.\n   * Returns the names of all removed collections.\n   */;\n  _proto.remove = function remove() {\n    return this.destroy().then(() => removeRxDatabase(this.name, this.storage));\n  };\n  _createClass(RxDatabaseBase, [{\n    key: \"$\",\n    get: function () {\n      return this.observable$;\n    }\n\n    /**\n     * Because having unhandled exceptions would fail,\n     * we have to store the async errors of the constructor here\n     * so we can throw them later.\n     */\n\n    /**\n     * When the database is destroyed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n     */\n\n    /**\n     * Unique token that is stored with the data.\n     * Used to detect if the dataset has been deleted\n     * and if two RxDatabase instances work on the same dataset or not.\n     *\n     * Because reading and writing the storageToken runs in the hot path\n     * of database creation, we do not await the storageWrites but instead\n     * work with the promise when we need the value.\n     */\n\n    /**\n     * Stores the whole state of the internal storage token document.\n     * We need this in some plugins.\n     */\n\n    /**\n     * Contains the ids of all event bulks that have been emitted\n     * by the database.\n     * Used to detect duplicates that come in again via BroadcastChannel\n     * or other streams.\n     * TODO instead of having this here, we should add a test to ensure each RxStorage\n     * behaves equal and does never emit duplicate eventBulks.\n     */\n  }, {\n    key: \"asRxDatabase\",\n    get: function () {\n      return this;\n    }\n  }]);\n  return RxDatabaseBase;\n}();\n\n/**\n * checks if an instance with same name and adapter already exists\n * @throws {RxError} if used\n */\nfunction throwIfDatabaseNameUsed(name) {\n  if (!USED_DATABASE_NAMES.has(name)) {\n    return;\n  } else {\n    throw newRxError('DB8', {\n      name,\n      link: 'https://pubkey.github.io/rxdb/rx-database.html#ignoreduplicate'\n    });\n  }\n}\n\n/**\n * Creates the storage instances that are used internally in the database\n * to store schemas and other configuration stuff.\n */\nexport function createRxDatabaseStorageInstance(_x5, _x6, _x7, _x8, _x9, _x10) {\n  return _createRxDatabaseStorageInstance.apply(this, arguments);\n}\nfunction _createRxDatabaseStorageInstance() {\n  _createRxDatabaseStorageInstance = _asyncToGenerator(function* (databaseInstanceToken, storage, databaseName, options, multiInstance, password) {\n    var internalStore = yield storage.createStorageInstance({\n      databaseInstanceToken,\n      databaseName,\n      collectionName: INTERNAL_STORAGE_NAME,\n      schema: INTERNAL_STORE_SCHEMA,\n      options,\n      multiInstance,\n      password,\n      devMode: overwritable.isDevMode()\n    });\n    return internalStore;\n  });\n  return _createRxDatabaseStorageInstance.apply(this, arguments);\n}\nexport function createRxDatabase({\n  storage,\n  instanceCreationOptions,\n  name,\n  password,\n  multiInstance = true,\n  eventReduce = false,\n  ignoreDuplicate = false,\n  options = {},\n  cleanupPolicy,\n  allowSlowCount = false,\n  localDocuments = false,\n  hashFunction = defaultHashSha256\n}) {\n  runPluginHooks('preCreateRxDatabase', {\n    storage,\n    instanceCreationOptions,\n    name,\n    password,\n    multiInstance,\n    eventReduce,\n    ignoreDuplicate,\n    options,\n    localDocuments\n  });\n  // check if combination already used\n  if (!ignoreDuplicate) {\n    throwIfDatabaseNameUsed(name);\n  }\n  USED_DATABASE_NAMES.add(name);\n  var databaseInstanceToken = randomCouchString(10);\n  return createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password)\n  /**\n   * Creating the internal store might fail\n   * if some RxStorage wrapper is used that does some checks\n   * and then throw.\n   * In that case we have to properly clean up the database.\n   */.catch(err => {\n    USED_DATABASE_NAMES.delete(name);\n    throw err;\n  }).then(storageInstance => {\n    var rxDatabase = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce, options, storageInstance, hashFunction, cleanupPolicy, allowSlowCount);\n    return runAsyncPluginHooks('createRxDatabase', {\n      database: rxDatabase,\n      creator: {\n        storage,\n        instanceCreationOptions,\n        name,\n        password,\n        multiInstance,\n        eventReduce,\n        ignoreDuplicate,\n        options,\n        localDocuments\n      }\n    }).then(() => rxDatabase);\n  });\n}\n\n/**\n * Removes the database and all its known data\n * with all known collections and all internal meta data.\n *\n * Returns the names of the removed collections.\n */\nexport function removeRxDatabase(_x11, _x12) {\n  return _removeRxDatabase.apply(this, arguments);\n}\nfunction _removeRxDatabase() {\n  _removeRxDatabase = _asyncToGenerator(function* (databaseName, storage) {\n    var databaseInstanceToken = randomCouchString(10);\n    var dbInternalsStorageInstance = yield createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, false);\n    var collectionDocs = yield getAllCollectionDocuments(storage.statics, dbInternalsStorageInstance);\n    var collectionNames = new Set();\n    collectionDocs.forEach(doc => collectionNames.add(doc.data.name));\n    var removedCollectionNames = Array.from(collectionNames);\n    yield Promise.all(removedCollectionNames.map(collectionName => removeCollectionStorages(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName)));\n    yield runAsyncPluginHooks('postRemoveRxDatabase', {\n      databaseName,\n      storage\n    });\n    yield dbInternalsStorageInstance.remove();\n    return removedCollectionNames;\n  });\n  return _removeRxDatabase.apply(this, arguments);\n}\nexport function isRxDatabase(obj) {\n  return obj instanceof RxDatabaseBase;\n}\nexport function dbCount() {\n  return DB_COUNT;\n}\n\n/**\n * Returns true if the given RxDatabase was the first\n * instance that was created on the storage with this name.\n *\n * Can be used for some optimizations because on the first instantiation,\n * we can assume that no data was written before.\n */\nexport function isRxDatabaseFirstTimeInstantiated(_x13) {\n  return _isRxDatabaseFirstTimeInstantiated.apply(this, arguments);\n}\n\n/**\n * For better performance some tasks run async\n * and are awaited later.\n * But we still have to ensure that there have been no errors\n * on database creation.\n */\nfunction _isRxDatabaseFirstTimeInstantiated() {\n  _isRxDatabaseFirstTimeInstantiated = _asyncToGenerator(function* (database) {\n    var tokenDoc = yield database.storageTokenDocument;\n    return tokenDoc.data.instanceToken === database.token;\n  });\n  return _isRxDatabaseFirstTimeInstantiated.apply(this, arguments);\n}\nexport function ensureNoStartupErrors(_x14) {\n  return _ensureNoStartupErrors.apply(this, arguments);\n}\nfunction _ensureNoStartupErrors() {\n  _ensureNoStartupErrors = _asyncToGenerator(function* (rxDatabase) {\n    yield rxDatabase.storageToken;\n    if (rxDatabase.startupErrors[0]) {\n      throw rxDatabase.startupErrors[0];\n    }\n  });\n  return _ensureNoStartupErrors.apply(this, arguments);\n}","map":{"version":3,"names":["_createClass","IdleQueue","pluginMissing","flatClone","PROMISE_RESOLVE_FALSE","randomCouchString","ensureNotFalsy","getDefaultRevision","getDefaultRxDocumentMeta","defaultHashSha256","newRxError","createRxSchema","runPluginHooks","runAsyncPluginHooks","Subject","mergeMap","createRxCollection","flatCloneDocWithMeta","getSingleDocument","getWrappedStorageInstance","INTERNAL_STORAGE_NAME","ObliviousSet","ensureStorageTokenDocumentExists","getAllCollectionDocuments","getPrimaryKeyOfInternalDocument","INTERNAL_CONTEXT_COLLECTION","INTERNAL_STORE_SCHEMA","_collectionNamePrimary","removeCollectionStorages","overwritable","USED_DATABASE_NAMES","Set","DB_COUNT","RxDatabaseBase","name","token","storage","instanceCreationOptions","password","multiInstance","eventReduce","options","internalStore","hashFunction","cleanupPolicy","allowSlowCount","idleQueue","storageInstances","_subs","startupErrors","onDestroy","destroyed","collections","eventBulks$","observable$","pipe","changeEventBulk","events","storageToken","storageTokenDocument","emittedEventBulkIds","asRxDatabase","catch","err","push","then","doc","data","_proto","prototype","$emit","has","id","add","next","removeCollectionDoc","_removeCollectionDoc","_asyncToGenerator","schema","writeDoc","_deleted","bulkWrite","document","previous","_x","_x2","apply","arguments","addCollections","_addCollections","collectionCreators","_this","jsonSchemas","schemas","bulkPutDocs","useArgsByCollectionName","Object","entries","forEach","args","collectionName","rxJsonSchema","collectionNameWithVersion","collectionDocData","key","context","schemaHash","hash","jsonSchema","version","connectedStorages","_meta","_rev","_attachments","useArgs","assign","database","hookData","conflictHandler","putDocsResult","ensureNoStartupErrors","error","_id","status","writeError","docInDb","documentInDb","collection","previousSchemaHash","previousSchema","ret","Promise","all","keys","map","_ref","defineProperty","get","_x4","_x3","lockedRun","fn","wrapCall","requestIdlePromise","exportJSON","_collections","importJSON","_exportedJSON","backup","_options","leaderElector","isLeader","waitForLeadership","migrationStates","destroy","_destroy","complete","sub","unsubscribe","col","close","delete","remove","removeRxDatabase","throwIfDatabaseNameUsed","link","createRxDatabaseStorageInstance","_x5","_x6","_x7","_x8","_x9","_x10","_createRxDatabaseStorageInstance","databaseInstanceToken","databaseName","createStorageInstance","devMode","isDevMode","createRxDatabase","ignoreDuplicate","localDocuments","storageInstance","rxDatabase","creator","_x11","_x12","_removeRxDatabase","dbInternalsStorageInstance","collectionDocs","statics","collectionNames","removedCollectionNames","Array","from","isRxDatabase","obj","dbCount","isRxDatabaseFirstTimeInstantiated","_x13","_isRxDatabaseFirstTimeInstantiated","tokenDoc","instanceToken","_x14","_ensureNoStartupErrors"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/rx-database.js"],"sourcesContent":["import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { IdleQueue } from 'custom-idle-queue';\nimport { pluginMissing, flatClone, PROMISE_RESOLVE_FALSE, randomCouchString, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, defaultHashSha256 } from './plugins/utils';\nimport { newRxError } from './rx-error';\nimport { createRxSchema } from './rx-schema';\nimport { runPluginHooks, runAsyncPluginHooks } from './hooks';\nimport { Subject } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\nimport { createRxCollection } from './rx-collection';\nimport { flatCloneDocWithMeta, getSingleDocument, getWrappedStorageInstance, INTERNAL_STORAGE_NAME } from './rx-storage-helper';\nimport { ObliviousSet } from 'oblivious-set';\nimport { ensureStorageTokenDocumentExists, getAllCollectionDocuments, getPrimaryKeyOfInternalDocument, INTERNAL_CONTEXT_COLLECTION, INTERNAL_STORE_SCHEMA, _collectionNamePrimary } from './rx-database-internal-store';\nimport { removeCollectionStorages } from './rx-collection-helper';\nimport { overwritable } from './overwritable';\n\n/**\n * stores the used database names\n * so we can throw when the same database is created more then once.\n */\nvar USED_DATABASE_NAMES = new Set();\nvar DB_COUNT = 0;\nexport var RxDatabaseBase = /*#__PURE__*/function () {\n  /**\n   * Contains all known non-closed storage instances\n   * that belong to this database.\n   * Used in plugins and unit tests.\n   */\n\n  function RxDatabaseBase(name,\n  /**\n   * Uniquely identifies the instance\n   * of this RxDatabase.\n   */\n  token, storage, instanceCreationOptions, password, multiInstance, eventReduce = false, options = {},\n  /**\n   * Stores information documents about the collections of the database\n   */\n  internalStore, hashFunction, cleanupPolicy, allowSlowCount) {\n    this.idleQueue = new IdleQueue();\n    this.storageInstances = new Set();\n    this._subs = [];\n    this.startupErrors = [];\n    this.onDestroy = [];\n    this.destroyed = false;\n    this.collections = {};\n    this.eventBulks$ = new Subject();\n    this.observable$ = this.eventBulks$.pipe(mergeMap(changeEventBulk => changeEventBulk.events));\n    this.storageToken = PROMISE_RESOLVE_FALSE;\n    this.storageTokenDocument = PROMISE_RESOLVE_FALSE;\n    this.emittedEventBulkIds = new ObliviousSet(60 * 1000);\n    this.name = name;\n    this.token = token;\n    this.storage = storage;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.password = password;\n    this.multiInstance = multiInstance;\n    this.eventReduce = eventReduce;\n    this.options = options;\n    this.internalStore = internalStore;\n    this.hashFunction = hashFunction;\n    this.cleanupPolicy = cleanupPolicy;\n    this.allowSlowCount = allowSlowCount;\n    DB_COUNT++;\n\n    /**\n     * In the dev-mode, we create a pseudoInstance\n     * to get all properties of RxDatabase and ensure they do not\n     * conflict with the collection names etc.\n     * So only if it is not pseudoInstance,\n     * we have all values to prepare a real RxDatabase.\n     *\n     * TODO this is ugly, we should use a different way in the dev-mode\n     * so that all non-dev-mode code can be cleaner.\n     */\n    if (this.name !== 'pseudoInstance') {\n      /**\n       * Wrap the internal store\n       * to ensure that calls to it also end up in\n       * calculation of the idle state and the hooks.\n       */\n      this.internalStore = getWrappedStorageInstance(this.asRxDatabase, internalStore, INTERNAL_STORE_SCHEMA);\n\n      /**\n       * Start writing the storage token.\n       * Do not await the creation because it would run\n       * in a critical path that increases startup time.\n       *\n       * Writing the token takes about 20 milliseconds\n       * even on a fast adapter, so this is worth it.\n       */\n      this.storageTokenDocument = ensureStorageTokenDocumentExists(this.asRxDatabase).catch(err => this.startupErrors.push(err));\n      this.storageToken = this.storageTokenDocument.then(doc => doc.data.token).catch(err => this.startupErrors.push(err));\n    }\n  }\n  var _proto = RxDatabaseBase.prototype;\n  /**\n   * This is the main handle-point for all change events\n   * ChangeEvents created by this instance go:\n   * RxDocument -> RxCollection -> RxDatabase.$emit -> MultiInstance\n   * ChangeEvents created by other instances go:\n   * MultiInstance -> RxDatabase.$emit -> RxCollection -> RxDatabase\n   */\n  _proto.$emit = function $emit(changeEventBulk) {\n    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {\n      return;\n    }\n    this.emittedEventBulkIds.add(changeEventBulk.id);\n\n    // emit into own stream\n    this.eventBulks$.next(changeEventBulk);\n  }\n\n  /**\n   * removes the collection-doc from the internalStore\n   */;\n  _proto.removeCollectionDoc = async function removeCollectionDoc(name, schema) {\n    var doc = await getSingleDocument(this.internalStore, getPrimaryKeyOfInternalDocument(_collectionNamePrimary(name, schema), INTERNAL_CONTEXT_COLLECTION));\n    if (!doc) {\n      throw newRxError('SNH', {\n        name,\n        schema\n      });\n    }\n    var writeDoc = flatCloneDocWithMeta(doc);\n    writeDoc._deleted = true;\n    await this.internalStore.bulkWrite([{\n      document: writeDoc,\n      previous: doc\n    }], 'rx-database-remove-collection');\n  }\n\n  /**\n   * creates multiple RxCollections at once\n   * to be much faster by saving db txs and doing stuff in bulk-operations\n   * This function is not called often, but mostly in the critical path at the initial page load\n   * So it must be as fast as possible.\n   */;\n  _proto.addCollections = async function addCollections(collectionCreators) {\n    var jsonSchemas = {};\n    var schemas = {};\n    var bulkPutDocs = [];\n    var useArgsByCollectionName = {};\n    Object.entries(collectionCreators).forEach(([name, args]) => {\n      var collectionName = name;\n      var rxJsonSchema = args.schema;\n      jsonSchemas[collectionName] = rxJsonSchema;\n      var schema = createRxSchema(rxJsonSchema, this.hashFunction);\n      schemas[collectionName] = schema;\n\n      // collection already exists\n      if (this.collections[name]) {\n        throw newRxError('DB3', {\n          name\n        });\n      }\n      var collectionNameWithVersion = _collectionNamePrimary(name, rxJsonSchema);\n      var collectionDocData = {\n        id: getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION),\n        key: collectionNameWithVersion,\n        context: INTERNAL_CONTEXT_COLLECTION,\n        data: {\n          name: collectionName,\n          schemaHash: schema.hash,\n          schema: schema.jsonSchema,\n          version: schema.version,\n          connectedStorages: []\n        },\n        _deleted: false,\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision(),\n        _attachments: {}\n      };\n      bulkPutDocs.push({\n        document: collectionDocData\n      });\n      var useArgs = Object.assign({}, args, {\n        name: collectionName,\n        schema,\n        database: this\n      });\n\n      // run hooks\n      var hookData = flatClone(args);\n      hookData.database = this;\n      hookData.name = name;\n      runPluginHooks('preCreateRxCollection', hookData);\n      useArgs.conflictHandler = hookData.conflictHandler;\n      useArgsByCollectionName[collectionName] = useArgs;\n    });\n    var putDocsResult = await this.internalStore.bulkWrite(bulkPutDocs, 'rx-database-add-collection');\n    await ensureNoStartupErrors(this);\n    Object.entries(putDocsResult.error).forEach(([_id, error]) => {\n      if (error.status !== 409) {\n        throw newRxError('DB12', {\n          database: this.name,\n          writeError: error\n        });\n      }\n      var docInDb = ensureNotFalsy(error.documentInDb);\n      var collectionName = docInDb.data.name;\n      var schema = schemas[collectionName];\n      // collection already exists but has different schema\n      if (docInDb.data.schemaHash !== schema.hash) {\n        throw newRxError('DB6', {\n          database: this.name,\n          collection: collectionName,\n          previousSchemaHash: docInDb.data.schemaHash,\n          schemaHash: schema.hash,\n          previousSchema: docInDb.data.schema,\n          schema: ensureNotFalsy(jsonSchemas[collectionName])\n        });\n      }\n    });\n    var ret = {};\n    await Promise.all(Object.keys(collectionCreators).map(async collectionName => {\n      var useArgs = useArgsByCollectionName[collectionName];\n      var collection = await createRxCollection(useArgs);\n      ret[collectionName] = collection;\n\n      // set as getter to the database\n      this.collections[collectionName] = collection;\n      if (!this[collectionName]) {\n        Object.defineProperty(this, collectionName, {\n          get: () => this.collections[collectionName]\n        });\n      }\n    }));\n    return ret;\n  }\n\n  /**\n   * runs the given function between idleQueue-locking\n   */;\n  _proto.lockedRun = function lockedRun(fn) {\n    return this.idleQueue.wrapCall(fn);\n  };\n  _proto.requestIdlePromise = function requestIdlePromise() {\n    return this.idleQueue.requestIdlePromise();\n  }\n\n  /**\n   * Export database to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON(_collections) {\n    throw pluginMissing('json-dump');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<db>.exportJSON()` method.\n   * @note When an interface is loaded in this collection all base properties of the type are typed as `any`\n   * since data could be encrypted.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.backup = function backup(_options) {\n    throw pluginMissing('backup');\n  };\n  _proto.leaderElector = function leaderElector() {\n    throw pluginMissing('leader-election');\n  };\n  _proto.isLeader = function isLeader() {\n    throw pluginMissing('leader-election');\n  }\n  /**\n   * returns a promise which resolves when the instance becomes leader\n   */;\n  _proto.waitForLeadership = function waitForLeadership() {\n    throw pluginMissing('leader-election');\n  };\n  _proto.migrationStates = function migrationStates() {\n    throw pluginMissing('migration');\n  }\n\n  /**\n   * destroys the database-instance and all collections\n   */;\n  _proto.destroy = async function destroy() {\n    if (this.destroyed) {\n      return PROMISE_RESOLVE_FALSE;\n    }\n\n    // settings destroyed = true must be the first thing to do.\n    this.destroyed = true;\n    await runAsyncPluginHooks('preDestroyRxDatabase', this);\n    /**\n     * Complete the event stream\n     * to stop all subscribers who forgot to unsubscribe.\n     */\n    this.eventBulks$.complete();\n    DB_COUNT--;\n    this._subs.map(sub => sub.unsubscribe());\n\n    /**\n     * Destroying the pseudo instance will throw\n     * because stuff is missing\n     * TODO we should not need the pseudo instance on runtime.\n     * we should generate the property list on build time.\n     */\n    if (this.name === 'pseudoInstance') {\n      return PROMISE_RESOLVE_FALSE;\n    }\n\n    /**\n     * First wait until the database is idle\n     */\n    return this.requestIdlePromise().then(() => Promise.all(this.onDestroy.map(fn => fn())))\n    // destroy all collections\n    .then(() => Promise.all(Object.keys(this.collections).map(key => this.collections[key]).map(col => col.destroy())))\n    // destroy internal storage instances\n    .then(() => this.internalStore.close())\n    // remove combination from USED_COMBINATIONS-map\n    .then(() => USED_DATABASE_NAMES.delete(this.name)).then(() => true);\n  }\n\n  /**\n   * deletes the database and its stored data.\n   * Returns the names of all removed collections.\n   */;\n  _proto.remove = function remove() {\n    return this.destroy().then(() => removeRxDatabase(this.name, this.storage));\n  };\n  _createClass(RxDatabaseBase, [{\n    key: \"$\",\n    get: function () {\n      return this.observable$;\n    }\n\n    /**\n     * Because having unhandled exceptions would fail,\n     * we have to store the async errors of the constructor here\n     * so we can throw them later.\n     */\n\n    /**\n     * When the database is destroyed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n     */\n\n    /**\n     * Unique token that is stored with the data.\n     * Used to detect if the dataset has been deleted\n     * and if two RxDatabase instances work on the same dataset or not.\n     *\n     * Because reading and writing the storageToken runs in the hot path\n     * of database creation, we do not await the storageWrites but instead\n     * work with the promise when we need the value.\n     */\n\n    /**\n     * Stores the whole state of the internal storage token document.\n     * We need this in some plugins.\n     */\n\n    /**\n     * Contains the ids of all event bulks that have been emitted\n     * by the database.\n     * Used to detect duplicates that come in again via BroadcastChannel\n     * or other streams.\n     * TODO instead of having this here, we should add a test to ensure each RxStorage\n     * behaves equal and does never emit duplicate eventBulks.\n     */\n  }, {\n    key: \"asRxDatabase\",\n    get: function () {\n      return this;\n    }\n  }]);\n  return RxDatabaseBase;\n}();\n\n/**\n * checks if an instance with same name and adapter already exists\n * @throws {RxError} if used\n */\nfunction throwIfDatabaseNameUsed(name) {\n  if (!USED_DATABASE_NAMES.has(name)) {\n    return;\n  } else {\n    throw newRxError('DB8', {\n      name,\n      link: 'https://pubkey.github.io/rxdb/rx-database.html#ignoreduplicate'\n    });\n  }\n}\n\n/**\n * Creates the storage instances that are used internally in the database\n * to store schemas and other configuration stuff.\n */\nexport async function createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, options, multiInstance, password) {\n  var internalStore = await storage.createStorageInstance({\n    databaseInstanceToken,\n    databaseName,\n    collectionName: INTERNAL_STORAGE_NAME,\n    schema: INTERNAL_STORE_SCHEMA,\n    options,\n    multiInstance,\n    password,\n    devMode: overwritable.isDevMode()\n  });\n  return internalStore;\n}\nexport function createRxDatabase({\n  storage,\n  instanceCreationOptions,\n  name,\n  password,\n  multiInstance = true,\n  eventReduce = false,\n  ignoreDuplicate = false,\n  options = {},\n  cleanupPolicy,\n  allowSlowCount = false,\n  localDocuments = false,\n  hashFunction = defaultHashSha256\n}) {\n  runPluginHooks('preCreateRxDatabase', {\n    storage,\n    instanceCreationOptions,\n    name,\n    password,\n    multiInstance,\n    eventReduce,\n    ignoreDuplicate,\n    options,\n    localDocuments\n  });\n  // check if combination already used\n  if (!ignoreDuplicate) {\n    throwIfDatabaseNameUsed(name);\n  }\n  USED_DATABASE_NAMES.add(name);\n  var databaseInstanceToken = randomCouchString(10);\n  return createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password)\n  /**\n   * Creating the internal store might fail\n   * if some RxStorage wrapper is used that does some checks\n   * and then throw.\n   * In that case we have to properly clean up the database.\n   */.catch(err => {\n    USED_DATABASE_NAMES.delete(name);\n    throw err;\n  }).then(storageInstance => {\n    var rxDatabase = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce, options, storageInstance, hashFunction, cleanupPolicy, allowSlowCount);\n    return runAsyncPluginHooks('createRxDatabase', {\n      database: rxDatabase,\n      creator: {\n        storage,\n        instanceCreationOptions,\n        name,\n        password,\n        multiInstance,\n        eventReduce,\n        ignoreDuplicate,\n        options,\n        localDocuments\n      }\n    }).then(() => rxDatabase);\n  });\n}\n\n/**\n * Removes the database and all its known data\n * with all known collections and all internal meta data.\n *\n * Returns the names of the removed collections.\n */\nexport async function removeRxDatabase(databaseName, storage) {\n  var databaseInstanceToken = randomCouchString(10);\n  var dbInternalsStorageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, false);\n  var collectionDocs = await getAllCollectionDocuments(storage.statics, dbInternalsStorageInstance);\n  var collectionNames = new Set();\n  collectionDocs.forEach(doc => collectionNames.add(doc.data.name));\n  var removedCollectionNames = Array.from(collectionNames);\n  await Promise.all(removedCollectionNames.map(collectionName => removeCollectionStorages(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName)));\n  await runAsyncPluginHooks('postRemoveRxDatabase', {\n    databaseName,\n    storage\n  });\n  await dbInternalsStorageInstance.remove();\n  return removedCollectionNames;\n}\nexport function isRxDatabase(obj) {\n  return obj instanceof RxDatabaseBase;\n}\nexport function dbCount() {\n  return DB_COUNT;\n}\n\n/**\n * Returns true if the given RxDatabase was the first\n * instance that was created on the storage with this name.\n *\n * Can be used for some optimizations because on the first instantiation,\n * we can assume that no data was written before.\n */\nexport async function isRxDatabaseFirstTimeInstantiated(database) {\n  var tokenDoc = await database.storageTokenDocument;\n  return tokenDoc.data.instanceToken === database.token;\n}\n\n/**\n * For better performance some tasks run async\n * and are awaited later.\n * But we still have to ensure that there have been no errors\n * on database creation.\n */\nexport async function ensureNoStartupErrors(rxDatabase) {\n  await rxDatabase.storageToken;\n  if (rxDatabase.startupErrors[0]) {\n    throw rxDatabase.startupErrors[0];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}