{"ast":null,"code":"import _defineProperty from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { assert, has, into, isNil, isObject, isObjectLike, isOperator, isString, resolve } from \"./util\";\n/**\n * This controls how input and output documents are processed to meet different application needs.\n * Each mode has different trade offs for; immutability, reference sharing, and performance.\n */\nexport var ProcessingMode;\n(function (ProcessingMode) {\n  /**\n   * Clone inputs prior to processing, and the outputs if some objects graphs may be shared.\n   * Use this option to keep input collection immutable and to get distinct output objects.\n   *\n   * Note: This option is expensive and reduces performance.\n   */\n  ProcessingMode[\"CLONE_ALL\"] = \"CLONE_ALL\";\n  /**\n   * Clones inputs prior to processing.\n   * This option will return output objects with shared graphs in their path if specific operators are used.\n   * Use this option to keep the input collection immutable.\n   *\n   */\n  ProcessingMode[\"CLONE_INPUT\"] = \"CLONE_INPUT\";\n  /**\n   * Clones the output to return distinct objects with no shared paths.\n   * This option modifies the input collection and during processing.\n   */\n  ProcessingMode[\"CLONE_OUTPUT\"] = \"CLONE_OUTPUT\";\n  /**\n   * Turn off cloning and modifies the input collection as needed.\n   * This option will also return output objects with shared paths in their graph when specific operators are used.\n   * This option provides the greatest speedup for the biggest tradeoff.\n   * When using the aggregation pipeline, you can use the \"$out\" operator to collect immutable intermediate results.\n   *\n   * @default\n   */\n  ProcessingMode[\"CLONE_OFF\"] = \"CLONE_OFF\";\n})(ProcessingMode || (ProcessingMode = {}));\n/** Custom type to facilitate type checking for global options */\nexport class ComputeOptions {\n  constructor(options, /** Reference to the root object when processing subgraphs of the object. */\n  _root, _local, /** The current time in milliseconds. Remains the same throughout all stages of the aggregation pipeline. */\n  timestamp = Date.now()) {\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"_root\", void 0);\n    _defineProperty(this, \"_local\", void 0);\n    _defineProperty(this, \"timestamp\", void 0);\n    this.options = options;\n    this._root = _root;\n    this._local = _local;\n    this.timestamp = timestamp;\n    this.options = options;\n    this.update(_root, _local);\n  }\n  /**\n   * Initialize new ComputeOptions. Returns the same object modified when the 'options' argument is a ComputeOptions.\n   * @param options\n   * @param root\n   * @param local\n   * @returns\n   */\n  static init(options, root, local) {\n    return options instanceof ComputeOptions ? options.update(\n    // value can be '0' or 'false'\n    isNil(options.root) ? root : options.root, Object.assign({}, options.local, local)) : new ComputeOptions(options || initOptions(), root, local);\n  }\n  /** Updates the internal mutable state. */\n  update(root, local) {\n    // NOTE: this is done for efficiency to avoid creating too many intermediate options objects.\n    this._root = root;\n    this._local = local ? Object.assign({}, local, {\n      variables: Object.assign({}, this._local?.variables, local?.variables)\n    }) : local;\n    return this;\n  }\n  get root() {\n    return this._root;\n  }\n  get local() {\n    return this._local;\n  }\n  get idKey() {\n    return this.options?.idKey;\n  }\n  get collation() {\n    return this.options?.collation;\n  }\n  get processingMode() {\n    return this.options?.processingMode || ProcessingMode.CLONE_OFF;\n  }\n  get useStrictMode() {\n    return this.options?.useStrictMode;\n  }\n  get scriptEnabled() {\n    return this.options?.scriptEnabled;\n  }\n  get hashFunction() {\n    return this.options?.hashFunction;\n  }\n  get collectionResolver() {\n    return this.options?.collectionResolver;\n  }\n  get jsonSchemaValidator() {\n    return this.options?.jsonSchemaValidator;\n  }\n  get variables() {\n    return this.options?.variables;\n  }\n}\n/**\n * Creates an Option from another required keys are initialized\n * @param options Options\n */\nexport function initOptions(options) {\n  return Object.freeze({\n    idKey: \"_id\",\n    scriptEnabled: true,\n    useStrictMode: true,\n    processingMode: ProcessingMode.CLONE_OFF,\n    ...options\n  });\n}\n/**\n * The different groups of operators\n */\nexport var OperatorType;\n(function (OperatorType) {\n  OperatorType[\"ACCUMULATOR\"] = \"accumulator\";\n  OperatorType[\"EXPRESSION\"] = \"expression\";\n  OperatorType[\"PIPELINE\"] = \"pipeline\";\n  OperatorType[\"PROJECTION\"] = \"projection\";\n  OperatorType[\"QUERY\"] = \"query\";\n  OperatorType[\"WINDOW\"] = \"window\";\n})(OperatorType || (OperatorType = {}));\n// operator definitions\nconst OPERATORS = {\n  [OperatorType.ACCUMULATOR]: {},\n  [OperatorType.EXPRESSION]: {},\n  [OperatorType.PIPELINE]: {},\n  [OperatorType.PROJECTION]: {},\n  [OperatorType.QUERY]: {},\n  [OperatorType.WINDOW]: {}\n};\n/**\n * Register fully specified operators for the given operator class.\n *\n * @param type The operator type\n * @param operators Map of the operators\n */\nexport function useOperators(type, operators) {\n  for (const [name, fn] of Object.entries(operators)) {\n    assert(fn instanceof Function && isOperator(name), `'${name}' is not a valid operator`);\n    const currentFn = getOperator(type, name);\n    assert(!currentFn || fn === currentFn, `${name} already exists for '${type}' operators. Cannot change operator function once registered.`);\n  }\n  // toss the operator salad :)\n  into(OPERATORS[type], operators);\n}\n/**\n * Returns the operator function or null if it is not found\n * @param type Type of operator\n * @param operator Name of the operator\n */\nexport function getOperator(type, operator) {\n  return OPERATORS[type][operator];\n}\n/* eslint-disable unused-imports/no-unused-vars-ts */\n/**\n * Implementation of system variables\n * @type {Object}\n */\nconst systemVariables = {\n  $$ROOT(obj, expr, options) {\n    return options.root;\n  },\n  $$CURRENT(obj, expr, options) {\n    return obj;\n  },\n  $$REMOVE(obj, expr, options) {\n    return undefined;\n  },\n  $$NOW(obj, expr, options) {\n    return new Date(options.timestamp);\n  }\n};\n/**\n * Implementation of $redact variables\n *\n * Each function accepts 3 arguments (obj, expr, options)\n *\n * @type {Object}\n */\nconst redactVariables = {\n  $$KEEP(obj, expr, options) {\n    return obj;\n  },\n  $$PRUNE(obj, expr, options) {\n    return undefined;\n  },\n  $$DESCEND(obj, expr, options) {\n    // traverse nested documents iff there is a $cond\n    if (!has(expr, \"$cond\")) return obj;\n    let result;\n    for (const [key, current] of Object.entries(obj)) {\n      if (isObjectLike(current)) {\n        if (current instanceof Array) {\n          const array = [];\n          for (let elem of current) {\n            if (isObject(elem)) {\n              elem = redact(elem, expr, options.update(elem));\n            }\n            if (!isNil(elem)) {\n              array.push(elem);\n            }\n          }\n          result = array;\n        } else {\n          result = redact(current, expr, options.update(current));\n        }\n        if (isNil(result)) {\n          delete obj[key]; // pruned result\n        } else {\n          obj[key] = result;\n        }\n      }\n    }\n    return obj;\n  }\n};\n/* eslint-enable unused-imports/no-unused-vars-ts */\n/**\n * Computes the value of the expression on the object for the given operator\n *\n * @param obj the current object from the collection\n * @param expr the expression for the given field\n * @param operator the operator to resolve the field with\n * @param options {Object} extra options\n * @returns {*}\n */\nexport function computeValue(obj, expr, operator, options) {\n  // ensure valid options exist on first invocation\n  const copts = ComputeOptions.init(options, obj);\n  if (isOperator(operator)) {\n    // if the field of the object is a valid operator\n    const callExpression = getOperator(OperatorType.EXPRESSION, operator);\n    if (callExpression) return callExpression(obj, expr, copts);\n    // we also handle $group accumulator operators\n    const callAccumulator = getOperator(OperatorType.ACCUMULATOR, operator);\n    if (callAccumulator) {\n      // if object is not an array, first try to compute using the expression\n      if (!(obj instanceof Array)) {\n        obj = computeValue(obj, expr, null, copts);\n        expr = null;\n      }\n      // validate that we have an array\n      assert(obj instanceof Array, `'${operator}' target must be an array.`);\n      // for accumulators, we use the global options since the root is specific to each element within array.\n      return callAccumulator(obj, expr,\n      // reset the root object for accumulators.\n      copts.update(null, copts.local));\n    }\n    // operator was not found\n    throw new Error(`operator '${operator}' is not registered`);\n  }\n  // if expr is a string and begins with \"$$\", then we have a variable.\n  //  this can be one of; redact variable, system variable, user-defined variable.\n  //  we check and process them in that order.\n  //\n  // if expr begins only a single \"$\", then it is a path to a field on the object.\n  if (isString(expr) && expr.length > 0 && expr[0] === \"$\") {\n    // we return redact variables as literals\n    if (has(redactVariables, expr)) {\n      return expr;\n    }\n    // default to root for resolving path.\n    let context = copts.root;\n    // handle selectors with explicit prefix\n    const arr = expr.split(\".\");\n    if (has(systemVariables, arr[0])) {\n      // set 'root' only the first time it is required to be used for all subsequent calls\n      // if it already available on the options, it will be used\n      context = systemVariables[arr[0]](obj, null, copts);\n      expr = expr.slice(arr[0].length + 1); //  +1 for '.'\n    } else if (arr[0].slice(0, 2) === \"$$\") {\n      // handle user-defined variables\n      context = Object.assign({}, copts.variables,\n      // global vars\n      // current item is added before local variables because the binding may be changed.\n      {\n        this: obj\n      }, copts.local?.variables // local vars\n      );\n\n      const prefix = arr[0].slice(2);\n      assert(has(context, prefix), `Use of undefined variable: ${prefix}`);\n      expr = expr.slice(2);\n    } else {\n      // 'expr' is a path to a field on the object.\n      expr = expr.slice(1);\n    }\n    if (expr === \"\") return context;\n    return resolve(context, expr);\n  }\n  // check and return value if already in a resolved state\n  if (expr instanceof Array) {\n    return expr.map(item => computeValue(obj, item, null, copts));\n  } else if (isObject(expr)) {\n    const result = {};\n    for (const [key, val] of Object.entries(expr)) {\n      result[key] = computeValue(obj, val, key, copts);\n      // must run ONLY one aggregate operator per expression\n      // if so, return result of the computed value\n      if ([OperatorType.EXPRESSION, OperatorType.ACCUMULATOR].some(c => has(OPERATORS[c], key))) {\n        // there should be only one operator\n        assert(Object.keys(expr).length === 1, \"Invalid aggregation expression '\" + JSON.stringify(expr) + \"'\");\n        return result[key];\n      }\n    }\n    return result;\n  }\n  return expr;\n}\n/**\n * Redact an object\n * @param  {Object} obj The object to redact\n * @param  {*} expr The redact expression\n * @param  {*} options  Options for value\n * @return {*} returns the result of the redacted object\n */\nexport function redact(obj, expr, options) {\n  const result = computeValue(obj, expr, null, options);\n  return has(redactVariables, result) ? redactVariables[result](obj, expr, options) : result;\n}","map":{"version":3,"names":["assert","has","into","isNil","isObject","isObjectLike","isOperator","isString","resolve","ProcessingMode","ComputeOptions","constructor","options","_root","_local","timestamp","Date","now","_defineProperty","update","init","root","local","Object","assign","initOptions","variables","idKey","collation","processingMode","CLONE_OFF","useStrictMode","scriptEnabled","hashFunction","collectionResolver","jsonSchemaValidator","freeze","OperatorType","OPERATORS","ACCUMULATOR","EXPRESSION","PIPELINE","PROJECTION","QUERY","WINDOW","useOperators","type","operators","name","fn","entries","Function","currentFn","getOperator","operator","systemVariables","$$ROOT","obj","expr","$$CURRENT","$$REMOVE","undefined","$$NOW","redactVariables","$$KEEP","$$PRUNE","$$DESCEND","result","key","current","Array","array","elem","redact","push","computeValue","copts","callExpression","callAccumulator","Error","length","context","arr","split","slice","this","prefix","map","item","val","some","c","keys","JSON","stringify"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/mingo/es/core.js"],"sourcesContent":["import { assert, has, into, isNil, isObject, isObjectLike, isOperator, isString, resolve, } from \"./util\";\n/**\n * This controls how input and output documents are processed to meet different application needs.\n * Each mode has different trade offs for; immutability, reference sharing, and performance.\n */\nexport var ProcessingMode;\n(function (ProcessingMode) {\n    /**\n     * Clone inputs prior to processing, and the outputs if some objects graphs may be shared.\n     * Use this option to keep input collection immutable and to get distinct output objects.\n     *\n     * Note: This option is expensive and reduces performance.\n     */\n    ProcessingMode[\"CLONE_ALL\"] = \"CLONE_ALL\";\n    /**\n     * Clones inputs prior to processing.\n     * This option will return output objects with shared graphs in their path if specific operators are used.\n     * Use this option to keep the input collection immutable.\n     *\n     */\n    ProcessingMode[\"CLONE_INPUT\"] = \"CLONE_INPUT\";\n    /**\n     * Clones the output to return distinct objects with no shared paths.\n     * This option modifies the input collection and during processing.\n     */\n    ProcessingMode[\"CLONE_OUTPUT\"] = \"CLONE_OUTPUT\";\n    /**\n     * Turn off cloning and modifies the input collection as needed.\n     * This option will also return output objects with shared paths in their graph when specific operators are used.\n     * This option provides the greatest speedup for the biggest tradeoff.\n     * When using the aggregation pipeline, you can use the \"$out\" operator to collect immutable intermediate results.\n     *\n     * @default\n     */\n    ProcessingMode[\"CLONE_OFF\"] = \"CLONE_OFF\";\n})(ProcessingMode || (ProcessingMode = {}));\n/** Custom type to facilitate type checking for global options */\nexport class ComputeOptions {\n    options;\n    _root;\n    _local;\n    timestamp;\n    constructor(options, \n    /** Reference to the root object when processing subgraphs of the object. */\n    _root, _local, \n    /** The current time in milliseconds. Remains the same throughout all stages of the aggregation pipeline. */\n    timestamp = Date.now()) {\n        this.options = options;\n        this._root = _root;\n        this._local = _local;\n        this.timestamp = timestamp;\n        this.options = options;\n        this.update(_root, _local);\n    }\n    /**\n     * Initialize new ComputeOptions. Returns the same object modified when the 'options' argument is a ComputeOptions.\n     * @param options\n     * @param root\n     * @param local\n     * @returns\n     */\n    static init(options, root, local) {\n        return options instanceof ComputeOptions\n            ? options.update(\n            // value can be '0' or 'false'\n            isNil(options.root) ? root : options.root, Object.assign({}, options.local, local))\n            : new ComputeOptions(options || initOptions(), root, local);\n    }\n    /** Updates the internal mutable state. */\n    update(root, local) {\n        // NOTE: this is done for efficiency to avoid creating too many intermediate options objects.\n        this._root = root;\n        this._local = local\n            ? Object.assign({}, local, {\n                variables: Object.assign({}, this._local?.variables, local?.variables),\n            })\n            : local;\n        return this;\n    }\n    get root() {\n        return this._root;\n    }\n    get local() {\n        return this._local;\n    }\n    get idKey() {\n        return this.options?.idKey;\n    }\n    get collation() {\n        return this.options?.collation;\n    }\n    get processingMode() {\n        return this.options?.processingMode || ProcessingMode.CLONE_OFF;\n    }\n    get useStrictMode() {\n        return this.options?.useStrictMode;\n    }\n    get scriptEnabled() {\n        return this.options?.scriptEnabled;\n    }\n    get hashFunction() {\n        return this.options?.hashFunction;\n    }\n    get collectionResolver() {\n        return this.options?.collectionResolver;\n    }\n    get jsonSchemaValidator() {\n        return this.options?.jsonSchemaValidator;\n    }\n    get variables() {\n        return this.options?.variables;\n    }\n}\n/**\n * Creates an Option from another required keys are initialized\n * @param options Options\n */\nexport function initOptions(options) {\n    return Object.freeze({\n        idKey: \"_id\",\n        scriptEnabled: true,\n        useStrictMode: true,\n        processingMode: ProcessingMode.CLONE_OFF,\n        ...options,\n    });\n}\n/**\n * The different groups of operators\n */\nexport var OperatorType;\n(function (OperatorType) {\n    OperatorType[\"ACCUMULATOR\"] = \"accumulator\";\n    OperatorType[\"EXPRESSION\"] = \"expression\";\n    OperatorType[\"PIPELINE\"] = \"pipeline\";\n    OperatorType[\"PROJECTION\"] = \"projection\";\n    OperatorType[\"QUERY\"] = \"query\";\n    OperatorType[\"WINDOW\"] = \"window\";\n})(OperatorType || (OperatorType = {}));\n// operator definitions\nconst OPERATORS = {\n    [OperatorType.ACCUMULATOR]: {},\n    [OperatorType.EXPRESSION]: {},\n    [OperatorType.PIPELINE]: {},\n    [OperatorType.PROJECTION]: {},\n    [OperatorType.QUERY]: {},\n    [OperatorType.WINDOW]: {},\n};\n/**\n * Register fully specified operators for the given operator class.\n *\n * @param type The operator type\n * @param operators Map of the operators\n */\nexport function useOperators(type, operators) {\n    for (const [name, fn] of Object.entries(operators)) {\n        assert(fn instanceof Function && isOperator(name), `'${name}' is not a valid operator`);\n        const currentFn = getOperator(type, name);\n        assert(!currentFn || fn === currentFn, `${name} already exists for '${type}' operators. Cannot change operator function once registered.`);\n    }\n    // toss the operator salad :)\n    into(OPERATORS[type], operators);\n}\n/**\n * Returns the operator function or null if it is not found\n * @param type Type of operator\n * @param operator Name of the operator\n */\nexport function getOperator(type, operator) {\n    return OPERATORS[type][operator];\n}\n/* eslint-disable unused-imports/no-unused-vars-ts */\n/**\n * Implementation of system variables\n * @type {Object}\n */\nconst systemVariables = {\n    $$ROOT(obj, expr, options) {\n        return options.root;\n    },\n    $$CURRENT(obj, expr, options) {\n        return obj;\n    },\n    $$REMOVE(obj, expr, options) {\n        return undefined;\n    },\n    $$NOW(obj, expr, options) {\n        return new Date(options.timestamp);\n    },\n};\n/**\n * Implementation of $redact variables\n *\n * Each function accepts 3 arguments (obj, expr, options)\n *\n * @type {Object}\n */\nconst redactVariables = {\n    $$KEEP(obj, expr, options) {\n        return obj;\n    },\n    $$PRUNE(obj, expr, options) {\n        return undefined;\n    },\n    $$DESCEND(obj, expr, options) {\n        // traverse nested documents iff there is a $cond\n        if (!has(expr, \"$cond\"))\n            return obj;\n        let result;\n        for (const [key, current] of Object.entries(obj)) {\n            if (isObjectLike(current)) {\n                if (current instanceof Array) {\n                    const array = [];\n                    for (let elem of current) {\n                        if (isObject(elem)) {\n                            elem = redact(elem, expr, options.update(elem));\n                        }\n                        if (!isNil(elem)) {\n                            array.push(elem);\n                        }\n                    }\n                    result = array;\n                }\n                else {\n                    result = redact(current, expr, options.update(current));\n                }\n                if (isNil(result)) {\n                    delete obj[key]; // pruned result\n                }\n                else {\n                    obj[key] = result;\n                }\n            }\n        }\n        return obj;\n    },\n};\n/* eslint-enable unused-imports/no-unused-vars-ts */\n/**\n * Computes the value of the expression on the object for the given operator\n *\n * @param obj the current object from the collection\n * @param expr the expression for the given field\n * @param operator the operator to resolve the field with\n * @param options {Object} extra options\n * @returns {*}\n */\nexport function computeValue(obj, expr, operator, options) {\n    // ensure valid options exist on first invocation\n    const copts = ComputeOptions.init(options, obj);\n    if (isOperator(operator)) {\n        // if the field of the object is a valid operator\n        const callExpression = getOperator(OperatorType.EXPRESSION, operator);\n        if (callExpression)\n            return callExpression(obj, expr, copts);\n        // we also handle $group accumulator operators\n        const callAccumulator = getOperator(OperatorType.ACCUMULATOR, operator);\n        if (callAccumulator) {\n            // if object is not an array, first try to compute using the expression\n            if (!(obj instanceof Array)) {\n                obj = computeValue(obj, expr, null, copts);\n                expr = null;\n            }\n            // validate that we have an array\n            assert(obj instanceof Array, `'${operator}' target must be an array.`);\n            // for accumulators, we use the global options since the root is specific to each element within array.\n            return callAccumulator(obj, expr, \n            // reset the root object for accumulators.\n            copts.update(null, copts.local));\n        }\n        // operator was not found\n        throw new Error(`operator '${operator}' is not registered`);\n    }\n    // if expr is a string and begins with \"$$\", then we have a variable.\n    //  this can be one of; redact variable, system variable, user-defined variable.\n    //  we check and process them in that order.\n    //\n    // if expr begins only a single \"$\", then it is a path to a field on the object.\n    if (isString(expr) && expr.length > 0 && expr[0] === \"$\") {\n        // we return redact variables as literals\n        if (has(redactVariables, expr)) {\n            return expr;\n        }\n        // default to root for resolving path.\n        let context = copts.root;\n        // handle selectors with explicit prefix\n        const arr = expr.split(\".\");\n        if (has(systemVariables, arr[0])) {\n            // set 'root' only the first time it is required to be used for all subsequent calls\n            // if it already available on the options, it will be used\n            context = systemVariables[arr[0]](obj, null, copts);\n            expr = expr.slice(arr[0].length + 1); //  +1 for '.'\n        }\n        else if (arr[0].slice(0, 2) === \"$$\") {\n            // handle user-defined variables\n            context = Object.assign({}, copts.variables, // global vars\n            // current item is added before local variables because the binding may be changed.\n            { this: obj }, copts.local?.variables // local vars\n            );\n            const prefix = arr[0].slice(2);\n            assert(has(context, prefix), `Use of undefined variable: ${prefix}`);\n            expr = expr.slice(2);\n        }\n        else {\n            // 'expr' is a path to a field on the object.\n            expr = expr.slice(1);\n        }\n        if (expr === \"\")\n            return context;\n        return resolve(context, expr);\n    }\n    // check and return value if already in a resolved state\n    if (expr instanceof Array) {\n        return expr.map((item) => computeValue(obj, item, null, copts));\n    }\n    else if (isObject(expr)) {\n        const result = {};\n        for (const [key, val] of Object.entries(expr)) {\n            result[key] = computeValue(obj, val, key, copts);\n            // must run ONLY one aggregate operator per expression\n            // if so, return result of the computed value\n            if ([OperatorType.EXPRESSION, OperatorType.ACCUMULATOR].some((c) => has(OPERATORS[c], key))) {\n                // there should be only one operator\n                assert(Object.keys(expr).length === 1, \"Invalid aggregation expression '\" + JSON.stringify(expr) + \"'\");\n                return result[key];\n            }\n        }\n        return result;\n    }\n    return expr;\n}\n/**\n * Redact an object\n * @param  {Object} obj The object to redact\n * @param  {*} expr The redact expression\n * @param  {*} options  Options for value\n * @return {*} returns the result of the redacted object\n */\nexport function redact(obj, expr, options) {\n    const result = computeValue(obj, expr, null, options);\n    return has(redactVariables, result)\n        ? redactVariables[result](obj, expr, options)\n        : result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}