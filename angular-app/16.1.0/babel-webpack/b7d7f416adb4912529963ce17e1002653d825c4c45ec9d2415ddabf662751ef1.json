{"ast":null,"code":"/**\n * Copied from\n * @link https://github.com/sindresorhus/dot-prop/blob/main/index.js\n * because it is currently an esm only module.\n * TODO use the npm package again when RxDB is also fully esm.\n */\n\nvar isObject = value => {\n  var type = typeof value;\n  return value !== null && (type === 'object' || type === 'function');\n};\nvar disallowedKeys = new Set(['__proto__', 'prototype', 'constructor']);\nvar digits = new Set('0123456789');\nfunction getPathSegments(path) {\n  var parts = [];\n  var currentSegment = '';\n  var currentPart = 'start';\n  var isIgnoring = false;\n  for (var character of path) {\n    switch (character) {\n      case '\\\\':\n        {\n          if (currentPart === 'index') {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            throw new Error('Invalid character after an index');\n          }\n          if (isIgnoring) {\n            currentSegment += character;\n          }\n          currentPart = 'property';\n          isIgnoring = !isIgnoring;\n          break;\n        }\n      case '.':\n        {\n          if (currentPart === 'index') {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            currentPart = 'property';\n            break;\n          }\n          if (isIgnoring) {\n            isIgnoring = false;\n            currentSegment += character;\n            break;\n          }\n          if (disallowedKeys.has(currentSegment)) {\n            return [];\n          }\n          parts.push(currentSegment);\n          currentSegment = '';\n          currentPart = 'property';\n          break;\n        }\n      case '[':\n        {\n          if (currentPart === 'index') {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            currentPart = 'index';\n            break;\n          }\n          if (isIgnoring) {\n            isIgnoring = false;\n            currentSegment += character;\n            break;\n          }\n          if (currentPart === 'property') {\n            if (disallowedKeys.has(currentSegment)) {\n              return [];\n            }\n            parts.push(currentSegment);\n            currentSegment = '';\n          }\n          currentPart = 'index';\n          break;\n        }\n      case ']':\n        {\n          if (currentPart === 'index') {\n            parts.push(Number.parseInt(currentSegment, 10));\n            currentSegment = '';\n            currentPart = 'indexEnd';\n            break;\n          }\n          if (currentPart === 'indexEnd') {\n            throw new Error('Invalid character after an index');\n          }\n\n          // Falls through\n        }\n\n      default:\n        {\n          if (currentPart === 'index' && !digits.has(character)) {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            throw new Error('Invalid character after an index');\n          }\n          if (currentPart === 'start') {\n            currentPart = 'property';\n          }\n          if (isIgnoring) {\n            isIgnoring = false;\n            currentSegment += '\\\\';\n          }\n          currentSegment += character;\n        }\n    }\n  }\n  if (isIgnoring) {\n    currentSegment += '\\\\';\n  }\n  switch (currentPart) {\n    case 'property':\n      {\n        if (disallowedKeys.has(currentSegment)) {\n          return [];\n        }\n        parts.push(currentSegment);\n        break;\n      }\n    case 'index':\n      {\n        throw new Error('Index was not closed');\n      }\n    case 'start':\n      {\n        parts.push('');\n        break;\n      }\n    // No default\n  }\n\n  return parts;\n}\nfunction isStringIndex(object, key) {\n  if (typeof key !== 'number' && Array.isArray(object)) {\n    var index = Number.parseInt(key, 10);\n    return Number.isInteger(index) && object[index] === object[key];\n  }\n  return false;\n}\nfunction assertNotStringIndex(object, key) {\n  if (isStringIndex(object, key)) {\n    throw new Error('Cannot use string index');\n  }\n}\nexport function getProperty(object, path, value) {\n  if (Array.isArray(path)) {\n    path = path.join('.');\n  }\n  if (!isObject(object) || typeof path !== 'string') {\n    return value === undefined ? object : value;\n  }\n  var pathArray = getPathSegments(path);\n  if (pathArray.length === 0) {\n    return value;\n  }\n  for (var index = 0; index < pathArray.length; index++) {\n    var key = pathArray[index];\n    if (isStringIndex(object, key)) {\n      object = index === pathArray.length - 1 ? undefined : null;\n    } else {\n      object = object[key];\n    }\n    if (object === undefined || object === null) {\n      // `object` is either `undefined` or `null` so we want to stop the loop, and\n      // if this is not the last bit of the path, and\n      // if it didn't return `undefined`\n      // it would return `null` if `object` is `null`\n      // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n      if (index !== pathArray.length - 1) {\n        return value;\n      }\n      break;\n    }\n  }\n  return object === undefined ? value : object;\n}\nexport function setProperty(object, path, value) {\n  if (Array.isArray(path)) {\n    path = path.join('.');\n  }\n  if (!isObject(object) || typeof path !== 'string') {\n    return object;\n  }\n  var root = object;\n  var pathArray = getPathSegments(path);\n  for (var index = 0; index < pathArray.length; index++) {\n    var key = pathArray[index];\n    assertNotStringIndex(object, key);\n    if (index === pathArray.length - 1) {\n      object[key] = value;\n    } else if (!isObject(object[key])) {\n      object[key] = typeof pathArray[index + 1] === 'number' ? [] : {};\n    }\n    object = object[key];\n  }\n  return root;\n}\nexport function deleteProperty(object, path) {\n  if (!isObject(object) || typeof path !== 'string') {\n    return false;\n  }\n  var pathArray = getPathSegments(path);\n  for (var index = 0; index < pathArray.length; index++) {\n    var key = pathArray[index];\n    assertNotStringIndex(object, key);\n    if (index === pathArray.length - 1) {\n      delete object[key];\n      return true;\n    }\n    object = object[key];\n    if (!isObject(object)) {\n      return false;\n    }\n  }\n}\nexport function hasProperty(object, path) {\n  if (!isObject(object) || typeof path !== 'string') {\n    return false;\n  }\n  var pathArray = getPathSegments(path);\n  if (pathArray.length === 0) {\n    return false;\n  }\n  for (var key of pathArray) {\n    if (!isObject(object) || !(key in object) || isStringIndex(object, key)) {\n      return false;\n    }\n    object = object[key];\n  }\n  return true;\n}\n\n// TODO: Backslashes with no effect should not be escaped\nfunction escapePath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return path.replace(/[\\\\.[]/g, '\\\\$&');\n}\n\n// The keys returned by Object.entries() for arrays are strings\nfunction entries(value) {\n  if (Array.isArray(value)) {\n    return value.map((v, index) => [index, v]);\n  }\n  return Object.entries(value);\n}\nfunction stringifyPath(pathSegments) {\n  var result = '';\n\n  // eslint-disable-next-line prefer-const\n  for (var [index, segment] of entries(pathSegments)) {\n    if (typeof segment === 'number') {\n      result += \"[\" + segment + \"]\";\n    } else {\n      segment = escapePath(segment);\n      result += index === 0 ? segment : \".\" + segment;\n    }\n  }\n  return result;\n}\nfunction* deepKeysIterator(object, currentPath = []) {\n  if (!isObject(object)) {\n    if (currentPath.length > 0) {\n      yield stringifyPath(currentPath);\n    }\n    return;\n  }\n  for (var [key, value] of entries(object)) {\n    yield* deepKeysIterator(value, [...currentPath, key]);\n  }\n}\nexport function deepKeys(object) {\n  return [...deepKeysIterator(object)];\n}","map":{"version":3,"names":["isObject","value","type","disallowedKeys","Set","digits","getPathSegments","path","parts","currentSegment","currentPart","isIgnoring","character","Error","has","push","Number","parseInt","isStringIndex","object","key","Array","isArray","index","isInteger","assertNotStringIndex","getProperty","join","undefined","pathArray","length","setProperty","root","deleteProperty","hasProperty","escapePath","TypeError","replace","entries","map","v","Object","stringifyPath","pathSegments","result","segment","deepKeysIterator","currentPath","deepKeys"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/plugins/utils/utils-object-dot-prop.js"],"sourcesContent":["/**\n * Copied from\n * @link https://github.com/sindresorhus/dot-prop/blob/main/index.js\n * because it is currently an esm only module.\n * TODO use the npm package again when RxDB is also fully esm.\n */\n\nvar isObject = value => {\n  var type = typeof value;\n  return value !== null && (type === 'object' || type === 'function');\n};\nvar disallowedKeys = new Set(['__proto__', 'prototype', 'constructor']);\nvar digits = new Set('0123456789');\nfunction getPathSegments(path) {\n  var parts = [];\n  var currentSegment = '';\n  var currentPart = 'start';\n  var isIgnoring = false;\n  for (var character of path) {\n    switch (character) {\n      case '\\\\':\n        {\n          if (currentPart === 'index') {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            throw new Error('Invalid character after an index');\n          }\n          if (isIgnoring) {\n            currentSegment += character;\n          }\n          currentPart = 'property';\n          isIgnoring = !isIgnoring;\n          break;\n        }\n      case '.':\n        {\n          if (currentPart === 'index') {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            currentPart = 'property';\n            break;\n          }\n          if (isIgnoring) {\n            isIgnoring = false;\n            currentSegment += character;\n            break;\n          }\n          if (disallowedKeys.has(currentSegment)) {\n            return [];\n          }\n          parts.push(currentSegment);\n          currentSegment = '';\n          currentPart = 'property';\n          break;\n        }\n      case '[':\n        {\n          if (currentPart === 'index') {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            currentPart = 'index';\n            break;\n          }\n          if (isIgnoring) {\n            isIgnoring = false;\n            currentSegment += character;\n            break;\n          }\n          if (currentPart === 'property') {\n            if (disallowedKeys.has(currentSegment)) {\n              return [];\n            }\n            parts.push(currentSegment);\n            currentSegment = '';\n          }\n          currentPart = 'index';\n          break;\n        }\n      case ']':\n        {\n          if (currentPart === 'index') {\n            parts.push(Number.parseInt(currentSegment, 10));\n            currentSegment = '';\n            currentPart = 'indexEnd';\n            break;\n          }\n          if (currentPart === 'indexEnd') {\n            throw new Error('Invalid character after an index');\n          }\n\n          // Falls through\n        }\n\n      default:\n        {\n          if (currentPart === 'index' && !digits.has(character)) {\n            throw new Error('Invalid character in an index');\n          }\n          if (currentPart === 'indexEnd') {\n            throw new Error('Invalid character after an index');\n          }\n          if (currentPart === 'start') {\n            currentPart = 'property';\n          }\n          if (isIgnoring) {\n            isIgnoring = false;\n            currentSegment += '\\\\';\n          }\n          currentSegment += character;\n        }\n    }\n  }\n  if (isIgnoring) {\n    currentSegment += '\\\\';\n  }\n  switch (currentPart) {\n    case 'property':\n      {\n        if (disallowedKeys.has(currentSegment)) {\n          return [];\n        }\n        parts.push(currentSegment);\n        break;\n      }\n    case 'index':\n      {\n        throw new Error('Index was not closed');\n      }\n    case 'start':\n      {\n        parts.push('');\n        break;\n      }\n    // No default\n  }\n\n  return parts;\n}\nfunction isStringIndex(object, key) {\n  if (typeof key !== 'number' && Array.isArray(object)) {\n    var index = Number.parseInt(key, 10);\n    return Number.isInteger(index) && object[index] === object[key];\n  }\n  return false;\n}\nfunction assertNotStringIndex(object, key) {\n  if (isStringIndex(object, key)) {\n    throw new Error('Cannot use string index');\n  }\n}\nexport function getProperty(object, path, value) {\n  if (Array.isArray(path)) {\n    path = path.join('.');\n  }\n  if (!isObject(object) || typeof path !== 'string') {\n    return value === undefined ? object : value;\n  }\n  var pathArray = getPathSegments(path);\n  if (pathArray.length === 0) {\n    return value;\n  }\n  for (var index = 0; index < pathArray.length; index++) {\n    var key = pathArray[index];\n    if (isStringIndex(object, key)) {\n      object = index === pathArray.length - 1 ? undefined : null;\n    } else {\n      object = object[key];\n    }\n    if (object === undefined || object === null) {\n      // `object` is either `undefined` or `null` so we want to stop the loop, and\n      // if this is not the last bit of the path, and\n      // if it didn't return `undefined`\n      // it would return `null` if `object` is `null`\n      // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n      if (index !== pathArray.length - 1) {\n        return value;\n      }\n      break;\n    }\n  }\n  return object === undefined ? value : object;\n}\nexport function setProperty(object, path, value) {\n  if (Array.isArray(path)) {\n    path = path.join('.');\n  }\n  if (!isObject(object) || typeof path !== 'string') {\n    return object;\n  }\n  var root = object;\n  var pathArray = getPathSegments(path);\n  for (var index = 0; index < pathArray.length; index++) {\n    var key = pathArray[index];\n    assertNotStringIndex(object, key);\n    if (index === pathArray.length - 1) {\n      object[key] = value;\n    } else if (!isObject(object[key])) {\n      object[key] = typeof pathArray[index + 1] === 'number' ? [] : {};\n    }\n    object = object[key];\n  }\n  return root;\n}\nexport function deleteProperty(object, path) {\n  if (!isObject(object) || typeof path !== 'string') {\n    return false;\n  }\n  var pathArray = getPathSegments(path);\n  for (var index = 0; index < pathArray.length; index++) {\n    var key = pathArray[index];\n    assertNotStringIndex(object, key);\n    if (index === pathArray.length - 1) {\n      delete object[key];\n      return true;\n    }\n    object = object[key];\n    if (!isObject(object)) {\n      return false;\n    }\n  }\n}\nexport function hasProperty(object, path) {\n  if (!isObject(object) || typeof path !== 'string') {\n    return false;\n  }\n  var pathArray = getPathSegments(path);\n  if (pathArray.length === 0) {\n    return false;\n  }\n  for (var key of pathArray) {\n    if (!isObject(object) || !(key in object) || isStringIndex(object, key)) {\n      return false;\n    }\n    object = object[key];\n  }\n  return true;\n}\n\n// TODO: Backslashes with no effect should not be escaped\nfunction escapePath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return path.replace(/[\\\\.[]/g, '\\\\$&');\n}\n\n// The keys returned by Object.entries() for arrays are strings\nfunction entries(value) {\n  if (Array.isArray(value)) {\n    return value.map((v, index) => [index, v]);\n  }\n  return Object.entries(value);\n}\nfunction stringifyPath(pathSegments) {\n  var result = '';\n\n  // eslint-disable-next-line prefer-const\n  for (var [index, segment] of entries(pathSegments)) {\n    if (typeof segment === 'number') {\n      result += \"[\" + segment + \"]\";\n    } else {\n      segment = escapePath(segment);\n      result += index === 0 ? segment : \".\" + segment;\n    }\n  }\n  return result;\n}\nfunction* deepKeysIterator(object, currentPath = []) {\n  if (!isObject(object)) {\n    if (currentPath.length > 0) {\n      yield stringifyPath(currentPath);\n    }\n    return;\n  }\n  for (var [key, value] of entries(object)) {\n    yield* deepKeysIterator(value, [...currentPath, key]);\n  }\n}\nexport function deepKeys(object) {\n  return [...deepKeysIterator(object)];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}