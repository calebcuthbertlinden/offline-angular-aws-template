{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { BehaviorSubject, firstValueFrom, merge } from 'rxjs';\nimport { mergeMap, filter, map, startWith, distinctUntilChanged, shareReplay } from 'rxjs/operators';\nimport { sortObject, stringifyFilter, pluginMissing, overwriteGetterForCaching, now, PROMISE_RESOLVE_FALSE, RXJS_SHARE_REPLAY_DEFAULTS, ensureNotFalsy, areRxDocumentArraysEqual } from './plugins/utils';\nimport { newRxError } from './rx-error';\nimport { runPluginHooks } from './hooks';\nimport { calculateNewResults } from './event-reduce';\nimport { triggerCacheReplacement } from './query-cache';\nimport { getQueryMatcher, normalizeMangoQuery } from './rx-query-helper';\nvar _queryCount = 0;\nvar newQueryID = function () {\n  return ++_queryCount;\n};\nexport var RxQueryBase = /*#__PURE__*/function () {\n  /**\n   * Some stats then are used for debugging and cache replacement policies\n   */\n\n  // used in the query-cache to determine if the RxQuery can be cleaned up.\n\n  // used to count the subscribers to the query\n\n  /**\n   * Contains the current result state\n   * or null if query has not run yet.\n   */\n\n  function RxQueryBase(op, mangoQuery, collection,\n  // used by some plugins\n  other = {}) {\n    this.id = newQueryID();\n    this._execOverDatabaseCount = 0;\n    this._creationTime = now();\n    this._lastEnsureEqual = 0;\n    this.uncached = false;\n    this.refCount$ = new BehaviorSubject(null);\n    this._result = null;\n    this._latestChangeEvent = -1;\n    this._lastExecStart = 0;\n    this._lastExecEnd = 0;\n    this._ensureEqualQueue = PROMISE_RESOLVE_FALSE;\n    this.op = op;\n    this.mangoQuery = mangoQuery;\n    this.collection = collection;\n    this.other = other;\n    if (!mangoQuery) {\n      this.mangoQuery = _getDefaultQuery();\n    }\n    this.isFindOneByIdQuery = isFindOneByIdQuery(this.collection.schema.primaryPath, mangoQuery);\n  }\n  var _proto = RxQueryBase.prototype;\n  /**\n   * Returns an observable that emits the results\n   * This should behave like an rxjs-BehaviorSubject which means:\n   * - Emit the current result-set on subscribe\n   * - Emit the new result-set when an RxChangeEvent comes in\n   * - Do not emit anything before the first result-set was created (no null)\n   */\n  /**\n   * set the new result-data as result-docs of the query\n   * @param newResultData json-docs that were received from the storage\n   */\n  _proto._setResultData = function _setResultData(newResultData) {\n    if (typeof newResultData === 'number') {\n      this._result = {\n        docsData: [],\n        docsMap: new Map(),\n        docsDataMap: new Map(),\n        count: newResultData,\n        docs: [],\n        time: now()\n      };\n      return;\n    } else if (newResultData instanceof Map) {\n      newResultData = Array.from(newResultData.values());\n    }\n    var docsDataMap = new Map();\n    var docsMap = new Map();\n    var docs = newResultData.map(docData => this.collection._docCache.getCachedRxDocument(docData));\n\n    /**\n     * Instead of using the newResultData in the result cache,\n     * we directly use the objects that are stored in the RxDocument\n     * to ensure we do not store the same data twice and fill up the memory.\n     */\n    var docsData = docs.map(doc => {\n      docsDataMap.set(doc.primary, doc._data);\n      docsMap.set(doc.primary, doc);\n      return doc._data;\n    });\n    this._result = {\n      docsData,\n      docsMap,\n      docsDataMap,\n      count: docsData.length,\n      docs,\n      time: now()\n    };\n  }\n\n  /**\n   * executes the query on the database\n   * @return results-array with document-data\n   */;\n  _proto._execOverDatabase = /*#__PURE__*/function () {\n    var _execOverDatabase2 = _asyncToGenerator(function* () {\n      this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n      this._lastExecStart = now();\n      if (this.op === 'count') {\n        var preparedQuery = this.getPreparedQuery();\n        var result = yield this.collection.storageInstance.count(preparedQuery);\n        if (result.mode === 'slow' && !this.collection.database.allowSlowCount) {\n          throw newRxError('QU14', {\n            collection: this.collection,\n            queryObj: this.mangoQuery\n          });\n        } else {\n          return result.count;\n        }\n      }\n      if (this.op === 'findByIds') {\n        var ids = ensureNotFalsy(this.mangoQuery.selector)[this.collection.schema.primaryPath].$in;\n        var ret = new Map();\n        var mustBeQueried = [];\n        // first try to fill from docCache\n        ids.forEach(id => {\n          var docData = this.collection._docCache.getLatestDocumentDataIfExists(id);\n          if (docData) {\n            if (!docData._deleted) {\n              var doc = this.collection._docCache.getCachedRxDocument(docData);\n              ret.set(id, doc);\n            }\n          } else {\n            mustBeQueried.push(id);\n          }\n        });\n        // everything which was not in docCache must be fetched from the storage\n        if (mustBeQueried.length > 0) {\n          var docs = yield this.collection.storageInstance.findDocumentsById(mustBeQueried, false);\n          Object.values(docs).forEach(docData => {\n            var doc = this.collection._docCache.getCachedRxDocument(docData);\n            ret.set(doc.primary, doc);\n          });\n        }\n        return ret;\n      }\n      var docsPromise = queryCollection(this);\n      return docsPromise.then(docs => {\n        this._lastExecEnd = now();\n        return docs;\n      });\n    });\n    function _execOverDatabase() {\n      return _execOverDatabase2.apply(this, arguments);\n    }\n    return _execOverDatabase;\n  }()\n\n  /**\n   * Execute the query\n   * To have an easier implementations,\n   * just subscribe and use the first result\n   */;\n  _proto.exec = function exec(throwIfMissing) {\n    if (throwIfMissing && this.op !== 'findOne') {\n      throw newRxError('QU9', {\n        collection: this.collection.name,\n        query: this.mangoQuery,\n        op: this.op\n      });\n    }\n\n    /**\n     * run _ensureEqual() here,\n     * this will make sure that errors in the query which throw inside of the RxStorage,\n     * will be thrown at this execution context and not in the background.\n     */\n    return _ensureEqual(this).then(() => firstValueFrom(this.$)).then(result => {\n      if (!result && throwIfMissing) {\n        throw newRxError('QU10', {\n          collection: this.collection.name,\n          query: this.mangoQuery,\n          op: this.op\n        });\n      } else {\n        return result;\n      }\n    });\n  }\n\n  /**\n   * cached call to get the queryMatcher\n   * @overwrites itself with the actual value\n   */;\n  /**\n   * returns a string that is used for equal-comparisons\n   * @overwrites itself with the actual value\n   */\n  _proto.toString = function toString() {\n    var stringObj = sortObject({\n      op: this.op,\n      query: this.mangoQuery,\n      other: this.other\n    }, true);\n    var value = JSON.stringify(stringObj, stringifyFilter);\n    this.toString = () => value;\n    return value;\n  }\n\n  /**\n   * returns the prepared query\n   * which can be send to the storage instance to query for documents.\n   * @overwrites itself with the actual value.\n   */;\n  _proto.getPreparedQuery = function getPreparedQuery() {\n    var hookInput = {\n      rxQuery: this,\n      // can be mutated by the hooks so we have to deep clone first.\n      mangoQuery: normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery)\n    };\n    runPluginHooks('prePrepareQuery', hookInput);\n    var value = this.collection.database.storage.statics.prepareQuery(this.collection.schema.jsonSchema, hookInput.mangoQuery);\n    this.getPreparedQuery = () => value;\n    return value;\n  }\n\n  /**\n   * returns true if the document matches the query,\n   * does not use the 'skip' and 'limit'\n   */;\n  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {\n    // if doc is deleted, it cannot match\n    if (docData._deleted) {\n      return false;\n    }\n    return this.queryMatcher(docData);\n  }\n\n  /**\n   * deletes all found documents\n   * @return promise with deleted documents\n   */;\n  _proto.remove = function remove() {\n    return this.exec().then(docs => {\n      if (Array.isArray(docs)) {\n        // TODO use a bulk operation instead of running .remove() on each document\n        return Promise.all(docs.map(doc => doc.remove()));\n      } else {\n        return docs.remove();\n      }\n    });\n  }\n\n  /**\n   * helper function to transform RxQueryBase to RxQuery type\n   */;\n  /**\n   * updates all found documents\n   * @overwritten by plugin (optional)\n   */\n  _proto.update = function update(_updateObj) {\n    throw pluginMissing('update');\n  }\n\n  // we only set some methods of query-builder here\n  // because the others depend on these ones\n  ;\n\n  _proto.where = function where(_queryObj) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.sort = function sort(_params) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.skip = function skip(_amount) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.limit = function limit(_amount) {\n    throw pluginMissing('query-builder');\n  };\n  _createClass(RxQueryBase, [{\n    key: \"$\",\n    get: function () {\n      if (!this._$) {\n        var results$ = this.collection.$.pipe(\n        /**\n         * Performance shortcut.\n         * Changes to local documents are not relevant for the query.\n         */\n        filter(changeEvent => !changeEvent.isLocal),\n        /**\n         * Start once to ensure the querying also starts\n         * when there where no changes.\n         */\n        startWith(null),\n        // ensure query results are up to date.\n        mergeMap(() => _ensureEqual(this)),\n        // use the current result set, written by _ensureEqual().\n        map(() => this._result),\n        // do not run stuff above for each new subscriber, only once.\n        shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),\n        // do not proceed if result set has not changed.\n        distinctUntilChanged((prev, curr) => {\n          if (prev && prev.time === ensureNotFalsy(curr).time) {\n            return true;\n          } else {\n            return false;\n          }\n        }), filter(result => !!result),\n        /**\n         * Map the result set to a single RxDocument or an array,\n         * depending on query type\n         */\n        map(result => {\n          var useResult = ensureNotFalsy(result);\n          if (this.op === 'count') {\n            return useResult.count;\n          } else if (this.op === 'findOne') {\n            // findOne()-queries emit RxDocument or null\n            return useResult.docs.length === 0 ? null : useResult.docs[0];\n          } else if (this.op === 'findByIds') {\n            return useResult.docsMap;\n          } else {\n            // find()-queries emit RxDocument[]\n            // Flat copy the array so it won't matter if the user modifies it.\n            return useResult.docs.slice(0);\n          }\n        }));\n        this._$ = merge(results$,\n        /**\n         * Also add the refCount$ to the query observable\n         * to allow us to count the amount of subscribers.\n         */\n        this.refCount$.pipe(filter(() => false)));\n      }\n      return this._$;\n    }\n\n    // stores the changeEvent-number of the last handled change-event\n\n    // time stamps on when the last full exec over the database has run\n    // used to properly handle events that happen while the find-query is running\n    /**\n     * ensures that the exec-runs\n     * are not run in parallel\n     */\n  }, {\n    key: \"queryMatcher\",\n    get: function () {\n      var schema = this.collection.schema.jsonSchema;\n      var normalizedQuery = normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery);\n      return overwriteGetterForCaching(this, 'queryMatcher', getQueryMatcher(schema, normalizedQuery));\n    }\n  }, {\n    key: \"asRxQuery\",\n    get: function () {\n      return this;\n    }\n  }]);\n  return RxQueryBase;\n}();\nexport function _getDefaultQuery() {\n  return {\n    selector: {}\n  };\n}\n\n/**\n * run this query through the QueryCache\n */\nexport function tunnelQueryCache(rxQuery) {\n  return rxQuery.collection._queryCache.getByQuery(rxQuery);\n}\nexport function createRxQuery(op, queryObj, collection, other) {\n  runPluginHooks('preCreateRxQuery', {\n    op,\n    queryObj,\n    collection,\n    other\n  });\n  var ret = new RxQueryBase(op, queryObj, collection, other);\n\n  // ensure when created with same params, only one is created\n  ret = tunnelQueryCache(ret);\n  triggerCacheReplacement(collection);\n  return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery) {\n  var currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.counter;\n  if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nfunction _ensureEqual(rxQuery) {\n  // Optimisation shortcut\n  if (rxQuery.collection.database.destroyed || _isResultsInSync(rxQuery)) {\n    return PROMISE_RESOLVE_FALSE;\n  }\n  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(() => __ensureEqual(rxQuery));\n  return rxQuery._ensureEqualQueue;\n}\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nfunction __ensureEqual(rxQuery) {\n  rxQuery._lastEnsureEqual = now();\n\n  /**\n   * Optimisation shortcuts\n   */\n  if (\n  // db is closed\n  rxQuery.collection.database.destroyed ||\n  // nothing happened since last run\n  _isResultsInSync(rxQuery)) {\n    return PROMISE_RESOLVE_FALSE;\n  }\n  var ret = false;\n  var mustReExec = false; // if this becomes true, a whole execution over the database is made\n  if (rxQuery._latestChangeEvent === -1) {\n    // have not executed yet -> must run\n    mustReExec = true;\n  }\n\n  /**\n   * try to use EventReduce to calculate the new results\n   */\n  if (!mustReExec) {\n    var missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n    if (missedChangeEvents === null) {\n      // changeEventBuffer is of bounds -> we must re-execute over the database\n      mustReExec = true;\n    } else {\n      rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.counter;\n      var runChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);\n      if (rxQuery.op === 'count') {\n        // 'count' query\n        var previousCount = ensureNotFalsy(rxQuery._result).count;\n        var newCount = previousCount;\n        runChangeEvents.forEach(cE => {\n          var didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);\n          var doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);\n          if (!didMatchBefore && doesMatchNow) {\n            newCount++;\n          }\n          if (didMatchBefore && !doesMatchNow) {\n            newCount--;\n          }\n        });\n        if (newCount !== previousCount) {\n          ret = true; // true because results changed\n          rxQuery._setResultData(newCount);\n        }\n      } else {\n        // 'find' or 'findOne' query\n        var eventReduceResult = calculateNewResults(rxQuery, runChangeEvents);\n        if (eventReduceResult.runFullQueryAgain) {\n          // could not calculate the new results, execute must be done\n          mustReExec = true;\n        } else if (eventReduceResult.changed) {\n          // we got the new results, we do not have to re-execute, mustReExec stays false\n          ret = true; // true because results changed\n          rxQuery._setResultData(eventReduceResult.newResults);\n        }\n      }\n    }\n  }\n\n  // oh no we have to re-execute the whole query over the database\n  if (mustReExec) {\n    // counter can change while _execOverDatabase() is running so we save it here\n    var latestAfter = rxQuery.collection._changeEventBuffer.counter;\n    return rxQuery._execOverDatabase().then(newResultData => {\n      rxQuery._latestChangeEvent = latestAfter;\n\n      // A count query needs a different has-changed check.\n      if (typeof newResultData === 'number') {\n        if (!rxQuery._result || newResultData !== rxQuery._result.count) {\n          ret = true;\n          rxQuery._setResultData(newResultData);\n        }\n        return ret;\n      }\n      if (!rxQuery._result || !areRxDocumentArraysEqual(rxQuery.collection.schema.primaryPath, newResultData, rxQuery._result.docsData)) {\n        ret = true; // true because results changed\n        rxQuery._setResultData(newResultData);\n      }\n      return ret;\n    });\n  }\n  return Promise.resolve(ret); // true if results have changed\n}\n\n/**\n * Runs the query over the storage instance\n * of the collection.\n * Does some optimizations to ensure findById is used\n * when specific queries are used.\n */\nexport function queryCollection(_x) {\n  return _queryCollection.apply(this, arguments);\n}\n\n/**\n * Returns true if the given query\n * selects exactly one document by its id.\n * Used to optimize performance because these kind of\n * queries do not have to run over an index and can use get-by-id instead.\n * Returns false if no query of that kind.\n * Returns the document id otherwise.\n */\nfunction _queryCollection() {\n  _queryCollection = _asyncToGenerator(function* (rxQuery) {\n    var docs = [];\n    var collection = rxQuery.collection;\n\n    /**\n     * Optimizations shortcut.\n     * If query is find-one-document-by-id,\n     * then we do not have to use the slow query() method\n     * but instead can use findDocumentsById()\n     */\n    if (rxQuery.isFindOneByIdQuery) {\n      if (Array.isArray(rxQuery.isFindOneByIdQuery)) {\n        var docIds = rxQuery.isFindOneByIdQuery;\n        docIds = docIds.filter(docId => {\n          // first try to fill from docCache\n          var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n          if (docData) {\n            docs.push(docData);\n            return false;\n          } else {\n            return true;\n          }\n        });\n        // otherwise get from storage\n        var docsMap = yield collection.storageInstance.findDocumentsById(docIds, false);\n        Object.values(docsMap).forEach(docData => {\n          docs.push(docData);\n        });\n      } else {\n        var docId = rxQuery.isFindOneByIdQuery;\n\n        // first try to fill from docCache\n        var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n        if (!docData) {\n          // otherwise get from storage\n          var _docsMap = yield collection.storageInstance.findDocumentsById([docId], false);\n          docData = _docsMap[docId];\n        }\n        if (docData) {\n          docs.push(docData);\n        }\n      }\n    } else {\n      var preparedQuery = rxQuery.getPreparedQuery();\n      var queryResult = yield collection.storageInstance.query(preparedQuery);\n      docs = queryResult.documents;\n    }\n    return docs;\n  });\n  return _queryCollection.apply(this, arguments);\n}\nexport function isFindOneByIdQuery(primaryPath, query) {\n  // must have exactly one operator which must be $eq || $in\n  if (!query.skip && query.selector && Object.keys(query.selector).length === 1 && query.selector[primaryPath]) {\n    var value = query.selector[primaryPath];\n    if (typeof value === 'string') {\n      return value;\n    } else if (Object.keys(value).length === 1 && typeof value.$eq === 'string') {\n      return value.$eq;\n    }\n\n    // same with $in string arrays\n    if (Object.keys(value).length === 1 && Array.isArray(value.$eq) &&\n    // must only contain strings\n    !value.$eq.find(r => typeof r !== 'string')) {\n      return value.$eq;\n    }\n  }\n  return false;\n}\nexport function isRxQuery(obj) {\n  return obj instanceof RxQueryBase;\n}","map":{"version":3,"names":["_createClass","BehaviorSubject","firstValueFrom","merge","mergeMap","filter","map","startWith","distinctUntilChanged","shareReplay","sortObject","stringifyFilter","pluginMissing","overwriteGetterForCaching","now","PROMISE_RESOLVE_FALSE","RXJS_SHARE_REPLAY_DEFAULTS","ensureNotFalsy","areRxDocumentArraysEqual","newRxError","runPluginHooks","calculateNewResults","triggerCacheReplacement","getQueryMatcher","normalizeMangoQuery","_queryCount","newQueryID","RxQueryBase","op","mangoQuery","collection","other","id","_execOverDatabaseCount","_creationTime","_lastEnsureEqual","uncached","refCount$","_result","_latestChangeEvent","_lastExecStart","_lastExecEnd","_ensureEqualQueue","_getDefaultQuery","isFindOneByIdQuery","schema","primaryPath","_proto","prototype","_setResultData","newResultData","docsData","docsMap","Map","docsDataMap","count","docs","time","Array","from","values","docData","_docCache","getCachedRxDocument","doc","set","primary","_data","length","_execOverDatabase","_execOverDatabase2","_asyncToGenerator","preparedQuery","getPreparedQuery","result","storageInstance","mode","database","allowSlowCount","queryObj","ids","selector","$in","ret","mustBeQueried","forEach","getLatestDocumentDataIfExists","_deleted","push","findDocumentsById","Object","docsPromise","queryCollection","then","apply","arguments","exec","throwIfMissing","name","query","_ensureEqual","$","toString","stringObj","value","JSON","stringify","hookInput","rxQuery","jsonSchema","storage","statics","prepareQuery","doesDocumentDataMatch","queryMatcher","remove","isArray","Promise","all","update","_updateObj","where","_queryObj","sort","_params","skip","_amount","limit","key","get","_$","results$","pipe","changeEvent","isLocal","prev","curr","useResult","slice","normalizedQuery","tunnelQueryCache","_queryCache","getByQuery","createRxQuery","_isResultsInSync","currentLatestEventNumber","asRxQuery","_changeEventBuffer","counter","destroyed","__ensureEqual","mustReExec","missedChangeEvents","getFrom","runChangeEvents","reduceByLastOfDoc","previousCount","newCount","cE","didMatchBefore","previousDocumentData","doesMatchNow","documentData","eventReduceResult","runFullQueryAgain","changed","newResults","latestAfter","resolve","_x","_queryCollection","docIds","docId","_docsMap","queryResult","documents","keys","$eq","find","r","isRxQuery","obj"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/rx-query.js"],"sourcesContent":["import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { BehaviorSubject, firstValueFrom, merge } from 'rxjs';\nimport { mergeMap, filter, map, startWith, distinctUntilChanged, shareReplay } from 'rxjs/operators';\nimport { sortObject, stringifyFilter, pluginMissing, overwriteGetterForCaching, now, PROMISE_RESOLVE_FALSE, RXJS_SHARE_REPLAY_DEFAULTS, ensureNotFalsy, areRxDocumentArraysEqual } from './plugins/utils';\nimport { newRxError } from './rx-error';\nimport { runPluginHooks } from './hooks';\nimport { calculateNewResults } from './event-reduce';\nimport { triggerCacheReplacement } from './query-cache';\nimport { getQueryMatcher, normalizeMangoQuery } from './rx-query-helper';\nvar _queryCount = 0;\nvar newQueryID = function () {\n  return ++_queryCount;\n};\nexport var RxQueryBase = /*#__PURE__*/function () {\n  /**\n   * Some stats then are used for debugging and cache replacement policies\n   */\n\n  // used in the query-cache to determine if the RxQuery can be cleaned up.\n\n  // used to count the subscribers to the query\n\n  /**\n   * Contains the current result state\n   * or null if query has not run yet.\n   */\n\n  function RxQueryBase(op, mangoQuery, collection,\n  // used by some plugins\n  other = {}) {\n    this.id = newQueryID();\n    this._execOverDatabaseCount = 0;\n    this._creationTime = now();\n    this._lastEnsureEqual = 0;\n    this.uncached = false;\n    this.refCount$ = new BehaviorSubject(null);\n    this._result = null;\n    this._latestChangeEvent = -1;\n    this._lastExecStart = 0;\n    this._lastExecEnd = 0;\n    this._ensureEqualQueue = PROMISE_RESOLVE_FALSE;\n    this.op = op;\n    this.mangoQuery = mangoQuery;\n    this.collection = collection;\n    this.other = other;\n    if (!mangoQuery) {\n      this.mangoQuery = _getDefaultQuery();\n    }\n    this.isFindOneByIdQuery = isFindOneByIdQuery(this.collection.schema.primaryPath, mangoQuery);\n  }\n  var _proto = RxQueryBase.prototype;\n  /**\n   * Returns an observable that emits the results\n   * This should behave like an rxjs-BehaviorSubject which means:\n   * - Emit the current result-set on subscribe\n   * - Emit the new result-set when an RxChangeEvent comes in\n   * - Do not emit anything before the first result-set was created (no null)\n   */\n  /**\n   * set the new result-data as result-docs of the query\n   * @param newResultData json-docs that were received from the storage\n   */\n  _proto._setResultData = function _setResultData(newResultData) {\n    if (typeof newResultData === 'number') {\n      this._result = {\n        docsData: [],\n        docsMap: new Map(),\n        docsDataMap: new Map(),\n        count: newResultData,\n        docs: [],\n        time: now()\n      };\n      return;\n    } else if (newResultData instanceof Map) {\n      newResultData = Array.from(newResultData.values());\n    }\n    var docsDataMap = new Map();\n    var docsMap = new Map();\n    var docs = newResultData.map(docData => this.collection._docCache.getCachedRxDocument(docData));\n\n    /**\n     * Instead of using the newResultData in the result cache,\n     * we directly use the objects that are stored in the RxDocument\n     * to ensure we do not store the same data twice and fill up the memory.\n     */\n    var docsData = docs.map(doc => {\n      docsDataMap.set(doc.primary, doc._data);\n      docsMap.set(doc.primary, doc);\n      return doc._data;\n    });\n    this._result = {\n      docsData,\n      docsMap,\n      docsDataMap,\n      count: docsData.length,\n      docs,\n      time: now()\n    };\n  }\n\n  /**\n   * executes the query on the database\n   * @return results-array with document-data\n   */;\n  _proto._execOverDatabase = async function _execOverDatabase() {\n    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n    this._lastExecStart = now();\n    if (this.op === 'count') {\n      var preparedQuery = this.getPreparedQuery();\n      var result = await this.collection.storageInstance.count(preparedQuery);\n      if (result.mode === 'slow' && !this.collection.database.allowSlowCount) {\n        throw newRxError('QU14', {\n          collection: this.collection,\n          queryObj: this.mangoQuery\n        });\n      } else {\n        return result.count;\n      }\n    }\n    if (this.op === 'findByIds') {\n      var ids = ensureNotFalsy(this.mangoQuery.selector)[this.collection.schema.primaryPath].$in;\n      var ret = new Map();\n      var mustBeQueried = [];\n      // first try to fill from docCache\n      ids.forEach(id => {\n        var docData = this.collection._docCache.getLatestDocumentDataIfExists(id);\n        if (docData) {\n          if (!docData._deleted) {\n            var doc = this.collection._docCache.getCachedRxDocument(docData);\n            ret.set(id, doc);\n          }\n        } else {\n          mustBeQueried.push(id);\n        }\n      });\n      // everything which was not in docCache must be fetched from the storage\n      if (mustBeQueried.length > 0) {\n        var docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);\n        Object.values(docs).forEach(docData => {\n          var doc = this.collection._docCache.getCachedRxDocument(docData);\n          ret.set(doc.primary, doc);\n        });\n      }\n      return ret;\n    }\n    var docsPromise = queryCollection(this);\n    return docsPromise.then(docs => {\n      this._lastExecEnd = now();\n      return docs;\n    });\n  }\n\n  /**\n   * Execute the query\n   * To have an easier implementations,\n   * just subscribe and use the first result\n   */;\n  _proto.exec = function exec(throwIfMissing) {\n    if (throwIfMissing && this.op !== 'findOne') {\n      throw newRxError('QU9', {\n        collection: this.collection.name,\n        query: this.mangoQuery,\n        op: this.op\n      });\n    }\n\n    /**\n     * run _ensureEqual() here,\n     * this will make sure that errors in the query which throw inside of the RxStorage,\n     * will be thrown at this execution context and not in the background.\n     */\n    return _ensureEqual(this).then(() => firstValueFrom(this.$)).then(result => {\n      if (!result && throwIfMissing) {\n        throw newRxError('QU10', {\n          collection: this.collection.name,\n          query: this.mangoQuery,\n          op: this.op\n        });\n      } else {\n        return result;\n      }\n    });\n  }\n\n  /**\n   * cached call to get the queryMatcher\n   * @overwrites itself with the actual value\n   */;\n  /**\n   * returns a string that is used for equal-comparisons\n   * @overwrites itself with the actual value\n   */\n  _proto.toString = function toString() {\n    var stringObj = sortObject({\n      op: this.op,\n      query: this.mangoQuery,\n      other: this.other\n    }, true);\n    var value = JSON.stringify(stringObj, stringifyFilter);\n    this.toString = () => value;\n    return value;\n  }\n\n  /**\n   * returns the prepared query\n   * which can be send to the storage instance to query for documents.\n   * @overwrites itself with the actual value.\n   */;\n  _proto.getPreparedQuery = function getPreparedQuery() {\n    var hookInput = {\n      rxQuery: this,\n      // can be mutated by the hooks so we have to deep clone first.\n      mangoQuery: normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery)\n    };\n    runPluginHooks('prePrepareQuery', hookInput);\n    var value = this.collection.database.storage.statics.prepareQuery(this.collection.schema.jsonSchema, hookInput.mangoQuery);\n    this.getPreparedQuery = () => value;\n    return value;\n  }\n\n  /**\n   * returns true if the document matches the query,\n   * does not use the 'skip' and 'limit'\n   */;\n  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {\n    // if doc is deleted, it cannot match\n    if (docData._deleted) {\n      return false;\n    }\n    return this.queryMatcher(docData);\n  }\n\n  /**\n   * deletes all found documents\n   * @return promise with deleted documents\n   */;\n  _proto.remove = function remove() {\n    return this.exec().then(docs => {\n      if (Array.isArray(docs)) {\n        // TODO use a bulk operation instead of running .remove() on each document\n        return Promise.all(docs.map(doc => doc.remove()));\n      } else {\n        return docs.remove();\n      }\n    });\n  }\n\n  /**\n   * helper function to transform RxQueryBase to RxQuery type\n   */;\n  /**\n   * updates all found documents\n   * @overwritten by plugin (optional)\n   */\n  _proto.update = function update(_updateObj) {\n    throw pluginMissing('update');\n  }\n\n  // we only set some methods of query-builder here\n  // because the others depend on these ones\n  ;\n  _proto.where = function where(_queryObj) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.sort = function sort(_params) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.skip = function skip(_amount) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.limit = function limit(_amount) {\n    throw pluginMissing('query-builder');\n  };\n  _createClass(RxQueryBase, [{\n    key: \"$\",\n    get: function () {\n      if (!this._$) {\n        var results$ = this.collection.$.pipe(\n        /**\n         * Performance shortcut.\n         * Changes to local documents are not relevant for the query.\n         */\n        filter(changeEvent => !changeEvent.isLocal),\n        /**\n         * Start once to ensure the querying also starts\n         * when there where no changes.\n         */\n        startWith(null),\n        // ensure query results are up to date.\n        mergeMap(() => _ensureEqual(this)),\n        // use the current result set, written by _ensureEqual().\n        map(() => this._result),\n        // do not run stuff above for each new subscriber, only once.\n        shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),\n        // do not proceed if result set has not changed.\n        distinctUntilChanged((prev, curr) => {\n          if (prev && prev.time === ensureNotFalsy(curr).time) {\n            return true;\n          } else {\n            return false;\n          }\n        }), filter(result => !!result),\n        /**\n         * Map the result set to a single RxDocument or an array,\n         * depending on query type\n         */\n        map(result => {\n          var useResult = ensureNotFalsy(result);\n          if (this.op === 'count') {\n            return useResult.count;\n          } else if (this.op === 'findOne') {\n            // findOne()-queries emit RxDocument or null\n            return useResult.docs.length === 0 ? null : useResult.docs[0];\n          } else if (this.op === 'findByIds') {\n            return useResult.docsMap;\n          } else {\n            // find()-queries emit RxDocument[]\n            // Flat copy the array so it won't matter if the user modifies it.\n            return useResult.docs.slice(0);\n          }\n        }));\n        this._$ = merge(results$,\n        /**\n         * Also add the refCount$ to the query observable\n         * to allow us to count the amount of subscribers.\n         */\n        this.refCount$.pipe(filter(() => false)));\n      }\n      return this._$;\n    }\n\n    // stores the changeEvent-number of the last handled change-event\n\n    // time stamps on when the last full exec over the database has run\n    // used to properly handle events that happen while the find-query is running\n    /**\n     * ensures that the exec-runs\n     * are not run in parallel\n     */\n  }, {\n    key: \"queryMatcher\",\n    get: function () {\n      var schema = this.collection.schema.jsonSchema;\n      var normalizedQuery = normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery);\n      return overwriteGetterForCaching(this, 'queryMatcher', getQueryMatcher(schema, normalizedQuery));\n    }\n  }, {\n    key: \"asRxQuery\",\n    get: function () {\n      return this;\n    }\n  }]);\n  return RxQueryBase;\n}();\nexport function _getDefaultQuery() {\n  return {\n    selector: {}\n  };\n}\n\n/**\n * run this query through the QueryCache\n */\nexport function tunnelQueryCache(rxQuery) {\n  return rxQuery.collection._queryCache.getByQuery(rxQuery);\n}\nexport function createRxQuery(op, queryObj, collection, other) {\n  runPluginHooks('preCreateRxQuery', {\n    op,\n    queryObj,\n    collection,\n    other\n  });\n  var ret = new RxQueryBase(op, queryObj, collection, other);\n\n  // ensure when created with same params, only one is created\n  ret = tunnelQueryCache(ret);\n  triggerCacheReplacement(collection);\n  return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery) {\n  var currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.counter;\n  if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nfunction _ensureEqual(rxQuery) {\n  // Optimisation shortcut\n  if (rxQuery.collection.database.destroyed || _isResultsInSync(rxQuery)) {\n    return PROMISE_RESOLVE_FALSE;\n  }\n  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(() => __ensureEqual(rxQuery));\n  return rxQuery._ensureEqualQueue;\n}\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nfunction __ensureEqual(rxQuery) {\n  rxQuery._lastEnsureEqual = now();\n\n  /**\n   * Optimisation shortcuts\n   */\n  if (\n  // db is closed\n  rxQuery.collection.database.destroyed ||\n  // nothing happened since last run\n  _isResultsInSync(rxQuery)) {\n    return PROMISE_RESOLVE_FALSE;\n  }\n  var ret = false;\n  var mustReExec = false; // if this becomes true, a whole execution over the database is made\n  if (rxQuery._latestChangeEvent === -1) {\n    // have not executed yet -> must run\n    mustReExec = true;\n  }\n\n  /**\n   * try to use EventReduce to calculate the new results\n   */\n  if (!mustReExec) {\n    var missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n    if (missedChangeEvents === null) {\n      // changeEventBuffer is of bounds -> we must re-execute over the database\n      mustReExec = true;\n    } else {\n      rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.counter;\n      var runChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);\n      if (rxQuery.op === 'count') {\n        // 'count' query\n        var previousCount = ensureNotFalsy(rxQuery._result).count;\n        var newCount = previousCount;\n        runChangeEvents.forEach(cE => {\n          var didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);\n          var doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);\n          if (!didMatchBefore && doesMatchNow) {\n            newCount++;\n          }\n          if (didMatchBefore && !doesMatchNow) {\n            newCount--;\n          }\n        });\n        if (newCount !== previousCount) {\n          ret = true; // true because results changed\n          rxQuery._setResultData(newCount);\n        }\n      } else {\n        // 'find' or 'findOne' query\n        var eventReduceResult = calculateNewResults(rxQuery, runChangeEvents);\n        if (eventReduceResult.runFullQueryAgain) {\n          // could not calculate the new results, execute must be done\n          mustReExec = true;\n        } else if (eventReduceResult.changed) {\n          // we got the new results, we do not have to re-execute, mustReExec stays false\n          ret = true; // true because results changed\n          rxQuery._setResultData(eventReduceResult.newResults);\n        }\n      }\n    }\n  }\n\n  // oh no we have to re-execute the whole query over the database\n  if (mustReExec) {\n    // counter can change while _execOverDatabase() is running so we save it here\n    var latestAfter = rxQuery.collection._changeEventBuffer.counter;\n    return rxQuery._execOverDatabase().then(newResultData => {\n      rxQuery._latestChangeEvent = latestAfter;\n\n      // A count query needs a different has-changed check.\n      if (typeof newResultData === 'number') {\n        if (!rxQuery._result || newResultData !== rxQuery._result.count) {\n          ret = true;\n          rxQuery._setResultData(newResultData);\n        }\n        return ret;\n      }\n      if (!rxQuery._result || !areRxDocumentArraysEqual(rxQuery.collection.schema.primaryPath, newResultData, rxQuery._result.docsData)) {\n        ret = true; // true because results changed\n        rxQuery._setResultData(newResultData);\n      }\n      return ret;\n    });\n  }\n  return Promise.resolve(ret); // true if results have changed\n}\n\n/**\n * Runs the query over the storage instance\n * of the collection.\n * Does some optimizations to ensure findById is used\n * when specific queries are used.\n */\nexport async function queryCollection(rxQuery) {\n  var docs = [];\n  var collection = rxQuery.collection;\n\n  /**\n   * Optimizations shortcut.\n   * If query is find-one-document-by-id,\n   * then we do not have to use the slow query() method\n   * but instead can use findDocumentsById()\n   */\n  if (rxQuery.isFindOneByIdQuery) {\n    if (Array.isArray(rxQuery.isFindOneByIdQuery)) {\n      var docIds = rxQuery.isFindOneByIdQuery;\n      docIds = docIds.filter(docId => {\n        // first try to fill from docCache\n        var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n        if (docData) {\n          docs.push(docData);\n          return false;\n        } else {\n          return true;\n        }\n      });\n      // otherwise get from storage\n      var docsMap = await collection.storageInstance.findDocumentsById(docIds, false);\n      Object.values(docsMap).forEach(docData => {\n        docs.push(docData);\n      });\n    } else {\n      var docId = rxQuery.isFindOneByIdQuery;\n\n      // first try to fill from docCache\n      var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n      if (!docData) {\n        // otherwise get from storage\n        var _docsMap = await collection.storageInstance.findDocumentsById([docId], false);\n        docData = _docsMap[docId];\n      }\n      if (docData) {\n        docs.push(docData);\n      }\n    }\n  } else {\n    var preparedQuery = rxQuery.getPreparedQuery();\n    var queryResult = await collection.storageInstance.query(preparedQuery);\n    docs = queryResult.documents;\n  }\n  return docs;\n}\n\n/**\n * Returns true if the given query\n * selects exactly one document by its id.\n * Used to optimize performance because these kind of\n * queries do not have to run over an index and can use get-by-id instead.\n * Returns false if no query of that kind.\n * Returns the document id otherwise.\n */\nexport function isFindOneByIdQuery(primaryPath, query) {\n  // must have exactly one operator which must be $eq || $in\n  if (!query.skip && query.selector && Object.keys(query.selector).length === 1 && query.selector[primaryPath]) {\n    var value = query.selector[primaryPath];\n    if (typeof value === 'string') {\n      return value;\n    } else if (Object.keys(value).length === 1 && typeof value.$eq === 'string') {\n      return value.$eq;\n    }\n\n    // same with $in string arrays\n    if (Object.keys(value).length === 1 && Array.isArray(value.$eq) &&\n    // must only contain strings\n    !value.$eq.find(r => typeof r !== 'string')) {\n      return value.$eq;\n    }\n  }\n  return false;\n}\nexport function isRxQuery(obj) {\n  return obj instanceof RxQueryBase;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}