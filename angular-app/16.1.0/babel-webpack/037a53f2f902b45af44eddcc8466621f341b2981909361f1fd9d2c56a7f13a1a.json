{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { InjectionToken } from '@angular/core';\nimport { createRxDatabase } from 'rxdb';\nimport { getRxStorageDexie } from 'rxdb/dist/types/plugins/storage-dexie';\nimport { learnerSchema } from './model/identity';\nimport { nuggetSchema } from './model/nugget';\nimport * as i0 from \"@angular/core\";\nexport const APP_STORAGE = new InjectionToken('APP_STORAGE');\nexport const IDENTITY_TABLE = 'identity';\nexport const NUGGET_TABLE = 'nugget';\nclass LocalStorageService {\n  constructor() {\n    this._init().then(() => {\n      console.log(\"Initialised database\");\n    });\n  }\n  _init() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this._database = yield createRxDatabase({\n        name: 'offlinestore',\n        storage: getRxStorageDexie(),\n        cleanupPolicy: {\n          /**\n           * The minimum time in milliseconds for how long\n           * a document has to be deleted before it is\n           * purged by the cleanup.\n           * [default=one month]\n           */\n          minimumDeletedTime: 1000 * 60 * 60 * 24 * 31,\n          /**\n           * The minimum amount of that that the RxCollection must have existed.\n           * This ensures that at the initial page load, more important\n           * tasks are not slowed down because a cleanup process is running.\n           * [default=60 seconds]\n           */\n          minimumCollectionAge: 1000 * 60,\n          /**\n           * After the initial cleanup is done,\n           * a new cleanup is started after [runEach] milliseconds\n           * [default=5 minutes]\n           */\n          runEach: 1000 * 60 * 5,\n          /**\n           * If set to true,\n           * RxDB will await all running replications\n           * to not have a replication cycle running.\n           * This ensures we do not remove deleted documents\n           * when they might not have already been replicated.\n           * [default=true]\n           */\n          awaitReplicationsInSync: true,\n          /**\n           * If true, it will only start the cleanup\n           * when the current instance is also the leader.\n           * This ensures that when RxDB is used in multiInstance mode,\n           * only one instance will start the cleanup.\n           * [default=true]\n           */\n          waitForLeadership: true\n        }\n      });\n      yield _this._database.addCollections({\n        identity: {\n          schema: learnerSchema\n        },\n        nugget: {\n          schema: nuggetSchema\n        }\n      });\n    })();\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Getter for database\n   */\n  get database() {\n    return this._database;\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be inserted.\n   * @param body - The data object representing the record to be inserted.\n   * @returns A Promise that resolves to void once the record has been successfully inserted.\n   *\n   * @example\n   * await post('orders', { id: 1, product: 'Phone', quantity: 2 });\n   * // Inserts a new record into the 'orders' table with the provided data.\n   */\n  post(table, body) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2.database[table].insert(body);\n    })();\n  }\n  /**\n   * Retrieves a record from the specified table in the local offline storage based on the provided ID.\n   *\n   * @param table - The name of the table from which the record will be retrieved.\n   * @param id - The ID of the record to be retrieved.\n   * @returns A Promise that resolves to the retrieved record.\n   *\n   * @example\n   * const order = await get('orders', '456');\n   * // Retrieves the record with ID '456' from the 'orders' table.\n   */\n  get(table, id) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3.database[table].findOne(id).exec();\n    })();\n  }\n  /**\n   * Retrieves an Observable stream of records from the specified table in the local offline storage.\n   *\n   * @param table - The name of the table from which the records will be retrieved.\n   * @returns An Observable that emits the records from the specified table.\n   *\n   * @example\n   * // Example usage:\n   * const users$ = get$('users');\n   * users$.subscribe((users) => {\n   *   console.log(users);\n   * });\n   * // Retrieves the records from the 'users' table and logs the emitted records whenever there is an update.\n   *\n   * @example\n   * // Example usage with async pipe:\n   * const orders$ = get$('orders');\n   * // In Angular template:\n   * <ng-container *ngIf=\"(orders$ | async) as orders\">\n   *   <!-- Display orders -->\n   * </ng-container>\n   * // Retrieves the records from the 'orders' table and uses the async pipe to subscribe to the Observable and handle the emitted values in the template.\n   */\n  get$(table) {\n    return this.database[table].$;\n  }\n  /**\n   * Updates an existing record or inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be updated or inserted.\n   * @param body - The data object representing the record to be updated or inserted.\n   * @returns A Promise that resolves to void once the record has been successfully updated or inserted.\n   *\n   * @example\n   * await put('users', { id: '123', name: 'John Doe', age: 30 });\n   * // Updates the record with ID '123' in the 'users' table if it exists, or inserts a new record with the provided data if the record doesn't exist.\n   */\n  put(table, body) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      yield _this4.database[table].upsert(body);\n    })();\n  }\n  /**\n   * DELETE\n   */\n  delete() {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * REMOVE\n   */\n  deleteCollection(table) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      yield _this5.database[table].remove();\n    })();\n  }\n  /**\n   * Destroy\n   */\n  destroyCollection(table) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      yield _this6.database[table].destroy();\n    })();\n  }\n}\nLocalStorageService.ɵfac = function LocalStorageService_Factory(t) {\n  return new (t || LocalStorageService)();\n};\nLocalStorageService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: LocalStorageService,\n  factory: LocalStorageService.ɵfac,\n  providedIn: 'root'\n});\nexport { LocalStorageService };","map":{"version":3,"names":["InjectionToken","createRxDatabase","getRxStorageDexie","learnerSchema","nuggetSchema","APP_STORAGE","IDENTITY_TABLE","NUGGET_TABLE","LocalStorageService","constructor","_init","then","console","log","_this","_asyncToGenerator","_database","name","storage","cleanupPolicy","minimumDeletedTime","minimumCollectionAge","runEach","awaitReplicationsInSync","waitForLeadership","addCollections","identity","schema","nugget","database","post","table","body","_this2","insert","get","id","_this3","findOne","exec","get$","$","put","_this4","upsert","delete","deleteCollection","_this5","remove","destroyCollection","_this6","destroy","factory","ɵfac","providedIn"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/src/app/data/local-storage.ts"],"sourcesContent":["import { Injectable, InjectionToken } from '@angular/core';\nimport { RxDatabase, createRxDatabase } from 'rxdb';\nimport { getRxStorageDexie } from 'rxdb/dist/types/plugins/storage-dexie';\nimport { learnerSchema } from './model/identity';\nimport { v4 } from 'uuid';\nimport { nuggetSchema } from './model/nugget';\nimport { Observable } from 'rxjs';\n\nexport const APP_STORAGE = new InjectionToken<any>('APP_STORAGE');\nexport const IDENTITY_TABLE = 'identity';\nexport const NUGGET_TABLE = 'nugget';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocalStorageService {\n  // private _database: BehaviorSubject<any>;\n  private _database: RxDatabase | undefined;\n\n  constructor() {\n    this._init().then(() => {\n      console.log(\"Initialised database\")\n    })\n  }\n\n  async _init() {\n    this._database = await createRxDatabase({\n      name: 'offlinestore',\n      storage: getRxStorageDexie(),\n      cleanupPolicy: {\n        /**\n         * The minimum time in milliseconds for how long\n         * a document has to be deleted before it is\n         * purged by the cleanup.\n         * [default=one month]\n         */\n        minimumDeletedTime: 1000 * 60 * 60 * 24 * 31, // one month,\n        /**\n         * The minimum amount of that that the RxCollection must have existed.\n         * This ensures that at the initial page load, more important\n         * tasks are not slowed down because a cleanup process is running.\n         * [default=60 seconds]\n         */\n        minimumCollectionAge: 1000 * 60, // 60 seconds\n        /**\n         * After the initial cleanup is done,\n         * a new cleanup is started after [runEach] milliseconds\n         * [default=5 minutes]\n         */\n        runEach: 1000 * 60 * 5, // 5 minutes\n        /**\n         * If set to true,\n         * RxDB will await all running replications\n         * to not have a replication cycle running.\n         * This ensures we do not remove deleted documents\n         * when they might not have already been replicated.\n         * [default=true]\n         */\n        awaitReplicationsInSync: true,\n        /**\n         * If true, it will only start the cleanup\n         * when the current instance is also the leader.\n         * This ensures that when RxDB is used in multiInstance mode,\n         * only one instance will start the cleanup.\n         * [default=true]\n         */\n        waitForLeadership: true\n      }\n    });\n\n    await this._database.addCollections({\n      identity: {\n        schema: learnerSchema\n      },\n      nugget: {\n        schema: nuggetSchema\n      }\n    });\n  }\n\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n\n  /**\n   * Getter for database\n   */\n  get database(): RxDatabase {\n    return this._database as RxDatabase;\n  }\n\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n\n  /**\n   * Inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be inserted.\n   * @param body - The data object representing the record to be inserted.\n   * @returns A Promise that resolves to void once the record has been successfully inserted.\n   *\n   * @example\n   * await post('orders', { id: 1, product: 'Phone', quantity: 2 });\n   * // Inserts a new record into the 'orders' table with the provided data.\n   */\n  async post(table: string, body: any): Promise<void> {\n    await this.database[table].insert(body);\n  }\n\n  /**\n   * Retrieves a record from the specified table in the local offline storage based on the provided ID.\n   *\n   * @param table - The name of the table from which the record will be retrieved.\n   * @param id - The ID of the record to be retrieved.\n   * @returns A Promise that resolves to the retrieved record.\n   *\n   * @example\n   * const order = await get('orders', '456');\n   * // Retrieves the record with ID '456' from the 'orders' table.\n   */\n  async get(table: string, id: string): Promise<any> {\n    return this.database[table].findOne(id).exec();\n  }\n\n  /**\n   * Retrieves an Observable stream of records from the specified table in the local offline storage.\n   *\n   * @param table - The name of the table from which the records will be retrieved.\n   * @returns An Observable that emits the records from the specified table.\n   *\n   * @example\n   * // Example usage:\n   * const users$ = get$('users');\n   * users$.subscribe((users) => {\n   *   console.log(users);\n   * });\n   * // Retrieves the records from the 'users' table and logs the emitted records whenever there is an update.\n   *\n   * @example\n   * // Example usage with async pipe:\n   * const orders$ = get$('orders');\n   * // In Angular template:\n   * <ng-container *ngIf=\"(orders$ | async) as orders\">\n   *   <!-- Display orders -->\n   * </ng-container>\n   * // Retrieves the records from the 'orders' table and uses the async pipe to subscribe to the Observable and handle the emitted values in the template.\n   */\n  get$(table: string): Observable<any> {\n    return this.database[table].$;\n  }\n\n  /**\n   * Updates an existing record or inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be updated or inserted.\n   * @param body - The data object representing the record to be updated or inserted.\n   * @returns A Promise that resolves to void once the record has been successfully updated or inserted.\n   *\n   * @example\n   * await put('users', { id: '123', name: 'John Doe', age: 30 });\n   * // Updates the record with ID '123' in the 'users' table if it exists, or inserts a new record with the provided data if the record doesn't exist.\n   */\n  async put(table: string, body: any): Promise<void> {\n    await this.database[table].upsert(body);\n  }\n\n\n  /**\n   * DELETE\n   */\n  async delete(): Promise<void> {\n\n  }\n\n  /**\n   * REMOVE\n   */\n  async deleteCollection(table: string): Promise<void> {\n    await this.database[table].remove();\n  }\n\n  /**\n   * Destroy\n   */\n  async destroyCollection(table: string): Promise<void> {\n    await this.database[table].destroy();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}