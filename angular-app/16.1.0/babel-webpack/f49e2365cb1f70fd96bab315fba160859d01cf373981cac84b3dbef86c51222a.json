{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * This plugin contains the primitives to create\n * a RxDB client-server replication.\n * It is used in the other replication plugins\n * but also can be used as standalone with a custom replication handler.\n */\n\nimport { BehaviorSubject, combineLatest, mergeMap, Subject } from 'rxjs';\nimport { RxDBLeaderElectionPlugin } from '../leader-election';\nimport { ensureNotFalsy, errorToPlainJson, flatClone, getFromMapOrCreate, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_TRUE, toArray } from '../../plugins/utils';\nimport { awaitRxStorageReplicationFirstInSync, awaitRxStorageReplicationInSync, cancelRxStorageReplication, getRxReplicationMetaInstanceSchema, replicateRxStorageInstance } from '../../replication-protocol';\nimport { newRxError } from '../../rx-error';\nimport { awaitRetry, DEFAULT_MODIFIER, swapDefaultDeletedTodeletedField, handlePulledDocuments } from './replication-helper';\nimport { addConnectedStorageToCollection } from '../../rx-database-internal-store';\nimport { addRxPlugin } from '../../plugin';\nimport { hasEncryption } from '../../rx-storage-helper';\nimport { overwritable } from '../../overwritable';\nimport { runAsyncPluginHooks } from '../../hooks';\nexport var REPLICATION_STATE_BY_COLLECTION = new WeakMap();\nexport var RxReplicationState = /*#__PURE__*/function () {\n  function RxReplicationState(\n  /**\n   * hash of the identifier, used to flag revisions\n   * and to identify which documents state came from the remote.\n   */\n  replicationIdentifierHash, collection, deletedField, pull, push, live, retryTime, autoStart) {\n    this.subs = [];\n    this.subjects = {\n      received: new Subject(),\n      // all documents that are received from the endpoint\n      send: new Subject(),\n      // all documents that are send to the endpoint\n      error: new Subject(),\n      // all errors that are received from the endpoint, emits new Error() objects\n      canceled: new BehaviorSubject(false),\n      // true when the replication was canceled\n      active: new BehaviorSubject(false) // true when something is running, false when not\n    };\n\n    this.received$ = this.subjects.received.asObservable();\n    this.send$ = this.subjects.send.asObservable();\n    this.error$ = this.subjects.error.asObservable();\n    this.canceled$ = this.subjects.canceled.asObservable();\n    this.active$ = this.subjects.active.asObservable();\n    this.callOnStart = undefined;\n    this.remoteEvents$ = new Subject();\n    this.replicationIdentifierHash = replicationIdentifierHash;\n    this.collection = collection;\n    this.deletedField = deletedField;\n    this.pull = pull;\n    this.push = push;\n    this.live = live;\n    this.retryTime = retryTime;\n    this.autoStart = autoStart;\n    var replicationStates = getFromMapOrCreate(REPLICATION_STATE_BY_COLLECTION, collection, () => []);\n    replicationStates.push(this);\n\n    // stop the replication when the collection gets destroyed\n    this.collection.onDestroy.push(() => this.cancel());\n\n    // create getters for the observables\n    Object.keys(this.subjects).forEach(key => {\n      Object.defineProperty(this, key + '$', {\n        get: function () {\n          return this.subjects[key].asObservable();\n        }\n      });\n    });\n    var startPromise = new Promise(res => {\n      this.callOnStart = res;\n    });\n    this.startPromise = startPromise;\n  }\n  var _proto = RxReplicationState.prototype;\n  _proto.start = /*#__PURE__*/function () {\n    var _start = _asyncToGenerator(function* () {\n      var _this = this;\n      if (this.isStopped()) {\n        return;\n      }\n\n      // fill in defaults for pull & push\n      var pullModifier = this.pull && this.pull.modifier ? this.pull.modifier : DEFAULT_MODIFIER;\n      var pushModifier = this.push && this.push.modifier ? this.push.modifier : DEFAULT_MODIFIER;\n      var database = this.collection.database;\n      var metaInstanceCollectionName = this.collection.name + '-rx-replication-' + this.replicationIdentifierHash;\n      var metaInstanceSchema = getRxReplicationMetaInstanceSchema(this.collection.schema.jsonSchema, hasEncryption(this.collection.schema.jsonSchema));\n      var [metaInstance] = yield Promise.all([this.collection.database.storage.createStorageInstance({\n        databaseName: database.name,\n        collectionName: metaInstanceCollectionName,\n        databaseInstanceToken: database.token,\n        multiInstance: database.multiInstance,\n        // TODO is this always false?\n        options: {},\n        schema: metaInstanceSchema,\n        password: database.password,\n        devMode: overwritable.isDevMode()\n      }), addConnectedStorageToCollection(this.collection, metaInstanceCollectionName, metaInstanceSchema)]);\n      this.metaInstance = metaInstance;\n      this.internalReplicationState = replicateRxStorageInstance({\n        pushBatchSize: this.push && this.push.batchSize ? this.push.batchSize : 100,\n        pullBatchSize: this.pull && this.pull.batchSize ? this.pull.batchSize : 100,\n        initialCheckpoint: {\n          upstream: this.push ? this.push.initialCheckpoint : undefined,\n          downstream: this.pull ? this.pull.initialCheckpoint : undefined\n        },\n        forkInstance: this.collection.storageInstance,\n        metaInstance: this.metaInstance,\n        hashFunction: database.hashFunction,\n        identifier: 'rxdbreplication' + this.replicationIdentifierHash,\n        conflictHandler: this.collection.conflictHandler,\n        replicationHandler: {\n          masterChangeStream$: this.remoteEvents$.asObservable().pipe(mergeMap( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (ev) {\n              if (ev === 'RESYNC') {\n                return ev;\n              }\n              var useEv = flatClone(ev);\n              useEv.documents = handlePulledDocuments(_this.collection, _this.deletedField, useEv.documents);\n              useEv.documents = yield Promise.all(useEv.documents.map(d => pullModifier(d)));\n              return useEv;\n            });\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }())),\n          masterChangesSince: function () {\n            var _ref2 = _asyncToGenerator(function* (checkpoint, batchSize) {\n              if (!_this.pull) {\n                return {\n                  checkpoint: null,\n                  documents: []\n                };\n              }\n              /**\n               * Retries must be done here in the replication primitives plugin,\n               * because the replication protocol itself has no\n               * error handling.\n               */\n              var done = false;\n              var result = {};\n              while (!done && !_this.isStopped()) {\n                try {\n                  result = yield _this.pull.handler(checkpoint, batchSize);\n                  done = true;\n                } catch (err) {\n                  var emitError = newRxError('RC_PULL', {\n                    checkpoint,\n                    errors: toArray(err).map(er => errorToPlainJson(er)),\n                    direction: 'pull'\n                  });\n                  _this.subjects.error.next(emitError);\n                  yield awaitRetry(_this.collection, ensureNotFalsy(_this.retryTime));\n                }\n              }\n              if (_this.isStopped()) {\n                return {\n                  checkpoint: null,\n                  documents: []\n                };\n              }\n              var useResult = flatClone(result);\n              useResult.documents = handlePulledDocuments(_this.collection, _this.deletedField, useResult.documents);\n              useResult.documents = yield Promise.all(useResult.documents.map(d => pullModifier(d)));\n              return useResult;\n            });\n            return function masterChangesSince(_x2, _x3) {\n              return _ref2.apply(this, arguments);\n            };\n          }(),\n          masterWrite: function () {\n            var _ref3 = _asyncToGenerator(function* (rows) {\n              if (!_this.push) {\n                return [];\n              }\n              var done = false;\n              yield runAsyncPluginHooks('preReplicationMasterWrite', {\n                rows,\n                collection: _this.collection\n              });\n              var useRows = yield Promise.all(rows.map( /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator(function* (row) {\n                  row.newDocumentState = yield pushModifier(row.newDocumentState);\n                  if (row.assumedMasterState) {\n                    row.assumedMasterState = yield pushModifier(row.assumedMasterState);\n                  }\n                  if (_this.deletedField !== '_deleted') {\n                    row.newDocumentState = swapDefaultDeletedTodeletedField(_this.deletedField, row.newDocumentState);\n                    if (row.assumedMasterState) {\n                      row.assumedMasterState = swapDefaultDeletedTodeletedField(_this.deletedField, row.assumedMasterState);\n                    }\n                  }\n                  return row;\n                });\n                return function (_x5) {\n                  return _ref4.apply(this, arguments);\n                };\n              }()));\n              var result = null;\n\n              // In case all the rows have been filtered and nothing has to be sent\n              if (useRows.length === 0) {\n                done = true;\n                result = [];\n              }\n              while (!done && !_this.isStopped()) {\n                try {\n                  result = yield _this.push.handler(useRows);\n                  /**\n                   * It is a common problem that people have wrongly behaving backend\n                   * that do not return an array with the conflicts on push requests.\n                   * So we run this check here to make it easier to debug.\n                   * @link https://github.com/pubkey/rxdb/issues/4103\n                   */\n                  if (!Array.isArray(result)) {\n                    throw newRxError('RC_PUSH_NO_AR', {\n                      pushRows: rows,\n                      direction: 'push',\n                      args: {\n                        result\n                      }\n                    });\n                  }\n                  done = true;\n                } catch (err) {\n                  var emitError = err.rxdb ? err : newRxError('RC_PUSH', {\n                    pushRows: rows,\n                    errors: toArray(err).map(er => errorToPlainJson(er)),\n                    direction: 'push'\n                  });\n                  _this.subjects.error.next(emitError);\n                  yield awaitRetry(_this.collection, ensureNotFalsy(_this.retryTime));\n                }\n              }\n              if (_this.isStopped()) {\n                return [];\n              }\n              yield runAsyncPluginHooks('preReplicationMasterWriteDocumentsHandle', {\n                result,\n                collection: _this.collection\n              });\n              var conflicts = handlePulledDocuments(_this.collection, _this.deletedField, ensureNotFalsy(result));\n              return conflicts;\n            });\n            return function masterWrite(_x4) {\n              return _ref3.apply(this, arguments);\n            };\n          }()\n        }\n      });\n      this.subs.push(this.internalReplicationState.events.error.subscribe(err => {\n        this.subjects.error.next(err);\n      }), this.internalReplicationState.events.processed.down.subscribe(row => this.subjects.received.next(row.document)), this.internalReplicationState.events.processed.up.subscribe(writeToMasterRow => {\n        this.subjects.send.next(writeToMasterRow.newDocumentState);\n      }), combineLatest([this.internalReplicationState.events.active.down, this.internalReplicationState.events.active.up]).subscribe(([down, up]) => {\n        var isActive = down || up;\n        this.subjects.active.next(isActive);\n      }));\n      if (this.pull && this.pull.stream$ && this.live) {\n        this.subs.push(this.pull.stream$.subscribe({\n          next: ev => {\n            this.remoteEvents$.next(ev);\n          },\n          error: err => {\n            this.subjects.error.next(err);\n          }\n        }));\n      }\n\n      /**\n       * Non-live replications run once\n       * and then automatically get canceled.\n       */\n      if (!this.live) {\n        yield awaitRxStorageReplicationFirstInSync(this.internalReplicationState);\n        yield awaitRxStorageReplicationInSync(this.internalReplicationState);\n        yield this.cancel();\n      }\n      this.callOnStart();\n    });\n    function start() {\n      return _start.apply(this, arguments);\n    }\n    return start;\n  }();\n  _proto.isStopped = function isStopped() {\n    if (this.subjects.canceled.getValue()) {\n      return true;\n    }\n    return false;\n  };\n  _proto.awaitInitialReplication = /*#__PURE__*/function () {\n    var _awaitInitialReplication = _asyncToGenerator(function* () {\n      yield this.startPromise;\n      return awaitRxStorageReplicationFirstInSync(ensureNotFalsy(this.internalReplicationState));\n    });\n    function awaitInitialReplication() {\n      return _awaitInitialReplication.apply(this, arguments);\n    }\n    return awaitInitialReplication;\n  }()\n\n  /**\n   * Returns a promise that resolves when:\n   * - All local data is replicated with the remote\n   * - No replication cycle is running or in retry-state\n   *\n   * WARNING: USing this function directly in a multi-tab browser application\n   * is dangerous because only the leading instance will ever be replicated,\n   * so this promise will not resolve in the other tabs.\n   * For multi-tab support you should set and observe a flag in a local document.\n   */;\n  _proto.awaitInSync = /*#__PURE__*/function () {\n    var _awaitInSync = _asyncToGenerator(function* () {\n      yield this.startPromise;\n      yield awaitRxStorageReplicationFirstInSync(ensureNotFalsy(this.internalReplicationState));\n\n      /**\n       * Often awaitInSync() is called directly after a document write,\n       * like in the unit tests.\n       * So we first have to await the idleness to ensure that all RxChangeEvents\n       * are processed already.\n       */\n      yield this.collection.database.requestIdlePromise();\n      yield awaitRxStorageReplicationInSync(ensureNotFalsy(this.internalReplicationState));\n      return true;\n    });\n    function awaitInSync() {\n      return _awaitInSync.apply(this, arguments);\n    }\n    return awaitInSync;\n  }();\n  _proto.reSync = function reSync() {\n    this.remoteEvents$.next('RESYNC');\n  };\n  _proto.emitEvent = function emitEvent(ev) {\n    this.remoteEvents$.next(ev);\n  };\n  _proto.cancel = function cancel() {\n    if (this.isStopped()) {\n      return PROMISE_RESOLVE_FALSE;\n    }\n    var promises = [];\n    if (this.internalReplicationState) {\n      cancelRxStorageReplication(this.internalReplicationState);\n    }\n    if (this.metaInstance) {\n      promises.push(ensureNotFalsy(this.internalReplicationState).checkpointQueue.then(() => ensureNotFalsy(this.metaInstance).close()));\n    }\n    this.subs.forEach(sub => sub.unsubscribe());\n    this.subjects.canceled.next(true);\n    this.subjects.active.complete();\n    this.subjects.canceled.complete();\n    this.subjects.error.complete();\n    this.subjects.received.complete();\n    this.subjects.send.complete();\n    return Promise.all(promises);\n  };\n  return RxReplicationState;\n}();\nexport function replicateRxCollection({\n  replicationIdentifier,\n  collection,\n  deletedField = '_deleted',\n  pull,\n  push,\n  live = true,\n  retryTime = 1000 * 5,\n  waitForLeadership = true,\n  autoStart = true\n}) {\n  addRxPlugin(RxDBLeaderElectionPlugin);\n  var replicationIdentifierHash = collection.database.hashFunction([collection.database.name, collection.name, replicationIdentifier].join('|'));\n  var replicationState = new RxReplicationState(replicationIdentifierHash, collection, deletedField, pull, push, live, retryTime, autoStart);\n  startReplicationOnLeaderShip(waitForLeadership, replicationState);\n  return replicationState;\n}\nexport function startReplicationOnLeaderShip(waitForLeadership, replicationState) {\n  /**\n   * Always await this Promise to ensure that the current instance\n   * is leader when waitForLeadership=true\n   */\n  var mustWaitForLeadership = waitForLeadership && replicationState.collection.database.multiInstance;\n  var waitTillRun = mustWaitForLeadership ? replicationState.collection.database.waitForLeadership() : PROMISE_RESOLVE_TRUE;\n  return waitTillRun.then(() => {\n    if (replicationState.isStopped()) {\n      return;\n    }\n    if (replicationState.autoStart) {\n      replicationState.start();\n    }\n  });\n}","map":{"version":3,"names":["BehaviorSubject","combineLatest","mergeMap","Subject","RxDBLeaderElectionPlugin","ensureNotFalsy","errorToPlainJson","flatClone","getFromMapOrCreate","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_TRUE","toArray","awaitRxStorageReplicationFirstInSync","awaitRxStorageReplicationInSync","cancelRxStorageReplication","getRxReplicationMetaInstanceSchema","replicateRxStorageInstance","newRxError","awaitRetry","DEFAULT_MODIFIER","swapDefaultDeletedTodeletedField","handlePulledDocuments","addConnectedStorageToCollection","addRxPlugin","hasEncryption","overwritable","runAsyncPluginHooks","REPLICATION_STATE_BY_COLLECTION","WeakMap","RxReplicationState","replicationIdentifierHash","collection","deletedField","pull","push","live","retryTime","autoStart","subs","subjects","received","send","error","canceled","active","received$","asObservable","send$","error$","canceled$","active$","callOnStart","undefined","remoteEvents$","replicationStates","onDestroy","cancel","Object","keys","forEach","key","defineProperty","get","startPromise","Promise","res","_proto","prototype","start","_start","_asyncToGenerator","_this","isStopped","pullModifier","modifier","pushModifier","database","metaInstanceCollectionName","name","metaInstanceSchema","schema","jsonSchema","metaInstance","all","storage","createStorageInstance","databaseName","collectionName","databaseInstanceToken","token","multiInstance","options","password","devMode","isDevMode","internalReplicationState","pushBatchSize","batchSize","pullBatchSize","initialCheckpoint","upstream","downstream","forkInstance","storageInstance","hashFunction","identifier","conflictHandler","replicationHandler","masterChangeStream$","pipe","_ref","ev","useEv","documents","map","d","_x","apply","arguments","masterChangesSince","_ref2","checkpoint","done","result","handler","err","emitError","errors","er","direction","next","useResult","_x2","_x3","masterWrite","_ref3","rows","useRows","_ref4","row","newDocumentState","assumedMasterState","_x5","length","Array","isArray","pushRows","args","rxdb","conflicts","_x4","events","subscribe","processed","down","document","up","writeToMasterRow","isActive","stream$","getValue","awaitInitialReplication","_awaitInitialReplication","awaitInSync","_awaitInSync","requestIdlePromise","reSync","emitEvent","promises","checkpointQueue","then","close","sub","unsubscribe","complete","replicateRxCollection","replicationIdentifier","waitForLeadership","join","replicationState","startReplicationOnLeaderShip","mustWaitForLeadership","waitTillRun"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/plugins/replication/index.js"],"sourcesContent":["/**\n * This plugin contains the primitives to create\n * a RxDB client-server replication.\n * It is used in the other replication plugins\n * but also can be used as standalone with a custom replication handler.\n */\n\nimport { BehaviorSubject, combineLatest, mergeMap, Subject } from 'rxjs';\nimport { RxDBLeaderElectionPlugin } from '../leader-election';\nimport { ensureNotFalsy, errorToPlainJson, flatClone, getFromMapOrCreate, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_TRUE, toArray } from '../../plugins/utils';\nimport { awaitRxStorageReplicationFirstInSync, awaitRxStorageReplicationInSync, cancelRxStorageReplication, getRxReplicationMetaInstanceSchema, replicateRxStorageInstance } from '../../replication-protocol';\nimport { newRxError } from '../../rx-error';\nimport { awaitRetry, DEFAULT_MODIFIER, swapDefaultDeletedTodeletedField, handlePulledDocuments } from './replication-helper';\nimport { addConnectedStorageToCollection } from '../../rx-database-internal-store';\nimport { addRxPlugin } from '../../plugin';\nimport { hasEncryption } from '../../rx-storage-helper';\nimport { overwritable } from '../../overwritable';\nimport { runAsyncPluginHooks } from '../../hooks';\nexport var REPLICATION_STATE_BY_COLLECTION = new WeakMap();\nexport var RxReplicationState = /*#__PURE__*/function () {\n  function RxReplicationState(\n  /**\n   * hash of the identifier, used to flag revisions\n   * and to identify which documents state came from the remote.\n   */\n  replicationIdentifierHash, collection, deletedField, pull, push, live, retryTime, autoStart) {\n    this.subs = [];\n    this.subjects = {\n      received: new Subject(),\n      // all documents that are received from the endpoint\n      send: new Subject(),\n      // all documents that are send to the endpoint\n      error: new Subject(),\n      // all errors that are received from the endpoint, emits new Error() objects\n      canceled: new BehaviorSubject(false),\n      // true when the replication was canceled\n      active: new BehaviorSubject(false) // true when something is running, false when not\n    };\n    this.received$ = this.subjects.received.asObservable();\n    this.send$ = this.subjects.send.asObservable();\n    this.error$ = this.subjects.error.asObservable();\n    this.canceled$ = this.subjects.canceled.asObservable();\n    this.active$ = this.subjects.active.asObservable();\n    this.callOnStart = undefined;\n    this.remoteEvents$ = new Subject();\n    this.replicationIdentifierHash = replicationIdentifierHash;\n    this.collection = collection;\n    this.deletedField = deletedField;\n    this.pull = pull;\n    this.push = push;\n    this.live = live;\n    this.retryTime = retryTime;\n    this.autoStart = autoStart;\n    var replicationStates = getFromMapOrCreate(REPLICATION_STATE_BY_COLLECTION, collection, () => []);\n    replicationStates.push(this);\n\n    // stop the replication when the collection gets destroyed\n    this.collection.onDestroy.push(() => this.cancel());\n\n    // create getters for the observables\n    Object.keys(this.subjects).forEach(key => {\n      Object.defineProperty(this, key + '$', {\n        get: function () {\n          return this.subjects[key].asObservable();\n        }\n      });\n    });\n    var startPromise = new Promise(res => {\n      this.callOnStart = res;\n    });\n    this.startPromise = startPromise;\n  }\n  var _proto = RxReplicationState.prototype;\n  _proto.start = async function start() {\n    if (this.isStopped()) {\n      return;\n    }\n\n    // fill in defaults for pull & push\n    var pullModifier = this.pull && this.pull.modifier ? this.pull.modifier : DEFAULT_MODIFIER;\n    var pushModifier = this.push && this.push.modifier ? this.push.modifier : DEFAULT_MODIFIER;\n    var database = this.collection.database;\n    var metaInstanceCollectionName = this.collection.name + '-rx-replication-' + this.replicationIdentifierHash;\n    var metaInstanceSchema = getRxReplicationMetaInstanceSchema(this.collection.schema.jsonSchema, hasEncryption(this.collection.schema.jsonSchema));\n    var [metaInstance] = await Promise.all([this.collection.database.storage.createStorageInstance({\n      databaseName: database.name,\n      collectionName: metaInstanceCollectionName,\n      databaseInstanceToken: database.token,\n      multiInstance: database.multiInstance,\n      // TODO is this always false?\n      options: {},\n      schema: metaInstanceSchema,\n      password: database.password,\n      devMode: overwritable.isDevMode()\n    }), addConnectedStorageToCollection(this.collection, metaInstanceCollectionName, metaInstanceSchema)]);\n    this.metaInstance = metaInstance;\n    this.internalReplicationState = replicateRxStorageInstance({\n      pushBatchSize: this.push && this.push.batchSize ? this.push.batchSize : 100,\n      pullBatchSize: this.pull && this.pull.batchSize ? this.pull.batchSize : 100,\n      initialCheckpoint: {\n        upstream: this.push ? this.push.initialCheckpoint : undefined,\n        downstream: this.pull ? this.pull.initialCheckpoint : undefined\n      },\n      forkInstance: this.collection.storageInstance,\n      metaInstance: this.metaInstance,\n      hashFunction: database.hashFunction,\n      identifier: 'rxdbreplication' + this.replicationIdentifierHash,\n      conflictHandler: this.collection.conflictHandler,\n      replicationHandler: {\n        masterChangeStream$: this.remoteEvents$.asObservable().pipe(mergeMap(async ev => {\n          if (ev === 'RESYNC') {\n            return ev;\n          }\n          var useEv = flatClone(ev);\n          useEv.documents = handlePulledDocuments(this.collection, this.deletedField, useEv.documents);\n          useEv.documents = await Promise.all(useEv.documents.map(d => pullModifier(d)));\n          return useEv;\n        })),\n        masterChangesSince: async (checkpoint, batchSize) => {\n          if (!this.pull) {\n            return {\n              checkpoint: null,\n              documents: []\n            };\n          }\n          /**\n           * Retries must be done here in the replication primitives plugin,\n           * because the replication protocol itself has no\n           * error handling.\n           */\n          var done = false;\n          var result = {};\n          while (!done && !this.isStopped()) {\n            try {\n              result = await this.pull.handler(checkpoint, batchSize);\n              done = true;\n            } catch (err) {\n              var emitError = newRxError('RC_PULL', {\n                checkpoint,\n                errors: toArray(err).map(er => errorToPlainJson(er)),\n                direction: 'pull'\n              });\n              this.subjects.error.next(emitError);\n              await awaitRetry(this.collection, ensureNotFalsy(this.retryTime));\n            }\n          }\n          if (this.isStopped()) {\n            return {\n              checkpoint: null,\n              documents: []\n            };\n          }\n          var useResult = flatClone(result);\n          useResult.documents = handlePulledDocuments(this.collection, this.deletedField, useResult.documents);\n          useResult.documents = await Promise.all(useResult.documents.map(d => pullModifier(d)));\n          return useResult;\n        },\n        masterWrite: async rows => {\n          if (!this.push) {\n            return [];\n          }\n          var done = false;\n          await runAsyncPluginHooks('preReplicationMasterWrite', {\n            rows,\n            collection: this.collection\n          });\n          var useRows = await Promise.all(rows.map(async row => {\n            row.newDocumentState = await pushModifier(row.newDocumentState);\n            if (row.assumedMasterState) {\n              row.assumedMasterState = await pushModifier(row.assumedMasterState);\n            }\n            if (this.deletedField !== '_deleted') {\n              row.newDocumentState = swapDefaultDeletedTodeletedField(this.deletedField, row.newDocumentState);\n              if (row.assumedMasterState) {\n                row.assumedMasterState = swapDefaultDeletedTodeletedField(this.deletedField, row.assumedMasterState);\n              }\n            }\n            return row;\n          }));\n          var result = null;\n\n          // In case all the rows have been filtered and nothing has to be sent\n          if (useRows.length === 0) {\n            done = true;\n            result = [];\n          }\n          while (!done && !this.isStopped()) {\n            try {\n              result = await this.push.handler(useRows);\n              /**\n               * It is a common problem that people have wrongly behaving backend\n               * that do not return an array with the conflicts on push requests.\n               * So we run this check here to make it easier to debug.\n               * @link https://github.com/pubkey/rxdb/issues/4103\n               */\n              if (!Array.isArray(result)) {\n                throw newRxError('RC_PUSH_NO_AR', {\n                  pushRows: rows,\n                  direction: 'push',\n                  args: {\n                    result\n                  }\n                });\n              }\n              done = true;\n            } catch (err) {\n              var emitError = err.rxdb ? err : newRxError('RC_PUSH', {\n                pushRows: rows,\n                errors: toArray(err).map(er => errorToPlainJson(er)),\n                direction: 'push'\n              });\n              this.subjects.error.next(emitError);\n              await awaitRetry(this.collection, ensureNotFalsy(this.retryTime));\n            }\n          }\n          if (this.isStopped()) {\n            return [];\n          }\n          await runAsyncPluginHooks('preReplicationMasterWriteDocumentsHandle', {\n            result,\n            collection: this.collection\n          });\n          var conflicts = handlePulledDocuments(this.collection, this.deletedField, ensureNotFalsy(result));\n          return conflicts;\n        }\n      }\n    });\n    this.subs.push(this.internalReplicationState.events.error.subscribe(err => {\n      this.subjects.error.next(err);\n    }), this.internalReplicationState.events.processed.down.subscribe(row => this.subjects.received.next(row.document)), this.internalReplicationState.events.processed.up.subscribe(writeToMasterRow => {\n      this.subjects.send.next(writeToMasterRow.newDocumentState);\n    }), combineLatest([this.internalReplicationState.events.active.down, this.internalReplicationState.events.active.up]).subscribe(([down, up]) => {\n      var isActive = down || up;\n      this.subjects.active.next(isActive);\n    }));\n    if (this.pull && this.pull.stream$ && this.live) {\n      this.subs.push(this.pull.stream$.subscribe({\n        next: ev => {\n          this.remoteEvents$.next(ev);\n        },\n        error: err => {\n          this.subjects.error.next(err);\n        }\n      }));\n    }\n\n    /**\n     * Non-live replications run once\n     * and then automatically get canceled.\n     */\n    if (!this.live) {\n      await awaitRxStorageReplicationFirstInSync(this.internalReplicationState);\n      await awaitRxStorageReplicationInSync(this.internalReplicationState);\n      await this.cancel();\n    }\n    this.callOnStart();\n  };\n  _proto.isStopped = function isStopped() {\n    if (this.subjects.canceled.getValue()) {\n      return true;\n    }\n    return false;\n  };\n  _proto.awaitInitialReplication = async function awaitInitialReplication() {\n    await this.startPromise;\n    return awaitRxStorageReplicationFirstInSync(ensureNotFalsy(this.internalReplicationState));\n  }\n\n  /**\n   * Returns a promise that resolves when:\n   * - All local data is replicated with the remote\n   * - No replication cycle is running or in retry-state\n   *\n   * WARNING: USing this function directly in a multi-tab browser application\n   * is dangerous because only the leading instance will ever be replicated,\n   * so this promise will not resolve in the other tabs.\n   * For multi-tab support you should set and observe a flag in a local document.\n   */;\n  _proto.awaitInSync = async function awaitInSync() {\n    await this.startPromise;\n    await awaitRxStorageReplicationFirstInSync(ensureNotFalsy(this.internalReplicationState));\n\n    /**\n     * Often awaitInSync() is called directly after a document write,\n     * like in the unit tests.\n     * So we first have to await the idleness to ensure that all RxChangeEvents\n     * are processed already.\n     */\n    await this.collection.database.requestIdlePromise();\n    await awaitRxStorageReplicationInSync(ensureNotFalsy(this.internalReplicationState));\n    return true;\n  };\n  _proto.reSync = function reSync() {\n    this.remoteEvents$.next('RESYNC');\n  };\n  _proto.emitEvent = function emitEvent(ev) {\n    this.remoteEvents$.next(ev);\n  };\n  _proto.cancel = function cancel() {\n    if (this.isStopped()) {\n      return PROMISE_RESOLVE_FALSE;\n    }\n    var promises = [];\n    if (this.internalReplicationState) {\n      cancelRxStorageReplication(this.internalReplicationState);\n    }\n    if (this.metaInstance) {\n      promises.push(ensureNotFalsy(this.internalReplicationState).checkpointQueue.then(() => ensureNotFalsy(this.metaInstance).close()));\n    }\n    this.subs.forEach(sub => sub.unsubscribe());\n    this.subjects.canceled.next(true);\n    this.subjects.active.complete();\n    this.subjects.canceled.complete();\n    this.subjects.error.complete();\n    this.subjects.received.complete();\n    this.subjects.send.complete();\n    return Promise.all(promises);\n  };\n  return RxReplicationState;\n}();\nexport function replicateRxCollection({\n  replicationIdentifier,\n  collection,\n  deletedField = '_deleted',\n  pull,\n  push,\n  live = true,\n  retryTime = 1000 * 5,\n  waitForLeadership = true,\n  autoStart = true\n}) {\n  addRxPlugin(RxDBLeaderElectionPlugin);\n  var replicationIdentifierHash = collection.database.hashFunction([collection.database.name, collection.name, replicationIdentifier].join('|'));\n  var replicationState = new RxReplicationState(replicationIdentifierHash, collection, deletedField, pull, push, live, retryTime, autoStart);\n  startReplicationOnLeaderShip(waitForLeadership, replicationState);\n  return replicationState;\n}\nexport function startReplicationOnLeaderShip(waitForLeadership, replicationState) {\n  /**\n   * Always await this Promise to ensure that the current instance\n   * is leader when waitForLeadership=true\n   */\n  var mustWaitForLeadership = waitForLeadership && replicationState.collection.database.multiInstance;\n  var waitTillRun = mustWaitForLeadership ? replicationState.collection.database.waitForLeadership() : PROMISE_RESOLVE_TRUE;\n  return waitTillRun.then(() => {\n    if (replicationState.isStopped()) {\n      return;\n    }\n    if (replicationState.autoStart) {\n      replicationState.start();\n    }\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}