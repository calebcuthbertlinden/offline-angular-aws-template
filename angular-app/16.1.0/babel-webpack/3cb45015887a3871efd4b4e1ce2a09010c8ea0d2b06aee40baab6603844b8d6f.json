{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { firstValueFrom, filter } from 'rxjs';\nimport { stackCheckpoints } from '../rx-storage-helper';\nimport { appendToArray, batchArray, ensureNotFalsy, parseRevision, PROMISE_RESOLVE_FALSE } from '../plugins/utils';\nimport { getLastCheckpointDoc, setCheckpoint } from './checkpoint';\nimport { resolveConflictError } from './conflicts';\nimport { writeDocToDocState } from './helper';\nimport { getAssumedMasterState, getMetaWriteRow } from './meta-instance';\n\n/**\n * Writes all document changes from the fork to the master.\n * The upstream runs on two modes:\n * - For initial replication, a checkpoint-iteration is used\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\n *   In contrast to the master, the fork can be assumed to never loose connection,\n *   so we do not have to prepare for missed out events.\n */\nexport function startReplicationUpstream(_x) {\n  return _startReplicationUpstream.apply(this, arguments);\n}\nfunction _startReplicationUpstream() {\n  _startReplicationUpstream = _asyncToGenerator(function* (state) {\n    if (state.input.initialCheckpoint && state.input.initialCheckpoint.upstream) {\n      var checkpointDoc = yield getLastCheckpointDoc(state, 'up');\n      if (!checkpointDoc) {\n        yield setCheckpoint(state, 'up', state.input.initialCheckpoint.upstream);\n      }\n    }\n    var replicationHandler = state.input.replicationHandler;\n    state.streamQueue.up = state.streamQueue.up.then(() => {\n      return upstreamInitialSync().then(() => {\n        processTasks();\n      });\n    });\n\n    // used to detect which tasks etc can in it at which order.\n    var timer = 0;\n    var initialSyncStartTime = -1;\n    var openTasks = [];\n    var sub = state.input.forkInstance.changeStream().pipe(filter(eventBulk => eventBulk.context !== state.downstreamBulkWriteFlag)).subscribe(eventBulk => {\n      state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\n      openTasks.push({\n        task: eventBulk,\n        time: timer++\n      });\n      if (state.input.waitBeforePersist) {\n        return state.input.waitBeforePersist().then(() => processTasks());\n      } else {\n        return processTasks();\n      }\n    });\n    firstValueFrom(state.events.canceled.pipe(filter(canceled => !!canceled))).then(() => sub.unsubscribe());\n    function upstreamInitialSync() {\n      return _upstreamInitialSync.apply(this, arguments);\n    }\n    /**\n     * Takes all open tasks an processes them at once.\n     */\n    function _upstreamInitialSync() {\n      _upstreamInitialSync = _asyncToGenerator(function* () {\n        state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\n        if (state.events.canceled.getValue()) {\n          return;\n        }\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\n        var lastCheckpoint = yield state.checkpointQueue;\n        var promises = [];\n        while (!state.events.canceled.getValue()) {\n          initialSyncStartTime = timer++;\n          var upResult = yield state.input.forkInstance.getChangedDocumentsSince(state.input.pushBatchSize, lastCheckpoint);\n          if (upResult.documents.length === 0) {\n            break;\n          }\n          lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\n          promises.push(persistToMaster(upResult.documents, ensureNotFalsy(lastCheckpoint)));\n        }\n\n        /**\n         * If we had conflicts during the initial sync,\n         * it means that we likely have new writes to the fork\n         * and so we have to run the initial sync again to upstream these new writes.\n         */\n        var resolvedPromises = yield Promise.all(promises);\n        var hadConflicts = resolvedPromises.find(r => !!r);\n        if (hadConflicts) {\n          yield upstreamInitialSync();\n        } else if (!state.firstSyncDone.up.getValue() && !state.events.canceled.getValue()) {\n          state.firstSyncDone.up.next(true);\n        }\n      });\n      return _upstreamInitialSync.apply(this, arguments);\n    }\n    function processTasks() {\n      if (state.events.canceled.getValue() || openTasks.length === 0) {\n        state.events.active.up.next(false);\n        return;\n      }\n      state.stats.up.processTasks = state.stats.up.processTasks + 1;\n      state.events.active.up.next(true);\n      state.streamQueue.up = state.streamQueue.up.then(() => {\n        /**\n         * Merge/filter all open tasks\n         */\n        var docs = [];\n        var checkpoint = {};\n        while (openTasks.length > 0) {\n          var taskWithTime = ensureNotFalsy(openTasks.shift());\n          /**\n           * If the task came in before the last time the initial sync fetching\n           * has run, we can ignore the task because the initial sync already processed\n           * these documents.\n           */\n          if (taskWithTime.time < initialSyncStartTime) {\n            continue;\n          }\n          appendToArray(docs, taskWithTime.task.events.map(r => {\n            return r.documentData;\n          }));\n          checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\n        }\n        var promise = docs.length === 0 ? PROMISE_RESOLVE_FALSE : persistToMaster(docs, checkpoint);\n        return promise.then(() => {\n          if (openTasks.length === 0) {\n            state.events.active.up.next(false);\n          } else {\n            processTasks();\n          }\n        });\n      });\n    }\n    var persistenceQueue = PROMISE_RESOLVE_FALSE;\n    var nonPersistedFromMaster = {\n      docs: {}\n    };\n\n    /**\n     * Returns true if had conflicts,\n     * false if not.\n     */\n    function persistToMaster(docs, checkpoint) {\n      state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\n\n      /**\n       * Add the new docs to the non-persistent list\n       */\n      docs.forEach(docData => {\n        var docId = docData[state.primaryPath];\n        nonPersistedFromMaster.docs[docId] = docData;\n      });\n      nonPersistedFromMaster.checkpoint = checkpoint;\n      persistenceQueue = persistenceQueue.then( /*#__PURE__*/_asyncToGenerator(function* () {\n        if (state.events.canceled.getValue()) {\n          return false;\n        }\n        var upDocsById = nonPersistedFromMaster.docs;\n        nonPersistedFromMaster.docs = {};\n        var useCheckpoint = nonPersistedFromMaster.checkpoint;\n        var docIds = Object.keys(upDocsById);\n        if (docIds.length === 0) {\n          return false;\n        }\n        var assumedMasterState = yield getAssumedMasterState(state, docIds);\n        var writeRowsToMaster = {};\n        var writeRowsToMasterIds = [];\n        var writeRowsToMeta = {};\n        var forkStateById = {};\n        yield Promise.all(docIds.map( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (docId) {\n            var fullDocData = upDocsById[docId];\n            forkStateById[docId] = fullDocData;\n            var docData = writeDocToDocState(fullDocData);\n            var assumedMasterDoc = assumedMasterState[docId];\n\n            /**\n             * If the master state is equal to the\n             * fork state, we can assume that the document state is already\n             * replicated.\n             */\n            if (assumedMasterDoc &&\n            // if the isResolvedConflict is correct, we do not have to compare the documents.\n            assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev && (yield state.input.conflictHandler({\n              realMasterState: assumedMasterDoc.docData,\n              newDocumentState: docData\n            }, 'upstream-check-if-equal')).isEqual ||\n            /**\n             * If the master works with _rev fields,\n             * we use that to check if our current doc state\n             * is different from the assumedMasterDoc.\n             */\n\n            assumedMasterDoc && assumedMasterDoc.docData._rev && parseRevision(fullDocData._rev).height === fullDocData._meta[state.input.identifier]) {\n              return;\n            }\n            writeRowsToMasterIds.push(docId);\n            writeRowsToMaster[docId] = {\n              assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n              newDocumentState: docData\n            };\n            writeRowsToMeta[docId] = getMetaWriteRow(state, docData, assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined);\n          });\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }()));\n        if (writeRowsToMasterIds.length === 0) {\n          return false;\n        }\n        var writeRowsArray = Object.values(writeRowsToMaster);\n        var conflictIds = new Set();\n        var conflictsById = {};\n\n        /**\n         * To always respect the push.batchSize,\n         * we have to split the write rows into batches\n         * to ensure that replicationHandler.masterWrite() is never\n         * called with more documents than what the batchSize limits.\n         */\n        var writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);\n        yield Promise.all(writeBatches.map( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(function* (writeBatch) {\n            var masterWriteResult = yield replicationHandler.masterWrite(writeBatch);\n            masterWriteResult.forEach(conflictDoc => {\n              var id = conflictDoc[state.primaryPath];\n              conflictIds.add(id);\n              conflictsById[id] = conflictDoc;\n            });\n          });\n          return function (_x3) {\n            return _ref3.apply(this, arguments);\n          };\n        }()));\n        var useWriteRowsToMeta = [];\n        writeRowsToMasterIds.forEach(docId => {\n          if (!conflictIds.has(docId)) {\n            state.events.processed.up.next(writeRowsToMaster[docId]);\n            useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n          }\n        });\n        if (useWriteRowsToMeta.length > 0) {\n          yield state.input.metaInstance.bulkWrite(useWriteRowsToMeta, 'replication-up-write-meta');\n          // TODO what happens when we have conflicts here?\n        }\n\n        /**\n         * Resolve conflicts by writing a new document\n         * state to the fork instance and the 'real' master state\n         * to the meta instance.\n         * Non-409 errors will be detected by resolveConflictError()\n         */\n        var hadConflictWrites = false;\n        if (conflictIds.size > 0) {\n          state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\n          var conflictWriteFork = [];\n          var conflictWriteMeta = {};\n          yield Promise.all(Object.entries(conflictsById).map(([docId, realMasterState]) => {\n            var writeToMasterRow = writeRowsToMaster[docId];\n            var input = {\n              newDocumentState: writeToMasterRow.newDocumentState,\n              assumedMasterState: writeToMasterRow.assumedMasterState,\n              realMasterState\n            };\n            return resolveConflictError(state, input, forkStateById[docId]).then(resolved => {\n              if (resolved) {\n                state.events.resolvedConflicts.next({\n                  input,\n                  output: resolved.output\n                });\n                conflictWriteFork.push({\n                  previous: forkStateById[docId],\n                  document: resolved.resolvedDoc\n                });\n                var assumedMasterDoc = assumedMasterState[docId];\n                conflictWriteMeta[docId] = getMetaWriteRow(state, ensureNotFalsy(realMasterState), assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined, resolved.resolvedDoc._rev);\n              }\n            });\n          }));\n          if (conflictWriteFork.length > 0) {\n            hadConflictWrites = true;\n            state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\n            var forkWriteResult = yield state.input.forkInstance.bulkWrite(conflictWriteFork, 'replication-up-write-conflict');\n            /**\n             * Errors in the forkWriteResult must not be handled\n             * because they have been caused by a write to the forkInstance\n             * in between which will anyway trigger a new upstream cycle\n             * that will then resolved the conflict again.\n             */\n            var useMetaWrites = [];\n            Object.keys(forkWriteResult.success).forEach(docId => {\n              useMetaWrites.push(conflictWriteMeta[docId]);\n            });\n            if (useMetaWrites.length > 0) {\n              yield state.input.metaInstance.bulkWrite(useMetaWrites, 'replication-up-write-conflict-meta');\n            }\n            // TODO what to do with conflicts while writing to the metaInstance?\n          }\n        }\n\n        /**\n         * For better performance we do not await checkpoint writes,\n         * but to ensure order on parallel checkpoint writes,\n         * we have to use a queue.\n         */\n        state.checkpointQueue = state.checkpointQueue.then(() => setCheckpoint(state, 'up', useCheckpoint));\n        return hadConflictWrites;\n      })).catch(unhandledError => {\n        state.events.error.next(unhandledError);\n        return false;\n      });\n      return persistenceQueue;\n    }\n  });\n  return _startReplicationUpstream.apply(this, arguments);\n}","map":{"version":3,"names":["firstValueFrom","filter","stackCheckpoints","appendToArray","batchArray","ensureNotFalsy","parseRevision","PROMISE_RESOLVE_FALSE","getLastCheckpointDoc","setCheckpoint","resolveConflictError","writeDocToDocState","getAssumedMasterState","getMetaWriteRow","startReplicationUpstream","_x","_startReplicationUpstream","apply","arguments","_asyncToGenerator","state","input","initialCheckpoint","upstream","checkpointDoc","replicationHandler","streamQueue","up","then","upstreamInitialSync","processTasks","timer","initialSyncStartTime","openTasks","sub","forkInstance","changeStream","pipe","eventBulk","context","downstreamBulkWriteFlag","subscribe","stats","forkChangeStreamEmit","push","task","time","waitBeforePersist","events","canceled","unsubscribe","_upstreamInitialSync","getValue","checkpointQueue","lastCheckpoint","promises","upResult","getChangedDocumentsSince","pushBatchSize","documents","length","checkpoint","persistToMaster","resolvedPromises","Promise","all","hadConflicts","find","r","firstSyncDone","next","active","docs","taskWithTime","shift","map","documentData","promise","persistenceQueue","nonPersistedFromMaster","forEach","docData","docId","primaryPath","upDocsById","useCheckpoint","docIds","Object","keys","assumedMasterState","writeRowsToMaster","writeRowsToMasterIds","writeRowsToMeta","forkStateById","_ref2","fullDocData","assumedMasterDoc","metaDocument","isResolvedConflict","_rev","conflictHandler","realMasterState","newDocumentState","isEqual","height","_meta","identifier","undefined","_x2","writeRowsArray","values","conflictIds","Set","conflictsById","writeBatches","_ref3","writeBatch","masterWriteResult","masterWrite","conflictDoc","id","add","_x3","useWriteRowsToMeta","has","processed","metaInstance","bulkWrite","hadConflictWrites","size","persistToMasterHadConflicts","conflictWriteFork","conflictWriteMeta","entries","writeToMasterRow","resolved","resolvedConflicts","output","previous","document","resolvedDoc","persistToMasterConflictWrites","forkWriteResult","useMetaWrites","success","catch","unhandledError","error"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/replication-protocol/upstream.js"],"sourcesContent":["import { firstValueFrom, filter } from 'rxjs';\nimport { stackCheckpoints } from '../rx-storage-helper';\nimport { appendToArray, batchArray, ensureNotFalsy, parseRevision, PROMISE_RESOLVE_FALSE } from '../plugins/utils';\nimport { getLastCheckpointDoc, setCheckpoint } from './checkpoint';\nimport { resolveConflictError } from './conflicts';\nimport { writeDocToDocState } from './helper';\nimport { getAssumedMasterState, getMetaWriteRow } from './meta-instance';\n\n/**\n * Writes all document changes from the fork to the master.\n * The upstream runs on two modes:\n * - For initial replication, a checkpoint-iteration is used\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\n *   In contrast to the master, the fork can be assumed to never loose connection,\n *   so we do not have to prepare for missed out events.\n */\nexport async function startReplicationUpstream(state) {\n  if (state.input.initialCheckpoint && state.input.initialCheckpoint.upstream) {\n    var checkpointDoc = await getLastCheckpointDoc(state, 'up');\n    if (!checkpointDoc) {\n      await setCheckpoint(state, 'up', state.input.initialCheckpoint.upstream);\n    }\n  }\n  var replicationHandler = state.input.replicationHandler;\n  state.streamQueue.up = state.streamQueue.up.then(() => {\n    return upstreamInitialSync().then(() => {\n      processTasks();\n    });\n  });\n\n  // used to detect which tasks etc can in it at which order.\n  var timer = 0;\n  var initialSyncStartTime = -1;\n  var openTasks = [];\n  var sub = state.input.forkInstance.changeStream().pipe(filter(eventBulk => eventBulk.context !== state.downstreamBulkWriteFlag)).subscribe(eventBulk => {\n    state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\n    openTasks.push({\n      task: eventBulk,\n      time: timer++\n    });\n    if (state.input.waitBeforePersist) {\n      return state.input.waitBeforePersist().then(() => processTasks());\n    } else {\n      return processTasks();\n    }\n  });\n  firstValueFrom(state.events.canceled.pipe(filter(canceled => !!canceled))).then(() => sub.unsubscribe());\n  async function upstreamInitialSync() {\n    state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\n    if (state.events.canceled.getValue()) {\n      return;\n    }\n    state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\n    var lastCheckpoint = await state.checkpointQueue;\n    var promises = [];\n    while (!state.events.canceled.getValue()) {\n      initialSyncStartTime = timer++;\n      var upResult = await state.input.forkInstance.getChangedDocumentsSince(state.input.pushBatchSize, lastCheckpoint);\n      if (upResult.documents.length === 0) {\n        break;\n      }\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\n      promises.push(persistToMaster(upResult.documents, ensureNotFalsy(lastCheckpoint)));\n    }\n\n    /**\n     * If we had conflicts during the initial sync,\n     * it means that we likely have new writes to the fork\n     * and so we have to run the initial sync again to upstream these new writes.\n     */\n    var resolvedPromises = await Promise.all(promises);\n    var hadConflicts = resolvedPromises.find(r => !!r);\n    if (hadConflicts) {\n      await upstreamInitialSync();\n    } else if (!state.firstSyncDone.up.getValue() && !state.events.canceled.getValue()) {\n      state.firstSyncDone.up.next(true);\n    }\n  }\n\n  /**\n   * Takes all open tasks an processes them at once.\n   */\n  function processTasks() {\n    if (state.events.canceled.getValue() || openTasks.length === 0) {\n      state.events.active.up.next(false);\n      return;\n    }\n    state.stats.up.processTasks = state.stats.up.processTasks + 1;\n    state.events.active.up.next(true);\n    state.streamQueue.up = state.streamQueue.up.then(() => {\n      /**\n       * Merge/filter all open tasks\n       */\n      var docs = [];\n      var checkpoint = {};\n      while (openTasks.length > 0) {\n        var taskWithTime = ensureNotFalsy(openTasks.shift());\n        /**\n         * If the task came in before the last time the initial sync fetching\n         * has run, we can ignore the task because the initial sync already processed\n         * these documents.\n         */\n        if (taskWithTime.time < initialSyncStartTime) {\n          continue;\n        }\n        appendToArray(docs, taskWithTime.task.events.map(r => {\n          return r.documentData;\n        }));\n        checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\n      }\n      var promise = docs.length === 0 ? PROMISE_RESOLVE_FALSE : persistToMaster(docs, checkpoint);\n      return promise.then(() => {\n        if (openTasks.length === 0) {\n          state.events.active.up.next(false);\n        } else {\n          processTasks();\n        }\n      });\n    });\n  }\n  var persistenceQueue = PROMISE_RESOLVE_FALSE;\n  var nonPersistedFromMaster = {\n    docs: {}\n  };\n\n  /**\n   * Returns true if had conflicts,\n   * false if not.\n   */\n  function persistToMaster(docs, checkpoint) {\n    state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\n\n    /**\n     * Add the new docs to the non-persistent list\n     */\n    docs.forEach(docData => {\n      var docId = docData[state.primaryPath];\n      nonPersistedFromMaster.docs[docId] = docData;\n    });\n    nonPersistedFromMaster.checkpoint = checkpoint;\n    persistenceQueue = persistenceQueue.then(async () => {\n      if (state.events.canceled.getValue()) {\n        return false;\n      }\n      var upDocsById = nonPersistedFromMaster.docs;\n      nonPersistedFromMaster.docs = {};\n      var useCheckpoint = nonPersistedFromMaster.checkpoint;\n      var docIds = Object.keys(upDocsById);\n      if (docIds.length === 0) {\n        return false;\n      }\n      var assumedMasterState = await getAssumedMasterState(state, docIds);\n      var writeRowsToMaster = {};\n      var writeRowsToMasterIds = [];\n      var writeRowsToMeta = {};\n      var forkStateById = {};\n      await Promise.all(docIds.map(async docId => {\n        var fullDocData = upDocsById[docId];\n        forkStateById[docId] = fullDocData;\n        var docData = writeDocToDocState(fullDocData);\n        var assumedMasterDoc = assumedMasterState[docId];\n\n        /**\n         * If the master state is equal to the\n         * fork state, we can assume that the document state is already\n         * replicated.\n         */\n        if (assumedMasterDoc &&\n        // if the isResolvedConflict is correct, we do not have to compare the documents.\n        assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev && (await state.input.conflictHandler({\n          realMasterState: assumedMasterDoc.docData,\n          newDocumentState: docData\n        }, 'upstream-check-if-equal')).isEqual ||\n        /**\n         * If the master works with _rev fields,\n         * we use that to check if our current doc state\n         * is different from the assumedMasterDoc.\n         */\n\n        assumedMasterDoc && assumedMasterDoc.docData._rev && parseRevision(fullDocData._rev).height === fullDocData._meta[state.input.identifier]) {\n          return;\n        }\n        writeRowsToMasterIds.push(docId);\n        writeRowsToMaster[docId] = {\n          assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n          newDocumentState: docData\n        };\n        writeRowsToMeta[docId] = getMetaWriteRow(state, docData, assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined);\n      }));\n      if (writeRowsToMasterIds.length === 0) {\n        return false;\n      }\n      var writeRowsArray = Object.values(writeRowsToMaster);\n      var conflictIds = new Set();\n      var conflictsById = {};\n\n      /**\n       * To always respect the push.batchSize,\n       * we have to split the write rows into batches\n       * to ensure that replicationHandler.masterWrite() is never\n       * called with more documents than what the batchSize limits.\n       */\n      var writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);\n      await Promise.all(writeBatches.map(async writeBatch => {\n        var masterWriteResult = await replicationHandler.masterWrite(writeBatch);\n        masterWriteResult.forEach(conflictDoc => {\n          var id = conflictDoc[state.primaryPath];\n          conflictIds.add(id);\n          conflictsById[id] = conflictDoc;\n        });\n      }));\n      var useWriteRowsToMeta = [];\n      writeRowsToMasterIds.forEach(docId => {\n        if (!conflictIds.has(docId)) {\n          state.events.processed.up.next(writeRowsToMaster[docId]);\n          useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n        }\n      });\n      if (useWriteRowsToMeta.length > 0) {\n        await state.input.metaInstance.bulkWrite(useWriteRowsToMeta, 'replication-up-write-meta');\n        // TODO what happens when we have conflicts here?\n      }\n\n      /**\n       * Resolve conflicts by writing a new document\n       * state to the fork instance and the 'real' master state\n       * to the meta instance.\n       * Non-409 errors will be detected by resolveConflictError()\n       */\n      var hadConflictWrites = false;\n      if (conflictIds.size > 0) {\n        state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\n        var conflictWriteFork = [];\n        var conflictWriteMeta = {};\n        await Promise.all(Object.entries(conflictsById).map(([docId, realMasterState]) => {\n          var writeToMasterRow = writeRowsToMaster[docId];\n          var input = {\n            newDocumentState: writeToMasterRow.newDocumentState,\n            assumedMasterState: writeToMasterRow.assumedMasterState,\n            realMasterState\n          };\n          return resolveConflictError(state, input, forkStateById[docId]).then(resolved => {\n            if (resolved) {\n              state.events.resolvedConflicts.next({\n                input,\n                output: resolved.output\n              });\n              conflictWriteFork.push({\n                previous: forkStateById[docId],\n                document: resolved.resolvedDoc\n              });\n              var assumedMasterDoc = assumedMasterState[docId];\n              conflictWriteMeta[docId] = getMetaWriteRow(state, ensureNotFalsy(realMasterState), assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined, resolved.resolvedDoc._rev);\n            }\n          });\n        }));\n        if (conflictWriteFork.length > 0) {\n          hadConflictWrites = true;\n          state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\n          var forkWriteResult = await state.input.forkInstance.bulkWrite(conflictWriteFork, 'replication-up-write-conflict');\n          /**\n           * Errors in the forkWriteResult must not be handled\n           * because they have been caused by a write to the forkInstance\n           * in between which will anyway trigger a new upstream cycle\n           * that will then resolved the conflict again.\n           */\n          var useMetaWrites = [];\n          Object.keys(forkWriteResult.success).forEach(docId => {\n            useMetaWrites.push(conflictWriteMeta[docId]);\n          });\n          if (useMetaWrites.length > 0) {\n            await state.input.metaInstance.bulkWrite(useMetaWrites, 'replication-up-write-conflict-meta');\n          }\n          // TODO what to do with conflicts while writing to the metaInstance?\n        }\n      }\n\n      /**\n       * For better performance we do not await checkpoint writes,\n       * but to ensure order on parallel checkpoint writes,\n       * we have to use a queue.\n       */\n      state.checkpointQueue = state.checkpointQueue.then(() => setCheckpoint(state, 'up', useCheckpoint));\n      return hadConflictWrites;\n    }).catch(unhandledError => {\n      state.events.error.next(unhandledError);\n      return false;\n    });\n    return persistenceQueue;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}