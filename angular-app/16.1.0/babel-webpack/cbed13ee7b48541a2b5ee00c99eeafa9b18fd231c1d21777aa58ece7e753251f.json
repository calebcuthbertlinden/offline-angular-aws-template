{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { INDEX_MIN } from '../../query-planner';\nimport { getQueryMatcher, getSortComparator } from '../../rx-query-helper';\nimport { dexieReplaceIfStartsWithPipe, DEXIE_DOCS_TABLE_NAME, fromDexieToStorage } from './dexie-helper';\nexport function mapKeyForKeyRange(k) {\n  if (k === INDEX_MIN) {\n    return -Infinity;\n  } else {\n    return k;\n  }\n}\nexport function getKeyRangeByQueryPlan(queryPlan, IDBKeyRange) {\n  if (!IDBKeyRange) {\n    if (typeof window === 'undefined') {\n      throw new Error('IDBKeyRange missing');\n    } else {\n      IDBKeyRange = window.IDBKeyRange;\n    }\n  }\n  var startKeys = queryPlan.startKeys.map(mapKeyForKeyRange);\n  var endKeys = queryPlan.endKeys.map(mapKeyForKeyRange);\n  var ret;\n  /**\n   * If index has only one field,\n   * we have to pass the keys directly, not the key arrays.\n   */\n  if (queryPlan.index.length === 1) {\n    var equalKeys = startKeys[0] === endKeys[0];\n    ret = IDBKeyRange.bound(startKeys[0], endKeys[0], equalKeys ? false : queryPlan.inclusiveStart, equalKeys ? false : queryPlan.inclusiveEnd);\n  } else {\n    ret = IDBKeyRange.bound(startKeys, endKeys, queryPlan.inclusiveStart, queryPlan.inclusiveEnd);\n  }\n  return ret;\n}\n\n/**\n * Runs mango queries over the Dexie.js database.\n */\nexport function dexieQuery(_x, _x2) {\n  return _dexieQuery.apply(this, arguments);\n}\nfunction _dexieQuery() {\n  _dexieQuery = _asyncToGenerator(function* (instance, preparedQuery) {\n    var state = yield instance.internals;\n    var query = preparedQuery.query;\n    var skip = query.skip ? query.skip : 0;\n    var limit = query.limit ? query.limit : Infinity;\n    var skipPlusLimit = skip + limit;\n    var queryPlan = preparedQuery.queryPlan;\n    var queryMatcher = false;\n    if (!queryPlan.selectorSatisfiedByIndex) {\n      queryMatcher = getQueryMatcher(instance.schema, preparedQuery.query);\n    }\n    var keyRange = getKeyRangeByQueryPlan(queryPlan, state.dexieDb._options.IDBKeyRange);\n    var queryPlanFields = queryPlan.index;\n    var rows = [];\n    yield state.dexieDb.transaction('r', state.dexieTable, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (dexieTx) {\n        /**\n         * TODO here we use the native IndexedDB transaction\n         * to get the cursor.\n         * Instead we should not leave Dexie.js API and find\n         * a way to create the cursor with Dexie.js.\n         */\n        var tx = dexieTx.idbtrans;\n\n        // const nativeIndexedDB = state.dexieDb.backendDB();\n        // const trans = nativeIndexedDB.transaction([DEXIE_DOCS_TABLE_NAME], 'readonly');\n\n        var store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);\n        var index;\n        if (queryPlanFields.length === 1 && queryPlanFields[0] === instance.primaryPath) {\n          index = store;\n        } else {\n          var indexName;\n          if (queryPlanFields.length === 1) {\n            indexName = dexieReplaceIfStartsWithPipe(queryPlanFields[0]);\n          } else {\n            indexName = '[' + queryPlanFields.map(field => dexieReplaceIfStartsWithPipe(field)).join('+') + ']';\n          }\n          index = store.index(indexName);\n        }\n        var cursorReq = index.openCursor(keyRange);\n        yield new Promise(res => {\n          cursorReq.onsuccess = function (e) {\n            var cursor = e.target.result;\n            if (cursor) {\n              // We have a record in cursor.value\n              var docData = fromDexieToStorage(cursor.value);\n              if (!docData._deleted && (!queryMatcher || queryMatcher(docData))) {\n                rows.push(docData);\n              }\n\n              /**\n               * If we do not have to manually sort\n               * and have enough documents,\n               * we can abort iterating over the cursor\n               * because we already have every relevant document.\n               */\n              if (queryPlan.sortFieldsSameAsIndexFields && rows.length === skipPlusLimit) {\n                res();\n              } else {\n                cursor.continue();\n              }\n            } else {\n              // Iteration complete\n              res();\n            }\n          };\n        });\n      });\n      return function (_x5) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    if (!queryPlan.sortFieldsSameAsIndexFields) {\n      var sortComparator = getSortComparator(instance.schema, preparedQuery.query);\n      rows = rows.sort(sortComparator);\n    }\n\n    // apply skip and limit boundaries.\n    rows = rows.slice(skip, skipPlusLimit);\n\n    /**\n     * Comment this in for debugging to check all fields in the database.\n     */\n    // const docsInDb = await state.dexieTable.filter(queryMatcher).toArray();\n    // let documents = docsInDb\n    //     .map(docData => stripDexieKey(docData))\n    //     .sort(sortComparator);\n    // if (preparedQuery.skip) {\n    //     documents = documents.slice(preparedQuery.skip);\n    // }\n    // if (preparedQuery.limit && documents.length > preparedQuery.limit) {\n    //     documents = documents.slice(0, preparedQuery.limit);\n    // }\n\n    return {\n      documents: rows\n    };\n  });\n  return _dexieQuery.apply(this, arguments);\n}\nexport function dexieCount(_x3, _x4) {\n  return _dexieCount.apply(this, arguments);\n}\nfunction _dexieCount() {\n  _dexieCount = _asyncToGenerator(function* (instance, preparedQuery) {\n    var state = yield instance.internals;\n    var queryPlan = preparedQuery.queryPlan;\n    var queryPlanFields = queryPlan.index;\n    var keyRange = getKeyRangeByQueryPlan(queryPlan, state.dexieDb._options.IDBKeyRange);\n    var count = -1;\n    yield state.dexieDb.transaction('r', state.dexieTable, /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (dexieTx) {\n        var tx = dexieTx.idbtrans;\n        var store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);\n        var index;\n        if (queryPlanFields.length === 1 && queryPlanFields[0] === instance.primaryPath) {\n          index = store;\n        } else {\n          var indexName;\n          if (queryPlanFields.length === 1) {\n            indexName = dexieReplaceIfStartsWithPipe(queryPlanFields[0]);\n          } else {\n            indexName = '[' + queryPlanFields.map(field => dexieReplaceIfStartsWithPipe(field)).join('+') + ']';\n          }\n          index = store.index(indexName);\n        }\n        var request = index.count(keyRange);\n        count = yield new Promise((res, rej) => {\n          request.onsuccess = function () {\n            res(request.result);\n          };\n          request.onerror = err => rej(err);\n        });\n      });\n      return function (_x6) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n    return count;\n  });\n  return _dexieCount.apply(this, arguments);\n}","map":{"version":3,"names":["INDEX_MIN","getQueryMatcher","getSortComparator","dexieReplaceIfStartsWithPipe","DEXIE_DOCS_TABLE_NAME","fromDexieToStorage","mapKeyForKeyRange","k","Infinity","getKeyRangeByQueryPlan","queryPlan","IDBKeyRange","window","Error","startKeys","map","endKeys","ret","index","length","equalKeys","bound","inclusiveStart","inclusiveEnd","dexieQuery","_x","_x2","_dexieQuery","apply","arguments","_asyncToGenerator","instance","preparedQuery","state","internals","query","skip","limit","skipPlusLimit","queryMatcher","selectorSatisfiedByIndex","schema","keyRange","dexieDb","_options","queryPlanFields","rows","transaction","dexieTable","_ref","dexieTx","tx","idbtrans","store","objectStore","primaryPath","indexName","field","join","cursorReq","openCursor","Promise","res","onsuccess","e","cursor","target","result","docData","value","_deleted","push","sortFieldsSameAsIndexFields","continue","_x5","sortComparator","sort","slice","documents","dexieCount","_x3","_x4","_dexieCount","count","_ref2","request","rej","onerror","err","_x6"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/plugins/storage-dexie/dexie-query.js"],"sourcesContent":["import { INDEX_MIN } from '../../query-planner';\nimport { getQueryMatcher, getSortComparator } from '../../rx-query-helper';\nimport { dexieReplaceIfStartsWithPipe, DEXIE_DOCS_TABLE_NAME, fromDexieToStorage } from './dexie-helper';\nexport function mapKeyForKeyRange(k) {\n  if (k === INDEX_MIN) {\n    return -Infinity;\n  } else {\n    return k;\n  }\n}\nexport function getKeyRangeByQueryPlan(queryPlan, IDBKeyRange) {\n  if (!IDBKeyRange) {\n    if (typeof window === 'undefined') {\n      throw new Error('IDBKeyRange missing');\n    } else {\n      IDBKeyRange = window.IDBKeyRange;\n    }\n  }\n  var startKeys = queryPlan.startKeys.map(mapKeyForKeyRange);\n  var endKeys = queryPlan.endKeys.map(mapKeyForKeyRange);\n  var ret;\n  /**\n   * If index has only one field,\n   * we have to pass the keys directly, not the key arrays.\n   */\n  if (queryPlan.index.length === 1) {\n    var equalKeys = startKeys[0] === endKeys[0];\n    ret = IDBKeyRange.bound(startKeys[0], endKeys[0], equalKeys ? false : queryPlan.inclusiveStart, equalKeys ? false : queryPlan.inclusiveEnd);\n  } else {\n    ret = IDBKeyRange.bound(startKeys, endKeys, queryPlan.inclusiveStart, queryPlan.inclusiveEnd);\n  }\n  return ret;\n}\n\n/**\n * Runs mango queries over the Dexie.js database.\n */\nexport async function dexieQuery(instance, preparedQuery) {\n  var state = await instance.internals;\n  var query = preparedQuery.query;\n  var skip = query.skip ? query.skip : 0;\n  var limit = query.limit ? query.limit : Infinity;\n  var skipPlusLimit = skip + limit;\n  var queryPlan = preparedQuery.queryPlan;\n  var queryMatcher = false;\n  if (!queryPlan.selectorSatisfiedByIndex) {\n    queryMatcher = getQueryMatcher(instance.schema, preparedQuery.query);\n  }\n  var keyRange = getKeyRangeByQueryPlan(queryPlan, state.dexieDb._options.IDBKeyRange);\n  var queryPlanFields = queryPlan.index;\n  var rows = [];\n  await state.dexieDb.transaction('r', state.dexieTable, async dexieTx => {\n    /**\n     * TODO here we use the native IndexedDB transaction\n     * to get the cursor.\n     * Instead we should not leave Dexie.js API and find\n     * a way to create the cursor with Dexie.js.\n     */\n    var tx = dexieTx.idbtrans;\n\n    // const nativeIndexedDB = state.dexieDb.backendDB();\n    // const trans = nativeIndexedDB.transaction([DEXIE_DOCS_TABLE_NAME], 'readonly');\n\n    var store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);\n    var index;\n    if (queryPlanFields.length === 1 && queryPlanFields[0] === instance.primaryPath) {\n      index = store;\n    } else {\n      var indexName;\n      if (queryPlanFields.length === 1) {\n        indexName = dexieReplaceIfStartsWithPipe(queryPlanFields[0]);\n      } else {\n        indexName = '[' + queryPlanFields.map(field => dexieReplaceIfStartsWithPipe(field)).join('+') + ']';\n      }\n      index = store.index(indexName);\n    }\n    var cursorReq = index.openCursor(keyRange);\n    await new Promise(res => {\n      cursorReq.onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (cursor) {\n          // We have a record in cursor.value\n          var docData = fromDexieToStorage(cursor.value);\n          if (!docData._deleted && (!queryMatcher || queryMatcher(docData))) {\n            rows.push(docData);\n          }\n\n          /**\n           * If we do not have to manually sort\n           * and have enough documents,\n           * we can abort iterating over the cursor\n           * because we already have every relevant document.\n           */\n          if (queryPlan.sortFieldsSameAsIndexFields && rows.length === skipPlusLimit) {\n            res();\n          } else {\n            cursor.continue();\n          }\n        } else {\n          // Iteration complete\n          res();\n        }\n      };\n    });\n  });\n  if (!queryPlan.sortFieldsSameAsIndexFields) {\n    var sortComparator = getSortComparator(instance.schema, preparedQuery.query);\n    rows = rows.sort(sortComparator);\n  }\n\n  // apply skip and limit boundaries.\n  rows = rows.slice(skip, skipPlusLimit);\n\n  /**\n   * Comment this in for debugging to check all fields in the database.\n   */\n  // const docsInDb = await state.dexieTable.filter(queryMatcher).toArray();\n  // let documents = docsInDb\n  //     .map(docData => stripDexieKey(docData))\n  //     .sort(sortComparator);\n  // if (preparedQuery.skip) {\n  //     documents = documents.slice(preparedQuery.skip);\n  // }\n  // if (preparedQuery.limit && documents.length > preparedQuery.limit) {\n  //     documents = documents.slice(0, preparedQuery.limit);\n  // }\n\n  return {\n    documents: rows\n  };\n}\nexport async function dexieCount(instance, preparedQuery) {\n  var state = await instance.internals;\n  var queryPlan = preparedQuery.queryPlan;\n  var queryPlanFields = queryPlan.index;\n  var keyRange = getKeyRangeByQueryPlan(queryPlan, state.dexieDb._options.IDBKeyRange);\n  var count = -1;\n  await state.dexieDb.transaction('r', state.dexieTable, async dexieTx => {\n    var tx = dexieTx.idbtrans;\n    var store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);\n    var index;\n    if (queryPlanFields.length === 1 && queryPlanFields[0] === instance.primaryPath) {\n      index = store;\n    } else {\n      var indexName;\n      if (queryPlanFields.length === 1) {\n        indexName = dexieReplaceIfStartsWithPipe(queryPlanFields[0]);\n      } else {\n        indexName = '[' + queryPlanFields.map(field => dexieReplaceIfStartsWithPipe(field)).join('+') + ']';\n      }\n      index = store.index(indexName);\n    }\n    var request = index.count(keyRange);\n    count = await new Promise((res, rej) => {\n      request.onsuccess = function () {\n        res(request.result);\n      };\n      request.onerror = err => rej(err);\n    });\n  });\n  return count;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}