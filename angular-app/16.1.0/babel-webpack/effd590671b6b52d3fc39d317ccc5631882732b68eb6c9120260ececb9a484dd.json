{"ast":null,"code":"import { getProperty, lastOfArray, UNKNOWN_VALUE } from '../util';\nexport const hasLimit = input => {\n  return !!input.queryParams.limit;\n};\nexport const isFindOne = input => {\n  return input.queryParams.limit === 1;\n};\nexport const hasSkip = input => {\n  if (input.queryParams.skip && input.queryParams.skip > 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\nexport const isDelete = input => {\n  return input.changeEvent.operation === 'DELETE';\n};\nexport const isInsert = input => {\n  return input.changeEvent.operation === 'INSERT';\n};\nexport const isUpdate = input => {\n  return input.changeEvent.operation === 'UPDATE';\n};\nexport const previousUnknown = input => {\n  return input.changeEvent.previous === UNKNOWN_VALUE;\n};\nexport const wasLimitReached = input => {\n  return hasLimit(input) && input.previousResults.length >= input.queryParams.limit;\n};\nexport const sortParamsChanged = input => {\n  const sortFields = input.queryParams.sortFields;\n  const prev = input.changeEvent.previous;\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  if (!prev || prev === UNKNOWN_VALUE) {\n    return true;\n  }\n  for (let i = 0; i < sortFields.length; i++) {\n    const field = sortFields[i];\n    const beforeData = getProperty(prev, field);\n    const afterData = getProperty(doc, field);\n    if (beforeData !== afterData) {\n      return true;\n    }\n  }\n  return false;\n};\nexport const wasInResult = input => {\n  const id = input.changeEvent.id;\n  if (input.keyDocumentMap) {\n    const has = input.keyDocumentMap.has(id);\n    return has;\n  } else {\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n      const item = results[i];\n      if (item[primary] === id) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\nexport const wasFirst = input => {\n  const first = input.previousResults[0];\n  if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  } else {\n    return false;\n  }\n};\nexport const wasLast = input => {\n  const last = lastOfArray(input.previousResults);\n  if (last && last[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  } else {\n    return false;\n  }\n};\nexport const wasSortedBeforeFirst = input => {\n  const prev = input.changeEvent.previous;\n  if (!prev || prev === UNKNOWN_VALUE) {\n    return false;\n  }\n  const first = input.previousResults[0];\n  if (!first) {\n    return false;\n  }\n  /**\n   * If the changed document is the same as the first,\n   * we cannot sort-compare them, because it might end in a non-deterministic\n   * sort order. Because both document could be equal.\n   * So instead we have to return true.\n   */\n  if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(prev, first);\n  return comp < 0;\n};\nexport const wasSortedAfterLast = input => {\n  const prev = input.changeEvent.previous;\n  if (!prev || prev === UNKNOWN_VALUE) {\n    return false;\n  }\n  const last = lastOfArray(input.previousResults);\n  if (!last) {\n    return false;\n  }\n  if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(prev, last);\n  return comp > 0;\n};\nexport const isSortedBeforeFirst = input => {\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  const first = input.previousResults[0];\n  if (!first) {\n    return false;\n  }\n  if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(doc, first);\n  return comp < 0;\n};\nexport const isSortedAfterLast = input => {\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  const last = lastOfArray(input.previousResults);\n  if (!last) {\n    return false;\n  }\n  if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(doc, last);\n  return comp > 0;\n};\nexport const wasMatching = input => {\n  const prev = input.changeEvent.previous;\n  if (!prev || prev === UNKNOWN_VALUE) {\n    return false;\n  }\n  return input.queryParams.queryMatcher(prev);\n};\nexport const doesMatchNow = input => {\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  const ret = input.queryParams.queryMatcher(doc);\n  return ret;\n};\nexport const wasResultsEmpty = input => {\n  return input.previousResults.length === 0;\n};","map":{"version":3,"names":["getProperty","lastOfArray","UNKNOWN_VALUE","hasLimit","input","queryParams","limit","isFindOne","hasSkip","skip","isDelete","changeEvent","operation","isInsert","isUpdate","previousUnknown","previous","wasLimitReached","previousResults","length","sortParamsChanged","sortFields","prev","doc","i","field","beforeData","afterData","wasInResult","id","keyDocumentMap","has","primary","primaryKey","results","item","wasFirst","first","wasLast","last","wasSortedBeforeFirst","comp","sortComparator","wasSortedAfterLast","isSortedBeforeFirst","isSortedAfterLast","wasMatching","queryMatcher","doesMatchNow","ret","wasResultsEmpty"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/event-reduce-js/dist/es/states/state-resolver.js"],"sourcesContent":["import { getProperty, lastOfArray, UNKNOWN_VALUE } from '../util';\nexport const hasLimit = (input) => {\n    return !!input.queryParams.limit;\n};\nexport const isFindOne = (input) => {\n    return input.queryParams.limit === 1;\n};\nexport const hasSkip = (input) => {\n    if (input.queryParams.skip && input.queryParams.skip > 0) {\n        return true;\n    }\n    else {\n        return false;\n    }\n};\nexport const isDelete = (input) => {\n    return input.changeEvent.operation === 'DELETE';\n};\nexport const isInsert = (input) => {\n    return input.changeEvent.operation === 'INSERT';\n};\nexport const isUpdate = (input) => {\n    return input.changeEvent.operation === 'UPDATE';\n};\nexport const previousUnknown = (input) => {\n    return input.changeEvent.previous === UNKNOWN_VALUE;\n};\nexport const wasLimitReached = (input) => {\n    return hasLimit(input) && input.previousResults.length >= input.queryParams.limit;\n};\nexport const sortParamsChanged = (input) => {\n    const sortFields = input.queryParams.sortFields;\n    const prev = input.changeEvent.previous;\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    if (!prev || prev === UNKNOWN_VALUE) {\n        return true;\n    }\n    for (let i = 0; i < sortFields.length; i++) {\n        const field = sortFields[i];\n        const beforeData = getProperty(prev, field);\n        const afterData = getProperty(doc, field);\n        if (beforeData !== afterData) {\n            return true;\n        }\n    }\n    return false;\n};\nexport const wasInResult = (input) => {\n    const id = input.changeEvent.id;\n    if (input.keyDocumentMap) {\n        const has = input.keyDocumentMap.has(id);\n        return has;\n    }\n    else {\n        const primary = input.queryParams.primaryKey;\n        const results = input.previousResults;\n        for (let i = 0; i < results.length; i++) {\n            const item = results[i];\n            if (item[primary] === id) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\nexport const wasFirst = (input) => {\n    const first = input.previousResults[0];\n    if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    else {\n        return false;\n    }\n};\nexport const wasLast = (input) => {\n    const last = lastOfArray(input.previousResults);\n    if (last && last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    else {\n        return false;\n    }\n};\nexport const wasSortedBeforeFirst = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev || prev === UNKNOWN_VALUE) {\n        return false;\n    }\n    const first = input.previousResults[0];\n    if (!first) {\n        return false;\n    }\n    /**\n     * If the changed document is the same as the first,\n     * we cannot sort-compare them, because it might end in a non-deterministic\n     * sort order. Because both document could be equal.\n     * So instead we have to return true.\n     */\n    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    const comp = input.queryParams.sortComparator(prev, first);\n    return comp < 0;\n};\nexport const wasSortedAfterLast = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev || prev === UNKNOWN_VALUE) {\n        return false;\n    }\n    const last = lastOfArray(input.previousResults);\n    if (!last) {\n        return false;\n    }\n    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    const comp = input.queryParams.sortComparator(prev, last);\n    return comp > 0;\n};\nexport const isSortedBeforeFirst = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    const first = input.previousResults[0];\n    if (!first) {\n        return false;\n    }\n    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    const comp = input.queryParams.sortComparator(doc, first);\n    return comp < 0;\n};\nexport const isSortedAfterLast = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    const last = lastOfArray(input.previousResults);\n    if (!last) {\n        return false;\n    }\n    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n    const comp = input.queryParams.sortComparator(doc, last);\n    return comp > 0;\n};\nexport const wasMatching = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev || prev === UNKNOWN_VALUE) {\n        return false;\n    }\n    return input.queryParams.queryMatcher(prev);\n};\nexport const doesMatchNow = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    const ret = input.queryParams.queryMatcher(doc);\n    return ret;\n};\nexport const wasResultsEmpty = (input) => {\n    return input.previousResults.length === 0;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}