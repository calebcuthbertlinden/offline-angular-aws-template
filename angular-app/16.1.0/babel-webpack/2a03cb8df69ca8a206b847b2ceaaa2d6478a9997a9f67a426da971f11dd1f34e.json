{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { InjectionToken } from '@angular/core';\nimport { createRxDatabase } from 'rxdb';\nimport { getRxStorageDexie } from 'rxdb/plugins/storage-dexie';\nimport { learnerSchema } from './model/identity';\nimport { nuggetSchema } from './model/nugget';\nimport { replicateRxCollection } from 'rxdb/plugins/replication';\nimport * as i0 from \"@angular/core\";\nexport const APP_STORAGE = new InjectionToken('APP_STORAGE');\nexport const IDENTITY_TABLE = 'identity';\nexport const NUGGET_TABLE = 'nugget';\nclass LocalStorageService {\n  constructor() {}\n  init() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this._database = yield createRxDatabase({\n        name: 'offlinestore' + new Date().getTime(),\n        storage: getRxStorageDexie(),\n        cleanupPolicy: {\n          /**\n           * The minimum time in milliseconds for how long\n           * a document has to be deleted before it is\n           * purged by the cleanup.\n           * [default=one month]\n           */\n          minimumDeletedTime: 1000 * 60 * 60 * 24 * 31,\n          /**\n           * The minimum amount of that that the RxCollection must have existed.\n           * This ensures that at the initial page load, more important\n           * tasks are not slowed down because a cleanup process is running.\n           * [default=60 seconds]\n           */\n          minimumCollectionAge: 1000 * 60,\n          /**\n           * After the initial cleanup is done,\n           * a new cleanup is started after [runEach] milliseconds\n           * [default=5 minutes]\n           */\n          runEach: 1000 * 60 * 5,\n          /**\n           * If set to true,\n           * RxDB will await all running replications\n           * to not have a replication cycle running.\n           * This ensures we do not remove deleted documents\n           * when they might not have already been replicated.\n           * [default=true]\n           */\n          awaitReplicationsInSync: true\n        }\n      });\n      yield _this._database.addCollections({\n        identity: {\n          schema: learnerSchema\n        },\n        nugget: {\n          schema: nuggetSchema\n        }\n      });\n    })();\n  }\n  replicate(collection) {\n    return _asyncToGenerator(function* () {\n      const replicationState = yield replicateRxCollection({\n        collection: collection,\n        /**\n         * An id for the replication to identify it\n         * and so that RxDB is able to resume the replication on app reload.\n         * If you replicate with a remote server, it is recommended to put the\n         * server url into the replicationIdentifier.\n         */\n        replicationIdentifier: 'my-rest-replication-to-https://example.com/api/sync',\n        /**\n         * By default it will do an ongoing realtime replication.\n         * By settings live: false the replication will run once until the local state\n         * is in sync with the remote state, then it will cancel itself.\n         * (optional), default is true.\n         */\n        live: true,\n        /**\n         * Time in milliseconds after when a failed backend request\n         * has to be retried.\n         * This time will be skipped if a offline->online switch is detected\n         * via navigator.onLine\n         * (optional), default is 5 seconds.\n         */\n        retryTime: 5 * 1000,\n        /**\n         * When multiInstance is true, like when you use RxDB in multiple browser tabs,\n         * the replication should always run in only one of the open browser tabs.\n         * If waitForLeadership is true, it will wait until the current instance is leader.\n         * If waitForLeadership is false, it will start replicating, even if it is not leader.\n         * [default=true]\n         */\n        waitForLeadership: true,\n        /**\n         * If this is set to false,\n         * the replication will not start automatically\n         * but will wait for replicationState.start() being called.\n         * (optional), default is true\n         */\n        autoStart: true,\n        /**\n         * Custom deleted field, the boolean property of the document data that\n         * marks a document as being deleted.\n         * If your backend uses a different fieldname then '_deleted', set the fieldname here.\n         * RxDB will still store the documents internally with '_deleted', setting this field\n         * only maps the data on the data layer.\n         *\n         * If a custom deleted field contains a non-boolean value, the deleted state\n         * of the documents depends on if the value is truthy or not. So instead of providing a boolean * * deleted value, you could also work with using a 'deletedAt' timestamp instead.\n         *\n         * [default='_deleted']\n         */\n        deletedField: 'deleted',\n        /**\n         * Optional,\n         * only needed when you want to replicate local changes to the remote instance.\n         */\n        push: {\n          /**\n           * Push handler\n           */\n          handler(docs) {\n            return _asyncToGenerator(function* () {\n              /**\n               * Push the local documents to a remote REST server.\n               */\n              const rawResponse = yield fetch('https://example.com/api/sync/push', {\n                method: 'POST',\n                headers: {\n                  'Accept': 'application/json',\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                  docs\n                })\n              });\n              /**\n               * Contains an array with all conflicts that appeared during this push.\n               * If there were no conflicts, return an empty array.\n               */\n              const response = yield rawResponse.json();\n              return response;\n            })();\n          },\n          /**\n           * Batch size, optional\n           * Defines how many documents will be given to the push handler at once.\n           */\n          batchSize: 5,\n          /**\n           * Modifies all documents before they are given to the push handler.\n           * Can be used to swap out a custom deleted flag instead of the '_deleted' field.\n           * (optional)\n           */\n          modifier: d => d\n        },\n        /**\n         * Optional,\n         * only needed when you want to replicate remote changes to the local state.\n         */\n        pull: {\n          /**\n           * Pull handler\n           */\n          handler(lastCheckpoint, batchSize) {\n            return _asyncToGenerator(function* () {\n              const minTimestamp = lastCheckpoint ? lastCheckpoint.updatedAt : 0;\n              /**\n               * In this example we replicate with a remote REST server\n               */\n              const response = yield fetch(`https://example.com/api/sync/?minUpdatedAt=${minTimestamp}&limit=${batchSize}`);\n              const documentsFromRemote = yield response.json();\n              return {\n                /**\n                 * Contains the pulled documents from the remote.\n                 * Notice: If documentsFromRemote.length < batchSize,\n                 * then RxDB assumes that there are no more un-replicated documents\n                 * on the backend, so the replication will switch to 'Event observation' mode.\n                 */\n                documents: documentsFromRemote,\n                /**\n                 * The last checkpoint of the returned documents.\n                 * On the next call to the pull handler,\n                 * this checkpoint will be passed as 'lastCheckpoint'\n                 */\n                checkpoint: documentsFromRemote.length === 0 ? lastCheckpoint : {\n                  id: lastOfArray(documentsFromRemote).id,\n                  updatedAt: lastOfArray(documentsFromRemote).updatedAt\n                }\n              };\n            })();\n          },\n          batchSize: 10,\n          /**\n           * Modifies all documents after they have been pulled\n           * but before they are used by RxDB.\n           * (optional)\n           */\n          modifier: d => d,\n          /**\n           * Stream of the backend document writes.\n           * See below.\n           * You only need a stream$ when you have set live=true\n           */\n          stream$: pullStream$.asObservable()\n        }\n      });\n    })();\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Getter for database\n   */\n  get database() {\n    return this._database;\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be inserted.\n   * @param body - The data object representing the record to be inserted.\n   * @returns A Promise that resolves to void once the record has been successfully inserted.\n   *\n   * @example\n   * await post('orders', { id: 1, product: 'Phone', quantity: 2 });\n   * // Inserts a new record into the 'orders' table with the provided data.\n   */\n  post(table, body) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2.database[table].insert(body);\n    })();\n  }\n  /**\n   * Retrieves a record from the specified table in the local offline storage based on the provided ID.\n   *\n   * @param table - The name of the table from which the record will be retrieved.\n   * @param id - The ID of the record to be retrieved.\n   * @returns A Promise that resolves to the retrieved record.\n   *\n   * @example\n   * const order = await get('orders', '456');\n   * // Retrieves the record with ID '456' from the 'orders' table.\n   */\n  get(table, id) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3.database[table].findOne(id).exec();\n    })();\n  }\n  getCollection(table) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return _this4.database[table].find().exec();\n    })();\n  }\n  /**\n   * Retrieves an Observable stream of records from the specified table in the local offline storage.\n   *\n   * @param table - The name of the table from which the records will be retrieved.\n   * @returns An Observable that emits the records from the specified table.\n   *\n   * @example\n   * // Example usage:\n   * const users$ = get$('users');\n   * users$.subscribe((users) => {\n   *   console.log(users);\n   * });\n   * // Retrieves the records from the 'users' table and logs the emitted records whenever there is an update.\n   *\n   * @example\n   * // Example usage with async pipe:\n   * const orders$ = get$('orders');\n   * // In Angular template:\n   * <ng-container *ngIf=\"(orders$ | async) as orders\">\n   *   <!-- Display orders -->\n   * </ng-container>\n   * // Retrieves the records from the 'orders' table and uses the async pipe to subscribe to the Observable and handle the emitted values in the template.\n   */\n  get$(table) {\n    return this.database[table].$;\n  }\n  /**\n   * Updates an existing record or inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be updated or inserted.\n   * @param body - The data object representing the record to be updated or inserted.\n   * @returns A Promise that resolves to void once the record has been successfully updated or inserted.\n   *\n   * @example\n   * await put('users', { id: '123', name: 'John Doe', age: 30 });\n   * // Updates the record with ID '123' in the 'users' table if it exists, or inserts a new record with the provided data if the record doesn't exist.\n   */\n  put(table, body) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      yield _this5.database[table].upsert(body);\n    })();\n  }\n  /**\n   * DELETE\n   */\n  delete() {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * REMOVE\n   */\n  deleteCollection(table) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      yield _this6.database[table].remove();\n    })();\n  }\n  /**\n   * Destroy\n   */\n  destroyCollection(table) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      yield _this7.database[table].destroy();\n    })();\n  }\n}\nLocalStorageService.ɵfac = function LocalStorageService_Factory(t) {\n  return new (t || LocalStorageService)();\n};\nLocalStorageService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: LocalStorageService,\n  factory: LocalStorageService.ɵfac,\n  providedIn: 'root'\n});\nexport { LocalStorageService };","map":{"version":3,"names":["InjectionToken","createRxDatabase","getRxStorageDexie","learnerSchema","nuggetSchema","replicateRxCollection","APP_STORAGE","IDENTITY_TABLE","NUGGET_TABLE","LocalStorageService","constructor","init","_this","_asyncToGenerator","_database","name","Date","getTime","storage","cleanupPolicy","minimumDeletedTime","minimumCollectionAge","runEach","awaitReplicationsInSync","addCollections","identity","schema","nugget","replicate","collection","replicationState","replicationIdentifier","live","retryTime","waitForLeadership","autoStart","deletedField","push","handler","docs","rawResponse","fetch","method","headers","body","JSON","stringify","response","json","batchSize","modifier","d","pull","lastCheckpoint","minTimestamp","updatedAt","documentsFromRemote","documents","checkpoint","length","id","lastOfArray","stream$","pullStream$","asObservable","database","post","table","_this2","insert","get","_this3","findOne","exec","getCollection","_this4","find","get$","$","put","_this5","upsert","delete","deleteCollection","_this6","remove","destroyCollection","_this7","destroy","factory","ɵfac","providedIn"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/src/app/data/local-storage.ts"],"sourcesContent":["import { Injectable, InjectionToken } from '@angular/core';\nimport { RxDatabase, RxStorage, createRxDatabase, removeRxDatabase } from 'rxdb';\nimport { getRxStorageDexie } from 'rxdb/plugins/storage-dexie';\nimport { learnerSchema } from './model/identity';\nimport { nuggetSchema } from './model/nugget';\nimport { Observable } from 'rxjs';\nimport { replicateRxCollection } from 'rxdb/plugins/replication';\n\nexport const APP_STORAGE = new InjectionToken<any>('APP_STORAGE');\nexport const IDENTITY_TABLE = 'identity';\nexport const NUGGET_TABLE = 'nugget';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocalStorageService {\n  // private _database: BehaviorSubject<any>;\n  private _database: RxDatabase | undefined;\n\n  constructor() {}\n\n  async init() {\n    this._database = await createRxDatabase({\n      name: 'offlinestore'+ new Date().getTime(),\n      storage: getRxStorageDexie(),\n      cleanupPolicy: {\n        /**\n         * The minimum time in milliseconds for how long\n         * a document has to be deleted before it is\n         * purged by the cleanup.\n         * [default=one month]\n         */\n        minimumDeletedTime: 1000 * 60 * 60 * 24 * 31, // one month,\n        /**\n         * The minimum amount of that that the RxCollection must have existed.\n         * This ensures that at the initial page load, more important\n         * tasks are not slowed down because a cleanup process is running.\n         * [default=60 seconds]\n         */\n        minimumCollectionAge: 1000 * 60, // 60 seconds\n        /**\n         * After the initial cleanup is done,\n         * a new cleanup is started after [runEach] milliseconds\n         * [default=5 minutes]\n         */\n        runEach: 1000 * 60 * 5, // 5 minutes\n        /**\n         * If set to true,\n         * RxDB will await all running replications\n         * to not have a replication cycle running.\n         * This ensures we do not remove deleted documents\n         * when they might not have already been replicated.\n         * [default=true]\n         */\n        awaitReplicationsInSync: true,\n      }\n    });\n\n    await this._database.addCollections({\n      identity: {\n        schema: learnerSchema\n      },\n      nugget: {\n        schema: nuggetSchema\n      }\n    });\n  }\n\n  async replicate(collection:any) {\n    const replicationState = await replicateRxCollection({\n      collection: collection,\n      /**\n       * An id for the replication to identify it\n       * and so that RxDB is able to resume the replication on app reload.\n       * If you replicate with a remote server, it is recommended to put the\n       * server url into the replicationIdentifier.\n       */\n      replicationIdentifier: 'my-rest-replication-to-https://example.com/api/sync',\n      /**\n       * By default it will do an ongoing realtime replication.\n       * By settings live: false the replication will run once until the local state\n       * is in sync with the remote state, then it will cancel itself.\n       * (optional), default is true.\n       */\n      live: true,\n      /**\n       * Time in milliseconds after when a failed backend request\n       * has to be retried.\n       * This time will be skipped if a offline->online switch is detected\n       * via navigator.onLine\n       * (optional), default is 5 seconds.\n       */\n      retryTime: 5 * 1000,\n      /**\n       * When multiInstance is true, like when you use RxDB in multiple browser tabs,\n       * the replication should always run in only one of the open browser tabs.\n       * If waitForLeadership is true, it will wait until the current instance is leader.\n       * If waitForLeadership is false, it will start replicating, even if it is not leader.\n       * [default=true]\n       */\n      waitForLeadership: true,\n      /**\n       * If this is set to false,\n       * the replication will not start automatically\n       * but will wait for replicationState.start() being called.\n       * (optional), default is true\n       */\n      autoStart: true,\n  \n      /**\n       * Custom deleted field, the boolean property of the document data that\n       * marks a document as being deleted.\n       * If your backend uses a different fieldname then '_deleted', set the fieldname here.\n       * RxDB will still store the documents internally with '_deleted', setting this field\n       * only maps the data on the data layer.\n       * \n       * If a custom deleted field contains a non-boolean value, the deleted state\n       * of the documents depends on if the value is truthy or not. So instead of providing a boolean * * deleted value, you could also work with using a 'deletedAt' timestamp instead.\n       * \n       * [default='_deleted']\n       */\n      deletedField: 'deleted',\n  \n      /**\n       * Optional,\n       * only needed when you want to replicate local changes to the remote instance.\n       */\n      push: {\n          /**\n           * Push handler\n           */\n          async handler(docs) {\n              /**\n               * Push the local documents to a remote REST server.\n               */\n              const rawResponse = await fetch('https://example.com/api/sync/push', {\n                  method: 'POST',\n                  headers: {\n                      'Accept': 'application/json',\n                      'Content-Type': 'application/json'\n                  },\n                  body: JSON.stringify({ docs })\n              });\n              /**\n               * Contains an array with all conflicts that appeared during this push.\n               * If there were no conflicts, return an empty array.\n               */\n              const response = await rawResponse.json();\n              return response;\n          },\n          /**\n           * Batch size, optional\n           * Defines how many documents will be given to the push handler at once.\n           */\n          batchSize: 5,\n          /**\n           * Modifies all documents before they are given to the push handler.\n           * Can be used to swap out a custom deleted flag instead of the '_deleted' field.\n           * (optional)\n           */\n          modifier: d => d\n      },\n      /**\n       * Optional,\n       * only needed when you want to replicate remote changes to the local state.\n       */\n      pull: {\n          /**\n           * Pull handler\n           */\n          async handler(lastCheckpoint, batchSize) {\n              const minTimestamp = lastCheckpoint ? lastCheckpoint.updatedAt : 0;\n              /**\n               * In this example we replicate with a remote REST server\n               */\n              const response = await fetch(\n                  `https://example.com/api/sync/?minUpdatedAt=${minTimestamp}&limit=${batchSize}`\n              );\n              const documentsFromRemote = await response.json();\n              return {\n                  /**\n                   * Contains the pulled documents from the remote.\n                   * Notice: If documentsFromRemote.length < batchSize,\n                   * then RxDB assumes that there are no more un-replicated documents\n                   * on the backend, so the replication will switch to 'Event observation' mode.\n                   */\n                  documents: documentsFromRemote,\n                  /**\n                   * The last checkpoint of the returned documents.\n                   * On the next call to the pull handler,\n                   * this checkpoint will be passed as 'lastCheckpoint'\n                   */\n                  checkpoint: documentsFromRemote.length === 0 ? lastCheckpoint : {\n                      id: lastOfArray(documentsFromRemote).id,\n                      updatedAt: lastOfArray(documentsFromRemote).updatedAt\n                  }\n              };\n          },\n          batchSize: 10,\n          /**\n           * Modifies all documents after they have been pulled\n           * but before they are used by RxDB.\n           * (optional)\n           */\n          modifier: d => d,\n          /**\n           * Stream of the backend document writes.\n           * See below.\n           * You only need a stream$ when you have set live=true\n           */\n          stream$: pullStream$.asObservable()\n      },\n  });\n  }\n\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n\n  /**\n   * Getter for database\n   */\n  get database(): RxDatabase {\n    return this._database as RxDatabase;\n  }\n\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n\n  /**\n   * Inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be inserted.\n   * @param body - The data object representing the record to be inserted.\n   * @returns A Promise that resolves to void once the record has been successfully inserted.\n   *\n   * @example\n   * await post('orders', { id: 1, product: 'Phone', quantity: 2 });\n   * // Inserts a new record into the 'orders' table with the provided data.\n   */\n  async post(table: string, body: any): Promise<void> {\n    await this.database[table].insert(body);\n  }\n\n  /**\n   * Retrieves a record from the specified table in the local offline storage based on the provided ID.\n   *\n   * @param table - The name of the table from which the record will be retrieved.\n   * @param id - The ID of the record to be retrieved.\n   * @returns A Promise that resolves to the retrieved record.\n   *\n   * @example\n   * const order = await get('orders', '456');\n   * // Retrieves the record with ID '456' from the 'orders' table.\n   */\n  async get(table: string, id: string): Promise<any> {\n    return this.database[table].findOne(id).exec();\n  }\n\n  async getCollection(table: string): Promise<any> {\n    return this.database[table].find().exec();\n  }\n\n\n  /**\n   * Retrieves an Observable stream of records from the specified table in the local offline storage.\n   *\n   * @param table - The name of the table from which the records will be retrieved.\n   * @returns An Observable that emits the records from the specified table.\n   *\n   * @example\n   * // Example usage:\n   * const users$ = get$('users');\n   * users$.subscribe((users) => {\n   *   console.log(users);\n   * });\n   * // Retrieves the records from the 'users' table and logs the emitted records whenever there is an update.\n   *\n   * @example\n   * // Example usage with async pipe:\n   * const orders$ = get$('orders');\n   * // In Angular template:\n   * <ng-container *ngIf=\"(orders$ | async) as orders\">\n   *   <!-- Display orders -->\n   * </ng-container>\n   * // Retrieves the records from the 'orders' table and uses the async pipe to subscribe to the Observable and handle the emitted values in the template.\n   */\n  get$(table: string): Observable<any> {\n    return this.database[table].$;\n  }\n\n  /**\n   * Updates an existing record or inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be updated or inserted.\n   * @param body - The data object representing the record to be updated or inserted.\n   * @returns A Promise that resolves to void once the record has been successfully updated or inserted.\n   *\n   * @example\n   * await put('users', { id: '123', name: 'John Doe', age: 30 });\n   * // Updates the record with ID '123' in the 'users' table if it exists, or inserts a new record with the provided data if the record doesn't exist.\n   */\n  async put(table: string, body: any): Promise<void> {\n    await this.database[table].upsert(body);\n  }\n\n\n  /**\n   * DELETE\n   */\n  async delete(): Promise<void> {\n\n  }\n\n  /**\n   * REMOVE\n   */\n  async deleteCollection(table: string): Promise<void> {\n    await this.database[table].remove();\n  }\n\n  /**\n   * Destroy\n   */\n  async destroyCollection(table: string): Promise<void> {\n    await this.database[table].destroy();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}