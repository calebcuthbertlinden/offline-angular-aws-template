{"ast":null,"code":"import { getFromMapOrCreate, getFromMapOrThrow, getHeightOfRevision } from './plugins/utils';\nimport { overwritable } from './overwritable';\nimport { getDocumentDataOfRxChangeEvent } from './rx-change-event';\n\n/**\n * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n */\n\n/**\n * The DocumentCache stores RxDocument objects\n * by their primary key and revision.\n * This is useful on client side applications where\n * it is not known how much memory can be used, so\n * we de-duplicate RxDocument states to save memory.\n * To not fill up the memory with old document states, the DocumentCache\n * only contains weak references to the RxDocuments themself.\n * @link https://caniuse.com/?search=weakref\n */\nexport var DocumentCache = /*#__PURE__*/function () {\n  /**\n   * Some JavaScript runtimes like QuickJS,\n   * so not have a FinalizationRegistry or WeakRef.\n   * Therefore we need a workaround which might waste a lot of memory,\n   * but at least works.\n   */\n\n  function DocumentCache(primaryPath, changes$,\n  /**\n   * A method that can create a RxDocument by the given document data.\n   */\n  documentCreator) {\n    this.cacheItemByDocId = new Map();\n    this.registry = typeof FinalizationRegistry === 'function' ? new FinalizationRegistry(docMeta => {\n      var docId = docMeta.docId;\n      var cacheItem = this.cacheItemByDocId.get(docId);\n      if (cacheItem) {\n        cacheItem.documentByRevisionHeight.delete(docMeta.revisionHeight);\n        if (cacheItem.documentByRevisionHeight.size === 0) {\n          /**\n           * No state of the document is cached anymore,\n           * so we can clean up.\n           */\n          this.cacheItemByDocId.delete(docId);\n        }\n      }\n    }) : undefined;\n    this.primaryPath = primaryPath;\n    this.changes$ = changes$;\n    this.documentCreator = documentCreator;\n    changes$.subscribe(changeEvent => {\n      var docId = changeEvent.documentId;\n      var cacheItem = this.cacheItemByDocId.get(docId);\n      if (cacheItem) {\n        var documentData = getDocumentDataOfRxChangeEvent(changeEvent);\n        cacheItem.latestDoc = documentData;\n      }\n    });\n  }\n\n  /**\n   * Get the RxDocument from the cache\n   * and create a new one if not exits before.\n   */\n  var _proto = DocumentCache.prototype;\n  _proto.getCachedRxDocument = function getCachedRxDocument(docData) {\n    var docId = docData[this.primaryPath];\n    var revisionHeight = getHeightOfRevision(docData._rev);\n    var cacheItem = getFromMapOrCreate(this.cacheItemByDocId, docId, () => getNewCacheItem(docData));\n    var cachedRxDocumentWeakRef = cacheItem.documentByRevisionHeight.get(revisionHeight);\n    var cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : undefined;\n    if (!cachedRxDocument) {\n      docData = overwritable.deepFreezeWhenDevMode(docData);\n      cachedRxDocument = this.documentCreator(docData);\n      cacheItem.documentByRevisionHeight.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));\n      if (this.registry) {\n        this.registry.register(cachedRxDocument, {\n          docId,\n          revisionHeight\n        });\n      }\n    }\n    return cachedRxDocument;\n  }\n\n  /**\n   * Throws if not exists\n   */;\n  _proto.getLatestDocumentData = function getLatestDocumentData(docId) {\n    var cacheItem = getFromMapOrThrow(this.cacheItemByDocId, docId);\n    return cacheItem.latestDoc;\n  };\n  _proto.getLatestDocumentDataIfExists = function getLatestDocumentDataIfExists(docId) {\n    var cacheItem = this.cacheItemByDocId.get(docId);\n    if (cacheItem) {\n      return cacheItem.latestDoc;\n    }\n  };\n  return DocumentCache;\n}();\nfunction getNewCacheItem(docData) {\n  return {\n    documentByRevisionHeight: new Map(),\n    latestDoc: docData\n  };\n}\n\n/**\n * Fallback for JavaScript runtimes that do not support WeakRef.\n * The fallback will keep the items in cache forever,\n * but at least works.\n */\nvar HAS_WEAK_REF = typeof WeakRef === 'function';\nfunction createWeakRefWithFallback(obj) {\n  if (HAS_WEAK_REF) {\n    return new WeakRef(obj);\n  } else {\n    return {\n      deref() {\n        return obj;\n      }\n    };\n  }\n}","map":{"version":3,"names":["getFromMapOrCreate","getFromMapOrThrow","getHeightOfRevision","overwritable","getDocumentDataOfRxChangeEvent","DocumentCache","primaryPath","changes$","documentCreator","cacheItemByDocId","Map","registry","FinalizationRegistry","docMeta","docId","cacheItem","get","documentByRevisionHeight","delete","revisionHeight","size","undefined","subscribe","changeEvent","documentId","documentData","latestDoc","_proto","prototype","getCachedRxDocument","docData","_rev","getNewCacheItem","cachedRxDocumentWeakRef","cachedRxDocument","deref","deepFreezeWhenDevMode","set","createWeakRefWithFallback","register","getLatestDocumentData","getLatestDocumentDataIfExists","HAS_WEAK_REF","WeakRef","obj"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/doc-cache.js"],"sourcesContent":["import { getFromMapOrCreate, getFromMapOrThrow, getHeightOfRevision } from './plugins/utils';\nimport { overwritable } from './overwritable';\nimport { getDocumentDataOfRxChangeEvent } from './rx-change-event';\n\n/**\n * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n */\n\n/**\n * The DocumentCache stores RxDocument objects\n * by their primary key and revision.\n * This is useful on client side applications where\n * it is not known how much memory can be used, so\n * we de-duplicate RxDocument states to save memory.\n * To not fill up the memory with old document states, the DocumentCache\n * only contains weak references to the RxDocuments themself.\n * @link https://caniuse.com/?search=weakref\n */\nexport var DocumentCache = /*#__PURE__*/function () {\n  /**\n   * Some JavaScript runtimes like QuickJS,\n   * so not have a FinalizationRegistry or WeakRef.\n   * Therefore we need a workaround which might waste a lot of memory,\n   * but at least works.\n   */\n\n  function DocumentCache(primaryPath, changes$,\n  /**\n   * A method that can create a RxDocument by the given document data.\n   */\n  documentCreator) {\n    this.cacheItemByDocId = new Map();\n    this.registry = typeof FinalizationRegistry === 'function' ? new FinalizationRegistry(docMeta => {\n      var docId = docMeta.docId;\n      var cacheItem = this.cacheItemByDocId.get(docId);\n      if (cacheItem) {\n        cacheItem.documentByRevisionHeight.delete(docMeta.revisionHeight);\n        if (cacheItem.documentByRevisionHeight.size === 0) {\n          /**\n           * No state of the document is cached anymore,\n           * so we can clean up.\n           */\n          this.cacheItemByDocId.delete(docId);\n        }\n      }\n    }) : undefined;\n    this.primaryPath = primaryPath;\n    this.changes$ = changes$;\n    this.documentCreator = documentCreator;\n    changes$.subscribe(changeEvent => {\n      var docId = changeEvent.documentId;\n      var cacheItem = this.cacheItemByDocId.get(docId);\n      if (cacheItem) {\n        var documentData = getDocumentDataOfRxChangeEvent(changeEvent);\n        cacheItem.latestDoc = documentData;\n      }\n    });\n  }\n\n  /**\n   * Get the RxDocument from the cache\n   * and create a new one if not exits before.\n   */\n  var _proto = DocumentCache.prototype;\n  _proto.getCachedRxDocument = function getCachedRxDocument(docData) {\n    var docId = docData[this.primaryPath];\n    var revisionHeight = getHeightOfRevision(docData._rev);\n    var cacheItem = getFromMapOrCreate(this.cacheItemByDocId, docId, () => getNewCacheItem(docData));\n    var cachedRxDocumentWeakRef = cacheItem.documentByRevisionHeight.get(revisionHeight);\n    var cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : undefined;\n    if (!cachedRxDocument) {\n      docData = overwritable.deepFreezeWhenDevMode(docData);\n      cachedRxDocument = this.documentCreator(docData);\n      cacheItem.documentByRevisionHeight.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));\n      if (this.registry) {\n        this.registry.register(cachedRxDocument, {\n          docId,\n          revisionHeight\n        });\n      }\n    }\n    return cachedRxDocument;\n  }\n\n  /**\n   * Throws if not exists\n   */;\n  _proto.getLatestDocumentData = function getLatestDocumentData(docId) {\n    var cacheItem = getFromMapOrThrow(this.cacheItemByDocId, docId);\n    return cacheItem.latestDoc;\n  };\n  _proto.getLatestDocumentDataIfExists = function getLatestDocumentDataIfExists(docId) {\n    var cacheItem = this.cacheItemByDocId.get(docId);\n    if (cacheItem) {\n      return cacheItem.latestDoc;\n    }\n  };\n  return DocumentCache;\n}();\nfunction getNewCacheItem(docData) {\n  return {\n    documentByRevisionHeight: new Map(),\n    latestDoc: docData\n  };\n}\n\n/**\n * Fallback for JavaScript runtimes that do not support WeakRef.\n * The fallback will keep the items in cache forever,\n * but at least works.\n */\nvar HAS_WEAK_REF = typeof WeakRef === 'function';\nfunction createWeakRefWithFallback(obj) {\n  if (HAS_WEAK_REF) {\n    return new WeakRef(obj);\n  } else {\n    return {\n      deref() {\n        return obj;\n      }\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}