{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { firstValueFrom, filter } from 'rxjs';\nimport { newRxError } from '../rx-error';\nimport { stackCheckpoints } from '../rx-storage-helper';\nimport { appendToArray, createRevision, ensureNotFalsy, flatClone, getDefaultRevision, getDefaultRxDocumentMeta, parseRevision, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_VOID } from '../plugins/utils';\nimport { getLastCheckpointDoc, setCheckpoint } from './checkpoint';\nimport { writeDocToDocState } from './helper';\nimport { getAssumedMasterState, getMetaWriteRow } from './meta-instance';\n\n/**\n * Writes all documents from the master to the fork.\n * The downstream has two operation modes\n * - Sync by iterating over the checkpoints via downstreamResyncOnce()\n * - Sync by listening to the changestream via downstreamProcessChanges()\n * We need this to be able to do initial syncs\n * and still can have fast event based sync when the client is not offline.\n */\nexport function startReplicationDownstream(_x) {\n  return _startReplicationDownstream.apply(this, arguments);\n}\nfunction _startReplicationDownstream() {\n  _startReplicationDownstream = _asyncToGenerator(function* (state) {\n    if (state.input.initialCheckpoint && state.input.initialCheckpoint.downstream) {\n      var checkpointDoc = yield getLastCheckpointDoc(state, 'down');\n      if (!checkpointDoc) {\n        yield setCheckpoint(state, 'down', state.input.initialCheckpoint.downstream);\n      }\n    }\n    var identifierHash = state.input.hashFunction(state.input.identifier);\n    var replicationHandler = state.input.replicationHandler;\n\n    // used to detect which tasks etc can in it at which order.\n    var timer = 0;\n    var openTasks = [];\n    function addNewTask(task) {\n      state.stats.down.addNewTask = state.stats.down.addNewTask + 1;\n      var taskWithTime = {\n        time: timer++,\n        task\n      };\n      openTasks.push(taskWithTime);\n      state.streamQueue.down = state.streamQueue.down.then(() => {\n        var useTasks = [];\n        while (openTasks.length > 0) {\n          state.events.active.down.next(true);\n          var innerTaskWithTime = ensureNotFalsy(openTasks.shift());\n\n          /**\n           * If the task came in before the last time we started the pull\n           * from the master, then we can drop the task.\n           */\n          if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {\n            continue;\n          }\n          if (innerTaskWithTime.task === 'RESYNC') {\n            if (useTasks.length === 0) {\n              useTasks.push(innerTaskWithTime.task);\n              break;\n            } else {\n              break;\n            }\n          }\n          useTasks.push(innerTaskWithTime.task);\n        }\n        if (useTasks.length === 0) return;\n        if (useTasks[0] === 'RESYNC') {\n          return downstreamResyncOnce();\n        } else {\n          return downstreamProcessChanges(useTasks);\n        }\n      }).then(() => {\n        state.events.active.down.next(false);\n        if (!state.firstSyncDone.down.getValue() && !state.events.canceled.getValue()) {\n          state.firstSyncDone.down.next(true);\n        }\n      });\n    }\n    addNewTask('RESYNC');\n\n    /**\n     * If a write on the master happens, we have to trigger the downstream.\n     */\n    var sub = replicationHandler.masterChangeStream$.subscribe(task => {\n      state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;\n      addNewTask(task);\n    });\n    firstValueFrom(state.events.canceled.pipe(filter(canceled => !!canceled))).then(() => sub.unsubscribe());\n\n    /**\n     * For faster performance, we directly start each write\n     * and then await all writes at the end.\n     */\n    var lastTimeMasterChangesRequested = -1;\n    function downstreamResyncOnce() {\n      return _downstreamResyncOnce.apply(this, arguments);\n    }\n    function _downstreamResyncOnce() {\n      _downstreamResyncOnce = _asyncToGenerator(function* () {\n        state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;\n        if (state.events.canceled.getValue()) {\n          return;\n        }\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'down'));\n        var lastCheckpoint = yield state.checkpointQueue;\n        var promises = [];\n        while (!state.events.canceled.getValue()) {\n          lastTimeMasterChangesRequested = timer++;\n          var downResult = yield replicationHandler.masterChangesSince(lastCheckpoint, state.input.pullBatchSize);\n          if (downResult.documents.length === 0) {\n            break;\n          }\n          lastCheckpoint = stackCheckpoints([lastCheckpoint, downResult.checkpoint]);\n          promises.push(persistFromMaster(downResult.documents, lastCheckpoint));\n\n          /**\n           * By definition we stop pull when the pulled documents\n           * do not fill up the pullBatchSize because we\n           * can assume that the remote has no more documents.\n           */\n          if (downResult.documents.length < state.input.pullBatchSize) {\n            break;\n          }\n        }\n        yield Promise.all(promises);\n      });\n      return _downstreamResyncOnce.apply(this, arguments);\n    }\n    function downstreamProcessChanges(tasks) {\n      state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;\n      var docsOfAllTasks = [];\n      var lastCheckpoint = null;\n      tasks.forEach(task => {\n        if (task === 'RESYNC') {\n          throw new Error('SNH');\n        }\n        appendToArray(docsOfAllTasks, task.documents);\n        lastCheckpoint = stackCheckpoints([lastCheckpoint, task.checkpoint]);\n      });\n      return persistFromMaster(docsOfAllTasks, ensureNotFalsy(lastCheckpoint));\n    }\n\n    /**\n     * It can happen that the calls to masterChangesSince() or the changeStream()\n     * are way faster then how fast the documents can be persisted.\n     * Therefore we merge all incoming downResults into the nonPersistedFromMaster object\n     * and process them together if possible.\n     * This often bundles up single writes and improves performance\n     * by processing the documents in bulks.\n     */\n    var persistenceQueue = PROMISE_RESOLVE_VOID;\n    var nonPersistedFromMaster = {\n      docs: {}\n    };\n    function persistFromMaster(docs, checkpoint) {\n      state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;\n\n      /**\n       * Add the new docs to the non-persistent list\n       */\n      docs.forEach(docData => {\n        var docId = docData[state.primaryPath];\n        nonPersistedFromMaster.docs[docId] = docData;\n      });\n      nonPersistedFromMaster.checkpoint = checkpoint;\n\n      /**\n       * Run in the queue\n       * with all open documents from nonPersistedFromMaster.\n       */\n      persistenceQueue = persistenceQueue.then(() => {\n        var downDocsById = nonPersistedFromMaster.docs;\n        nonPersistedFromMaster.docs = {};\n        var useCheckpoint = nonPersistedFromMaster.checkpoint;\n        var docIds = Object.keys(downDocsById);\n        if (state.events.canceled.getValue() || docIds.length === 0) {\n          return PROMISE_RESOLVE_VOID;\n        }\n        var writeRowsToFork = [];\n        var writeRowsToForkById = {};\n        var writeRowsToMeta = {};\n        var useMetaWriteRows = [];\n        return Promise.all([state.input.forkInstance.findDocumentsById(docIds, true), getAssumedMasterState(state, docIds)]).then(([currentForkState, assumedMasterState]) => {\n          return Promise.all(docIds.map( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (docId) {\n              var forkStateFullDoc = currentForkState[docId];\n              var forkStateDocData = forkStateFullDoc ? writeDocToDocState(forkStateFullDoc) : undefined;\n              var masterState = downDocsById[docId];\n              var assumedMaster = assumedMasterState[docId];\n              if (assumedMaster && assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev) {\n                /**\n                 * The current fork state represents a resolved conflict\n                 * that first must be send to the master in the upstream.\n                 * All conflicts are resolved by the upstream.\n                 */\n                return PROMISE_RESOLVE_VOID;\n              }\n              var isAssumedMasterEqualToForkStatePromise = !assumedMaster || !forkStateDocData ? PROMISE_RESOLVE_FALSE : state.input.conflictHandler({\n                realMasterState: assumedMaster.docData,\n                newDocumentState: forkStateDocData\n              }, 'downstream-check-if-equal-0').then(r => r.isEqual);\n              var isAssumedMasterEqualToForkState = yield isAssumedMasterEqualToForkStatePromise;\n              if (!isAssumedMasterEqualToForkState && assumedMaster && assumedMaster.docData._rev && forkStateFullDoc._meta[state.input.identifier] && parseRevision(forkStateFullDoc._rev).height === forkStateFullDoc._meta[state.input.identifier]) {\n                isAssumedMasterEqualToForkState = true;\n              }\n              if (forkStateFullDoc && assumedMaster && isAssumedMasterEqualToForkState === false || forkStateFullDoc && !assumedMaster) {\n                /**\n                 * We have a non-upstream-replicated\n                 * local write to the fork.\n                 * This means we ignore the downstream of this document\n                 * because anyway the upstream will first resolve the conflict.\n                 */\n                return PROMISE_RESOLVE_VOID;\n              }\n              var areStatesExactlyEqualPromise = !forkStateDocData ? PROMISE_RESOLVE_FALSE : state.input.conflictHandler({\n                realMasterState: masterState,\n                newDocumentState: forkStateDocData\n              }, 'downstream-check-if-equal-1').then(r => r.isEqual);\n              var areStatesExactlyEqual = yield areStatesExactlyEqualPromise;\n              if (forkStateDocData && areStatesExactlyEqual) {\n                /**\n                 * Document states are exactly equal.\n                 * This can happen when the replication is shut down\n                 * unexpected like when the user goes offline.\n                 *\n                 * Only when the assumedMaster is different from the forkState,\n                 * we have to patch the document in the meta instance.\n                 */\n                if (!assumedMaster || isAssumedMasterEqualToForkState === false) {\n                  useMetaWriteRows.push(getMetaWriteRow(state, forkStateDocData, assumedMaster ? assumedMaster.metaDocument : undefined));\n                }\n                return PROMISE_RESOLVE_VOID;\n              }\n\n              /**\n               * All other master states need to be written to the forkInstance\n               * and metaInstance.\n               */\n              var newForkState = Object.assign({}, masterState, forkStateFullDoc ? {\n                _meta: flatClone(forkStateFullDoc._meta),\n                _attachments: {},\n                _rev: getDefaultRevision()\n              } : {\n                _meta: getDefaultRxDocumentMeta(),\n                _rev: getDefaultRevision(),\n                _attachments: {}\n              });\n              /**\n               * If the remote works with revisions,\n               * we store the height of the next fork-state revision\n               * inside of the documents meta data.\n               * By doing so we can filter it out in the upstream\n               * and detect the document as being equal to master or not.\n               * This is used for example in the CouchDB replication plugin.\n               */\n              if (masterState._rev) {\n                var nextRevisionHeight = !forkStateFullDoc ? 1 : parseRevision(forkStateFullDoc._rev).height + 1;\n                newForkState._meta[state.input.identifier] = nextRevisionHeight;\n              }\n              var forkWriteRow = {\n                previous: forkStateFullDoc,\n                document: newForkState\n              };\n              forkWriteRow.document._rev = createRevision(identifierHash, forkWriteRow.previous);\n              writeRowsToFork.push(forkWriteRow);\n              writeRowsToForkById[docId] = forkWriteRow;\n              writeRowsToMeta[docId] = getMetaWriteRow(state, masterState, assumedMaster ? assumedMaster.metaDocument : undefined);\n            });\n            return function (_x2) {\n              return _ref.apply(this, arguments);\n            };\n          }()));\n        }).then(() => {\n          if (writeRowsToFork.length > 0) {\n            return state.input.forkInstance.bulkWrite(writeRowsToFork, state.downstreamBulkWriteFlag).then(forkWriteResult => {\n              Object.keys(forkWriteResult.success).forEach(docId => {\n                state.events.processed.down.next(writeRowsToForkById[docId]);\n                useMetaWriteRows.push(writeRowsToMeta[docId]);\n              });\n              Object.values(forkWriteResult.error).forEach(error => {\n                /**\n                 * We do not have to care about downstream conflict errors here\n                 * because on conflict, it will be solved locally and result in another write.\n                 */\n                if (error.status === 409) {\n                  return;\n                }\n                // other non-conflict errors must be handled\n                state.events.error.next(newRxError('RC_PULL', {\n                  writeError: error\n                }));\n              });\n            });\n          }\n        }).then(() => {\n          if (useMetaWriteRows.length > 0) {\n            return state.input.metaInstance.bulkWrite(useMetaWriteRows, 'replication-down-write-meta').then(metaWriteResult => {\n              Object.entries(metaWriteResult.error).forEach(([docId, writeError]) => {\n                state.events.error.next(newRxError('RC_PULL', {\n                  id: docId,\n                  writeError\n                }));\n              });\n            });\n          }\n        }).then(() => {\n          /**\n           * For better performance we do not await checkpoint writes,\n           * but to ensure order on parallel checkpoint writes,\n           * we have to use a queue.\n           */\n          state.checkpointQueue = state.checkpointQueue.then(() => setCheckpoint(state, 'down', useCheckpoint));\n        });\n      }).catch(unhandledError => state.events.error.next(unhandledError));\n      return persistenceQueue;\n    }\n  });\n  return _startReplicationDownstream.apply(this, arguments);\n}","map":{"version":3,"names":["firstValueFrom","filter","newRxError","stackCheckpoints","appendToArray","createRevision","ensureNotFalsy","flatClone","getDefaultRevision","getDefaultRxDocumentMeta","parseRevision","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_VOID","getLastCheckpointDoc","setCheckpoint","writeDocToDocState","getAssumedMasterState","getMetaWriteRow","startReplicationDownstream","_x","_startReplicationDownstream","apply","arguments","_asyncToGenerator","state","input","initialCheckpoint","downstream","checkpointDoc","identifierHash","hashFunction","identifier","replicationHandler","timer","openTasks","addNewTask","task","stats","down","taskWithTime","time","push","streamQueue","then","useTasks","length","events","active","next","innerTaskWithTime","shift","lastTimeMasterChangesRequested","downstreamResyncOnce","downstreamProcessChanges","firstSyncDone","getValue","canceled","sub","masterChangeStream$","subscribe","masterChangeStreamEmit","pipe","unsubscribe","_downstreamResyncOnce","checkpointQueue","lastCheckpoint","promises","downResult","masterChangesSince","pullBatchSize","documents","checkpoint","persistFromMaster","Promise","all","tasks","docsOfAllTasks","forEach","Error","persistenceQueue","nonPersistedFromMaster","docs","docData","docId","primaryPath","downDocsById","useCheckpoint","docIds","Object","keys","writeRowsToFork","writeRowsToForkById","writeRowsToMeta","useMetaWriteRows","forkInstance","findDocumentsById","currentForkState","assumedMasterState","map","_ref","forkStateFullDoc","forkStateDocData","undefined","masterState","assumedMaster","metaDocument","isResolvedConflict","_rev","isAssumedMasterEqualToForkStatePromise","conflictHandler","realMasterState","newDocumentState","r","isEqual","isAssumedMasterEqualToForkState","_meta","height","areStatesExactlyEqualPromise","areStatesExactlyEqual","newForkState","assign","_attachments","nextRevisionHeight","forkWriteRow","previous","document","_x2","bulkWrite","downstreamBulkWriteFlag","forkWriteResult","success","processed","values","error","status","writeError","metaInstance","metaWriteResult","entries","id","catch","unhandledError"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/replication-protocol/downstream.js"],"sourcesContent":["import { firstValueFrom, filter } from 'rxjs';\nimport { newRxError } from '../rx-error';\nimport { stackCheckpoints } from '../rx-storage-helper';\nimport { appendToArray, createRevision, ensureNotFalsy, flatClone, getDefaultRevision, getDefaultRxDocumentMeta, parseRevision, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_VOID } from '../plugins/utils';\nimport { getLastCheckpointDoc, setCheckpoint } from './checkpoint';\nimport { writeDocToDocState } from './helper';\nimport { getAssumedMasterState, getMetaWriteRow } from './meta-instance';\n\n/**\n * Writes all documents from the master to the fork.\n * The downstream has two operation modes\n * - Sync by iterating over the checkpoints via downstreamResyncOnce()\n * - Sync by listening to the changestream via downstreamProcessChanges()\n * We need this to be able to do initial syncs\n * and still can have fast event based sync when the client is not offline.\n */\nexport async function startReplicationDownstream(state) {\n  if (state.input.initialCheckpoint && state.input.initialCheckpoint.downstream) {\n    var checkpointDoc = await getLastCheckpointDoc(state, 'down');\n    if (!checkpointDoc) {\n      await setCheckpoint(state, 'down', state.input.initialCheckpoint.downstream);\n    }\n  }\n  var identifierHash = state.input.hashFunction(state.input.identifier);\n  var replicationHandler = state.input.replicationHandler;\n\n  // used to detect which tasks etc can in it at which order.\n  var timer = 0;\n  var openTasks = [];\n  function addNewTask(task) {\n    state.stats.down.addNewTask = state.stats.down.addNewTask + 1;\n    var taskWithTime = {\n      time: timer++,\n      task\n    };\n    openTasks.push(taskWithTime);\n    state.streamQueue.down = state.streamQueue.down.then(() => {\n      var useTasks = [];\n      while (openTasks.length > 0) {\n        state.events.active.down.next(true);\n        var innerTaskWithTime = ensureNotFalsy(openTasks.shift());\n\n        /**\n         * If the task came in before the last time we started the pull\n         * from the master, then we can drop the task.\n         */\n        if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {\n          continue;\n        }\n        if (innerTaskWithTime.task === 'RESYNC') {\n          if (useTasks.length === 0) {\n            useTasks.push(innerTaskWithTime.task);\n            break;\n          } else {\n            break;\n          }\n        }\n        useTasks.push(innerTaskWithTime.task);\n      }\n      if (useTasks.length === 0) return;\n      if (useTasks[0] === 'RESYNC') {\n        return downstreamResyncOnce();\n      } else {\n        return downstreamProcessChanges(useTasks);\n      }\n    }).then(() => {\n      state.events.active.down.next(false);\n      if (!state.firstSyncDone.down.getValue() && !state.events.canceled.getValue()) {\n        state.firstSyncDone.down.next(true);\n      }\n    });\n  }\n  addNewTask('RESYNC');\n\n  /**\n   * If a write on the master happens, we have to trigger the downstream.\n   */\n  var sub = replicationHandler.masterChangeStream$.subscribe(task => {\n    state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;\n    addNewTask(task);\n  });\n  firstValueFrom(state.events.canceled.pipe(filter(canceled => !!canceled))).then(() => sub.unsubscribe());\n\n  /**\n   * For faster performance, we directly start each write\n   * and then await all writes at the end.\n   */\n  var lastTimeMasterChangesRequested = -1;\n  async function downstreamResyncOnce() {\n    state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;\n    if (state.events.canceled.getValue()) {\n      return;\n    }\n    state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'down'));\n    var lastCheckpoint = await state.checkpointQueue;\n    var promises = [];\n    while (!state.events.canceled.getValue()) {\n      lastTimeMasterChangesRequested = timer++;\n      var downResult = await replicationHandler.masterChangesSince(lastCheckpoint, state.input.pullBatchSize);\n      if (downResult.documents.length === 0) {\n        break;\n      }\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, downResult.checkpoint]);\n      promises.push(persistFromMaster(downResult.documents, lastCheckpoint));\n\n      /**\n       * By definition we stop pull when the pulled documents\n       * do not fill up the pullBatchSize because we\n       * can assume that the remote has no more documents.\n       */\n      if (downResult.documents.length < state.input.pullBatchSize) {\n        break;\n      }\n    }\n    await Promise.all(promises);\n  }\n  function downstreamProcessChanges(tasks) {\n    state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;\n    var docsOfAllTasks = [];\n    var lastCheckpoint = null;\n    tasks.forEach(task => {\n      if (task === 'RESYNC') {\n        throw new Error('SNH');\n      }\n      appendToArray(docsOfAllTasks, task.documents);\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, task.checkpoint]);\n    });\n    return persistFromMaster(docsOfAllTasks, ensureNotFalsy(lastCheckpoint));\n  }\n\n  /**\n   * It can happen that the calls to masterChangesSince() or the changeStream()\n   * are way faster then how fast the documents can be persisted.\n   * Therefore we merge all incoming downResults into the nonPersistedFromMaster object\n   * and process them together if possible.\n   * This often bundles up single writes and improves performance\n   * by processing the documents in bulks.\n   */\n  var persistenceQueue = PROMISE_RESOLVE_VOID;\n  var nonPersistedFromMaster = {\n    docs: {}\n  };\n  function persistFromMaster(docs, checkpoint) {\n    state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;\n\n    /**\n     * Add the new docs to the non-persistent list\n     */\n    docs.forEach(docData => {\n      var docId = docData[state.primaryPath];\n      nonPersistedFromMaster.docs[docId] = docData;\n    });\n    nonPersistedFromMaster.checkpoint = checkpoint;\n\n    /**\n     * Run in the queue\n     * with all open documents from nonPersistedFromMaster.\n     */\n    persistenceQueue = persistenceQueue.then(() => {\n      var downDocsById = nonPersistedFromMaster.docs;\n      nonPersistedFromMaster.docs = {};\n      var useCheckpoint = nonPersistedFromMaster.checkpoint;\n      var docIds = Object.keys(downDocsById);\n      if (state.events.canceled.getValue() || docIds.length === 0) {\n        return PROMISE_RESOLVE_VOID;\n      }\n      var writeRowsToFork = [];\n      var writeRowsToForkById = {};\n      var writeRowsToMeta = {};\n      var useMetaWriteRows = [];\n      return Promise.all([state.input.forkInstance.findDocumentsById(docIds, true), getAssumedMasterState(state, docIds)]).then(([currentForkState, assumedMasterState]) => {\n        return Promise.all(docIds.map(async docId => {\n          var forkStateFullDoc = currentForkState[docId];\n          var forkStateDocData = forkStateFullDoc ? writeDocToDocState(forkStateFullDoc) : undefined;\n          var masterState = downDocsById[docId];\n          var assumedMaster = assumedMasterState[docId];\n          if (assumedMaster && assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev) {\n            /**\n             * The current fork state represents a resolved conflict\n             * that first must be send to the master in the upstream.\n             * All conflicts are resolved by the upstream.\n             */\n            return PROMISE_RESOLVE_VOID;\n          }\n          var isAssumedMasterEqualToForkStatePromise = !assumedMaster || !forkStateDocData ? PROMISE_RESOLVE_FALSE : state.input.conflictHandler({\n            realMasterState: assumedMaster.docData,\n            newDocumentState: forkStateDocData\n          }, 'downstream-check-if-equal-0').then(r => r.isEqual);\n          var isAssumedMasterEqualToForkState = await isAssumedMasterEqualToForkStatePromise;\n          if (!isAssumedMasterEqualToForkState && assumedMaster && assumedMaster.docData._rev && forkStateFullDoc._meta[state.input.identifier] && parseRevision(forkStateFullDoc._rev).height === forkStateFullDoc._meta[state.input.identifier]) {\n            isAssumedMasterEqualToForkState = true;\n          }\n          if (forkStateFullDoc && assumedMaster && isAssumedMasterEqualToForkState === false || forkStateFullDoc && !assumedMaster) {\n            /**\n             * We have a non-upstream-replicated\n             * local write to the fork.\n             * This means we ignore the downstream of this document\n             * because anyway the upstream will first resolve the conflict.\n             */\n            return PROMISE_RESOLVE_VOID;\n          }\n          var areStatesExactlyEqualPromise = !forkStateDocData ? PROMISE_RESOLVE_FALSE : state.input.conflictHandler({\n            realMasterState: masterState,\n            newDocumentState: forkStateDocData\n          }, 'downstream-check-if-equal-1').then(r => r.isEqual);\n          var areStatesExactlyEqual = await areStatesExactlyEqualPromise;\n          if (forkStateDocData && areStatesExactlyEqual) {\n            /**\n             * Document states are exactly equal.\n             * This can happen when the replication is shut down\n             * unexpected like when the user goes offline.\n             *\n             * Only when the assumedMaster is different from the forkState,\n             * we have to patch the document in the meta instance.\n             */\n            if (!assumedMaster || isAssumedMasterEqualToForkState === false) {\n              useMetaWriteRows.push(getMetaWriteRow(state, forkStateDocData, assumedMaster ? assumedMaster.metaDocument : undefined));\n            }\n            return PROMISE_RESOLVE_VOID;\n          }\n\n          /**\n           * All other master states need to be written to the forkInstance\n           * and metaInstance.\n           */\n          var newForkState = Object.assign({}, masterState, forkStateFullDoc ? {\n            _meta: flatClone(forkStateFullDoc._meta),\n            _attachments: {},\n            _rev: getDefaultRevision()\n          } : {\n            _meta: getDefaultRxDocumentMeta(),\n            _rev: getDefaultRevision(),\n            _attachments: {}\n          });\n          /**\n           * If the remote works with revisions,\n           * we store the height of the next fork-state revision\n           * inside of the documents meta data.\n           * By doing so we can filter it out in the upstream\n           * and detect the document as being equal to master or not.\n           * This is used for example in the CouchDB replication plugin.\n           */\n          if (masterState._rev) {\n            var nextRevisionHeight = !forkStateFullDoc ? 1 : parseRevision(forkStateFullDoc._rev).height + 1;\n            newForkState._meta[state.input.identifier] = nextRevisionHeight;\n          }\n          var forkWriteRow = {\n            previous: forkStateFullDoc,\n            document: newForkState\n          };\n          forkWriteRow.document._rev = createRevision(identifierHash, forkWriteRow.previous);\n          writeRowsToFork.push(forkWriteRow);\n          writeRowsToForkById[docId] = forkWriteRow;\n          writeRowsToMeta[docId] = getMetaWriteRow(state, masterState, assumedMaster ? assumedMaster.metaDocument : undefined);\n        }));\n      }).then(() => {\n        if (writeRowsToFork.length > 0) {\n          return state.input.forkInstance.bulkWrite(writeRowsToFork, state.downstreamBulkWriteFlag).then(forkWriteResult => {\n            Object.keys(forkWriteResult.success).forEach(docId => {\n              state.events.processed.down.next(writeRowsToForkById[docId]);\n              useMetaWriteRows.push(writeRowsToMeta[docId]);\n            });\n            Object.values(forkWriteResult.error).forEach(error => {\n              /**\n               * We do not have to care about downstream conflict errors here\n               * because on conflict, it will be solved locally and result in another write.\n               */\n              if (error.status === 409) {\n                return;\n              }\n              // other non-conflict errors must be handled\n              state.events.error.next(newRxError('RC_PULL', {\n                writeError: error\n              }));\n            });\n          });\n        }\n      }).then(() => {\n        if (useMetaWriteRows.length > 0) {\n          return state.input.metaInstance.bulkWrite(useMetaWriteRows, 'replication-down-write-meta').then(metaWriteResult => {\n            Object.entries(metaWriteResult.error).forEach(([docId, writeError]) => {\n              state.events.error.next(newRxError('RC_PULL', {\n                id: docId,\n                writeError\n              }));\n            });\n          });\n        }\n      }).then(() => {\n        /**\n         * For better performance we do not await checkpoint writes,\n         * but to ensure order on parallel checkpoint writes,\n         * we have to use a queue.\n         */\n        state.checkpointQueue = state.checkpointQueue.then(() => setCheckpoint(state, 'down', useCheckpoint));\n      });\n    }).catch(unhandledError => state.events.error.next(unhandledError));\n    return persistenceQueue;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}