{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { isBulkWriteConflictError, newRxError } from './rx-error';\nimport { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData } from './rx-schema-helper';\nimport { getSingleDocument, writeSingle } from './rx-storage-helper';\nimport { clone, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, randomCouchString } from './plugins/utils';\nexport var INTERNAL_CONTEXT_COLLECTION = 'collection';\nexport var INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';\n\n/**\n * Do not change the title,\n * we have to flag the internal schema so that\n * some RxStorage implementations are able\n * to detect if the created RxStorageInstance\n * is from the internals or not,\n * to do some optimizations in some cases.\n */\nexport var INTERNAL_STORE_SCHEMA_TITLE = 'RxInternalDocument';\nexport var INTERNAL_STORE_SCHEMA = fillWithDefaultSettings({\n  version: 0,\n  title: INTERNAL_STORE_SCHEMA_TITLE,\n  primaryKey: {\n    key: 'id',\n    fields: ['context', 'key'],\n    separator: '|'\n  },\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string',\n      maxLength: 200\n    },\n    key: {\n      type: 'string'\n    },\n    context: {\n      type: 'string',\n      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, 'OTHER']\n    },\n    data: {\n      type: 'object',\n      additionalProperties: true\n    }\n  },\n  indexes: [],\n  required: ['key', 'context', 'data'],\n  additionalProperties: false,\n  /**\n   * If the sharding plugin is used,\n   * it must not shard on the internal RxStorageInstance\n   * because that one anyway has only a small amount of documents\n   * and also its creation is in the hot path of the initial page load,\n   * so we should spend less time creating multiple RxStorageInstances.\n   */\n  sharding: {\n    shards: 1,\n    mode: 'collection'\n  }\n});\nexport function getPrimaryKeyOfInternalDocument(key, context) {\n  return getComposedPrimaryKeyOfDocumentData(INTERNAL_STORE_SCHEMA, {\n    key,\n    context\n  });\n}\n\n/**\n * Returns all internal documents\n * with context 'collection'\n */\nexport function getAllCollectionDocuments(_x, _x2) {\n  return _getAllCollectionDocuments.apply(this, arguments);\n}\n\n/**\n * to not confuse multiInstance-messages with other databases that have the same\n * name and adapter, but do not share state with this one (for example in-memory-instances),\n * we set a storage-token and use it in the broadcast-channel\n */\nfunction _getAllCollectionDocuments() {\n  _getAllCollectionDocuments = _asyncToGenerator(function* (storageStatics, storageInstance) {\n    var getAllQueryPrepared = storageStatics.prepareQuery(storageInstance.schema, {\n      selector: {\n        context: INTERNAL_CONTEXT_COLLECTION\n      },\n      sort: [{\n        id: 'asc'\n      }],\n      skip: 0\n    });\n    var queryResult = yield storageInstance.query(getAllQueryPrepared);\n    var allDocs = queryResult.documents;\n    return allDocs;\n  });\n  return _getAllCollectionDocuments.apply(this, arguments);\n}\nexport var STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';\nexport var STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);\nexport function ensureStorageTokenDocumentExists(_x3) {\n  return _ensureStorageTokenDocumentExists.apply(this, arguments);\n}\nfunction _ensureStorageTokenDocumentExists() {\n  _ensureStorageTokenDocumentExists = _asyncToGenerator(function* (rxDatabase) {\n    /**\n     * To have less read-write cycles,\n     * we just try to insert a new document\n     * and only fetch the existing one if a conflict happened.\n     */\n    var storageToken = randomCouchString(10);\n    var passwordHash = rxDatabase.password ? rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) : undefined;\n    var docData = {\n      id: STORAGE_TOKEN_DOCUMENT_ID,\n      context: INTERNAL_CONTEXT_STORAGE_TOKEN,\n      key: STORAGE_TOKEN_DOCUMENT_KEY,\n      data: {\n        token: storageToken,\n        /**\n         * We add the instance token here\n         * to be able to detect if a given RxDatabase instance\n         * is the first instance that was ever created\n         * or if databases have existed earlier on that storage\n         * with the same database name.\n         */\n        instanceToken: rxDatabase.token,\n        passwordHash\n      },\n      _deleted: false,\n      _meta: getDefaultRxDocumentMeta(),\n      _rev: getDefaultRevision(),\n      _attachments: {}\n    };\n    var writeResult = yield rxDatabase.internalStore.bulkWrite([{\n      document: docData\n    }], 'internal-add-storage-token');\n    if (writeResult.success[STORAGE_TOKEN_DOCUMENT_ID]) {\n      return writeResult.success[STORAGE_TOKEN_DOCUMENT_ID];\n    }\n\n    /**\n     * If we get a 409 error,\n     * it means another instance already inserted the storage token.\n     * So we get that token from the database and return that one.\n     */\n    var error = ensureNotFalsy(writeResult.error[STORAGE_TOKEN_DOCUMENT_ID]);\n    if (error.isError && error.status === 409) {\n      var conflictError = error;\n      if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {\n        throw newRxError('DB1', {\n          passwordHash,\n          existingPasswordHash: conflictError.documentInDb.data.passwordHash\n        });\n      }\n      var storageTokenDocInDb = conflictError.documentInDb;\n      return ensureNotFalsy(storageTokenDocInDb);\n    }\n    throw error;\n  });\n  return _ensureStorageTokenDocumentExists.apply(this, arguments);\n}\nexport function addConnectedStorageToCollection(_x4, _x5, _x6) {\n  return _addConnectedStorageToCollection.apply(this, arguments);\n}\n\n/**\n * returns the primary for a given collection-data\n * used in the internal store of a RxDatabase\n */\nfunction _addConnectedStorageToCollection() {\n  _addConnectedStorageToCollection = _asyncToGenerator(function* (collection, storageCollectionName, schema) {\n    var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n    var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);\n    while (true) {\n      var collectionDoc = yield getSingleDocument(collection.database.internalStore, collectionDocId);\n      var saveData = clone(ensureNotFalsy(collectionDoc));\n      /**\n       * Add array if not exist for backwards compatibility\n       * TODO remove this in 2023\n       */\n      if (!saveData.data.connectedStorages) {\n        saveData.data.connectedStorages = [];\n      }\n\n      // do nothing if already in array\n      var alreadyThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n      if (alreadyThere) {\n        return;\n      }\n\n      // otherwise add to array and save\n      saveData.data.connectedStorages.push({\n        collectionName: storageCollectionName,\n        schema\n      });\n      try {\n        yield writeSingle(collection.database.internalStore, {\n          previous: ensureNotFalsy(collectionDoc),\n          document: saveData\n        }, 'add-connected-storage-to-collection');\n      } catch (err) {\n        if (!isBulkWriteConflictError(err)) {\n          throw err;\n        }\n        // retry on conflict\n      }\n    }\n  });\n  return _addConnectedStorageToCollection.apply(this, arguments);\n}\nexport function _collectionNamePrimary(name, schema) {\n  return name + '-' + schema.version;\n}","map":{"version":3,"names":["isBulkWriteConflictError","newRxError","fillWithDefaultSettings","getComposedPrimaryKeyOfDocumentData","getSingleDocument","writeSingle","clone","ensureNotFalsy","getDefaultRevision","getDefaultRxDocumentMeta","randomCouchString","INTERNAL_CONTEXT_COLLECTION","INTERNAL_CONTEXT_STORAGE_TOKEN","INTERNAL_STORE_SCHEMA_TITLE","INTERNAL_STORE_SCHEMA","version","title","primaryKey","key","fields","separator","type","properties","id","maxLength","context","enum","data","additionalProperties","indexes","required","sharding","shards","mode","getPrimaryKeyOfInternalDocument","getAllCollectionDocuments","_x","_x2","_getAllCollectionDocuments","apply","arguments","_asyncToGenerator","storageStatics","storageInstance","getAllQueryPrepared","prepareQuery","schema","selector","sort","skip","queryResult","query","allDocs","documents","STORAGE_TOKEN_DOCUMENT_KEY","STORAGE_TOKEN_DOCUMENT_ID","ensureStorageTokenDocumentExists","_x3","_ensureStorageTokenDocumentExists","rxDatabase","storageToken","passwordHash","password","hashFunction","JSON","stringify","undefined","docData","token","instanceToken","_deleted","_meta","_rev","_attachments","writeResult","internalStore","bulkWrite","document","success","error","isError","status","conflictError","documentInDb","existingPasswordHash","storageTokenDocInDb","addConnectedStorageToCollection","_x4","_x5","_x6","_addConnectedStorageToCollection","collection","storageCollectionName","collectionNameWithVersion","_collectionNamePrimary","name","jsonSchema","collectionDocId","collectionDoc","database","saveData","connectedStorages","alreadyThere","find","row","collectionName","push","previous","err"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/rx-database-internal-store.js"],"sourcesContent":["import { isBulkWriteConflictError, newRxError } from './rx-error';\nimport { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData } from './rx-schema-helper';\nimport { getSingleDocument, writeSingle } from './rx-storage-helper';\nimport { clone, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, randomCouchString } from './plugins/utils';\nexport var INTERNAL_CONTEXT_COLLECTION = 'collection';\nexport var INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';\n\n/**\n * Do not change the title,\n * we have to flag the internal schema so that\n * some RxStorage implementations are able\n * to detect if the created RxStorageInstance\n * is from the internals or not,\n * to do some optimizations in some cases.\n */\nexport var INTERNAL_STORE_SCHEMA_TITLE = 'RxInternalDocument';\nexport var INTERNAL_STORE_SCHEMA = fillWithDefaultSettings({\n  version: 0,\n  title: INTERNAL_STORE_SCHEMA_TITLE,\n  primaryKey: {\n    key: 'id',\n    fields: ['context', 'key'],\n    separator: '|'\n  },\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string',\n      maxLength: 200\n    },\n    key: {\n      type: 'string'\n    },\n    context: {\n      type: 'string',\n      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, 'OTHER']\n    },\n    data: {\n      type: 'object',\n      additionalProperties: true\n    }\n  },\n  indexes: [],\n  required: ['key', 'context', 'data'],\n  additionalProperties: false,\n  /**\n   * If the sharding plugin is used,\n   * it must not shard on the internal RxStorageInstance\n   * because that one anyway has only a small amount of documents\n   * and also its creation is in the hot path of the initial page load,\n   * so we should spend less time creating multiple RxStorageInstances.\n   */\n  sharding: {\n    shards: 1,\n    mode: 'collection'\n  }\n});\nexport function getPrimaryKeyOfInternalDocument(key, context) {\n  return getComposedPrimaryKeyOfDocumentData(INTERNAL_STORE_SCHEMA, {\n    key,\n    context\n  });\n}\n\n/**\n * Returns all internal documents\n * with context 'collection'\n */\nexport async function getAllCollectionDocuments(storageStatics, storageInstance) {\n  var getAllQueryPrepared = storageStatics.prepareQuery(storageInstance.schema, {\n    selector: {\n      context: INTERNAL_CONTEXT_COLLECTION\n    },\n    sort: [{\n      id: 'asc'\n    }],\n    skip: 0\n  });\n  var queryResult = await storageInstance.query(getAllQueryPrepared);\n  var allDocs = queryResult.documents;\n  return allDocs;\n}\n\n/**\n * to not confuse multiInstance-messages with other databases that have the same\n * name and adapter, but do not share state with this one (for example in-memory-instances),\n * we set a storage-token and use it in the broadcast-channel\n */\nexport var STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';\nexport var STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);\nexport async function ensureStorageTokenDocumentExists(rxDatabase) {\n  /**\n   * To have less read-write cycles,\n   * we just try to insert a new document\n   * and only fetch the existing one if a conflict happened.\n   */\n  var storageToken = randomCouchString(10);\n  var passwordHash = rxDatabase.password ? rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) : undefined;\n  var docData = {\n    id: STORAGE_TOKEN_DOCUMENT_ID,\n    context: INTERNAL_CONTEXT_STORAGE_TOKEN,\n    key: STORAGE_TOKEN_DOCUMENT_KEY,\n    data: {\n      token: storageToken,\n      /**\n       * We add the instance token here\n       * to be able to detect if a given RxDatabase instance\n       * is the first instance that was ever created\n       * or if databases have existed earlier on that storage\n       * with the same database name.\n       */\n      instanceToken: rxDatabase.token,\n      passwordHash\n    },\n    _deleted: false,\n    _meta: getDefaultRxDocumentMeta(),\n    _rev: getDefaultRevision(),\n    _attachments: {}\n  };\n  var writeResult = await rxDatabase.internalStore.bulkWrite([{\n    document: docData\n  }], 'internal-add-storage-token');\n  if (writeResult.success[STORAGE_TOKEN_DOCUMENT_ID]) {\n    return writeResult.success[STORAGE_TOKEN_DOCUMENT_ID];\n  }\n\n  /**\n   * If we get a 409 error,\n   * it means another instance already inserted the storage token.\n   * So we get that token from the database and return that one.\n   */\n  var error = ensureNotFalsy(writeResult.error[STORAGE_TOKEN_DOCUMENT_ID]);\n  if (error.isError && error.status === 409) {\n    var conflictError = error;\n    if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {\n      throw newRxError('DB1', {\n        passwordHash,\n        existingPasswordHash: conflictError.documentInDb.data.passwordHash\n      });\n    }\n    var storageTokenDocInDb = conflictError.documentInDb;\n    return ensureNotFalsy(storageTokenDocInDb);\n  }\n  throw error;\n}\nexport async function addConnectedStorageToCollection(collection, storageCollectionName, schema) {\n  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);\n  while (true) {\n    var collectionDoc = await getSingleDocument(collection.database.internalStore, collectionDocId);\n    var saveData = clone(ensureNotFalsy(collectionDoc));\n    /**\n     * Add array if not exist for backwards compatibility\n     * TODO remove this in 2023\n     */\n    if (!saveData.data.connectedStorages) {\n      saveData.data.connectedStorages = [];\n    }\n\n    // do nothing if already in array\n    var alreadyThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n    if (alreadyThere) {\n      return;\n    }\n\n    // otherwise add to array and save\n    saveData.data.connectedStorages.push({\n      collectionName: storageCollectionName,\n      schema\n    });\n    try {\n      await writeSingle(collection.database.internalStore, {\n        previous: ensureNotFalsy(collectionDoc),\n        document: saveData\n      }, 'add-connected-storage-to-collection');\n    } catch (err) {\n      if (!isBulkWriteConflictError(err)) {\n        throw err;\n      }\n      // retry on conflict\n    }\n  }\n}\n\n/**\n * returns the primary for a given collection-data\n * used in the internal store of a RxDatabase\n */\nexport function _collectionNamePrimary(name, schema) {\n  return name + '-' + schema.version;\n}\n"],"mappings":";AAAA,SAASA,wBAAwB,EAAEC,UAAU,QAAQ,YAAY;AACjE,SAASC,uBAAuB,EAAEC,mCAAmC,QAAQ,oBAAoB;AACjG,SAASC,iBAAiB,EAAEC,WAAW,QAAQ,qBAAqB;AACpE,SAASC,KAAK,EAAEC,cAAc,EAAEC,kBAAkB,EAAEC,wBAAwB,EAAEC,iBAAiB,QAAQ,iBAAiB;AACxH,OAAO,IAAIC,2BAA2B,GAAG,YAAY;AACrD,OAAO,IAAIC,8BAA8B,GAAG,eAAe;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,2BAA2B,GAAG,oBAAoB;AAC7D,OAAO,IAAIC,qBAAqB,GAAGZ,uBAAuB,CAAC;EACzDa,OAAO,EAAE,CAAC;EACVC,KAAK,EAAEH,2BAA2B;EAClCI,UAAU,EAAE;IACVC,GAAG,EAAE,IAAI;IACTC,MAAM,EAAE,CAAC,SAAS,EAAE,KAAK,CAAC;IAC1BC,SAAS,EAAE;EACb,CAAC;EACDC,IAAI,EAAE,QAAQ;EACdC,UAAU,EAAE;IACVC,EAAE,EAAE;MACFF,IAAI,EAAE,QAAQ;MACdG,SAAS,EAAE;IACb,CAAC;IACDN,GAAG,EAAE;MACHG,IAAI,EAAE;IACR,CAAC;IACDI,OAAO,EAAE;MACPJ,IAAI,EAAE,QAAQ;MACdK,IAAI,EAAE,CAACf,2BAA2B,EAAEC,8BAA8B,EAAE,OAAO;IAC7E,CAAC;IACDe,IAAI,EAAE;MACJN,IAAI,EAAE,QAAQ;MACdO,oBAAoB,EAAE;IACxB;EACF,CAAC;EACDC,OAAO,EAAE,EAAE;EACXC,QAAQ,EAAE,CAAC,KAAK,EAAE,SAAS,EAAE,MAAM,CAAC;EACpCF,oBAAoB,EAAE,KAAK;EAC3B;AACF;AACA;AACA;AACA;AACA;AACA;EACEG,QAAQ,EAAE;IACRC,MAAM,EAAE,CAAC;IACTC,IAAI,EAAE;EACR;AACF,CAAC,CAAC;AACF,OAAO,SAASC,+BAA+BA,CAAChB,GAAG,EAAEO,OAAO,EAAE;EAC5D,OAAOtB,mCAAmC,CAACW,qBAAqB,EAAE;IAChEI,GAAG;IACHO;EACF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA,gBAAsBU,yBAAyBA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,0BAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;;AAe/C;AACA;AACA;AACA;AACA;AAJA,SAAAF,2BAAA;EAAAA,0BAAA,GAAAG,iBAAA,CAfO,WAAyCC,cAAc,EAAEC,eAAe,EAAE;IAC/E,IAAIC,mBAAmB,GAAGF,cAAc,CAACG,YAAY,CAACF,eAAe,CAACG,MAAM,EAAE;MAC5EC,QAAQ,EAAE;QACRtB,OAAO,EAAEd;MACX,CAAC;MACDqC,IAAI,EAAE,CAAC;QACLzB,EAAE,EAAE;MACN,CAAC,CAAC;MACF0B,IAAI,EAAE;IACR,CAAC,CAAC;IACF,IAAIC,WAAW,SAASP,eAAe,CAACQ,KAAK,CAACP,mBAAmB,CAAC;IAClE,IAAIQ,OAAO,GAAGF,WAAW,CAACG,SAAS;IACnC,OAAOD,OAAO;EAChB,CAAC;EAAA,OAAAd,0BAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAOD,OAAO,IAAIc,0BAA0B,GAAG,cAAc;AACtD,OAAO,IAAIC,yBAAyB,GAAGrB,+BAA+B,CAACoB,0BAA0B,EAAE1C,8BAA8B,CAAC;AAClI,gBAAsB4C,gCAAgCA,CAAAC,GAAA;EAAA,OAAAC,iCAAA,CAAAnB,KAAA,OAAAC,SAAA;AAAA;AAsDrD,SAAAkB,kCAAA;EAAAA,iCAAA,GAAAjB,iBAAA,CAtDM,WAAgDkB,UAAU,EAAE;IACjE;AACF;AACA;AACA;AACA;IACE,IAAIC,YAAY,GAAGlD,iBAAiB,CAAC,EAAE,CAAC;IACxC,IAAImD,YAAY,GAAGF,UAAU,CAACG,QAAQ,GAAGH,UAAU,CAACI,YAAY,CAACC,IAAI,CAACC,SAAS,CAACN,UAAU,CAACG,QAAQ,CAAC,CAAC,GAAGI,SAAS;IACjH,IAAIC,OAAO,GAAG;MACZ5C,EAAE,EAAEgC,yBAAyB;MAC7B9B,OAAO,EAAEb,8BAA8B;MACvCM,GAAG,EAAEoC,0BAA0B;MAC/B3B,IAAI,EAAE;QACJyC,KAAK,EAAER,YAAY;QACnB;AACN;AACA;AACA;AACA;AACA;AACA;QACMS,aAAa,EAAEV,UAAU,CAACS,KAAK;QAC/BP;MACF,CAAC;MACDS,QAAQ,EAAE,KAAK;MACfC,KAAK,EAAE9D,wBAAwB,CAAC,CAAC;MACjC+D,IAAI,EAAEhE,kBAAkB,CAAC,CAAC;MAC1BiE,YAAY,EAAE,CAAC;IACjB,CAAC;IACD,IAAIC,WAAW,SAASf,UAAU,CAACgB,aAAa,CAACC,SAAS,CAAC,CAAC;MAC1DC,QAAQ,EAAEV;IACZ,CAAC,CAAC,EAAE,4BAA4B,CAAC;IACjC,IAAIO,WAAW,CAACI,OAAO,CAACvB,yBAAyB,CAAC,EAAE;MAClD,OAAOmB,WAAW,CAACI,OAAO,CAACvB,yBAAyB,CAAC;IACvD;;IAEA;AACF;AACA;AACA;AACA;IACE,IAAIwB,KAAK,GAAGxE,cAAc,CAACmE,WAAW,CAACK,KAAK,CAACxB,yBAAyB,CAAC,CAAC;IACxE,IAAIwB,KAAK,CAACC,OAAO,IAAID,KAAK,CAACE,MAAM,KAAK,GAAG,EAAE;MACzC,IAAIC,aAAa,GAAGH,KAAK;MACzB,IAAIlB,YAAY,IAAIA,YAAY,KAAKqB,aAAa,CAACC,YAAY,CAACxD,IAAI,CAACkC,YAAY,EAAE;QACjF,MAAM5D,UAAU,CAAC,KAAK,EAAE;UACtB4D,YAAY;UACZuB,oBAAoB,EAAEF,aAAa,CAACC,YAAY,CAACxD,IAAI,CAACkC;QACxD,CAAC,CAAC;MACJ;MACA,IAAIwB,mBAAmB,GAAGH,aAAa,CAACC,YAAY;MACpD,OAAO5E,cAAc,CAAC8E,mBAAmB,CAAC;IAC5C;IACA,MAAMN,KAAK;EACb,CAAC;EAAA,OAAArB,iCAAA,CAAAnB,KAAA,OAAAC,SAAA;AAAA;AACD,gBAAsB8C,+BAA+BA,CAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,gCAAA,CAAAnD,KAAA,OAAAC,SAAA;AAAA;;AAuCrD;AACA;AACA;AACA;AAHA,SAAAkD,iCAAA;EAAAA,gCAAA,GAAAjD,iBAAA,CAvCO,WAA+CkD,UAAU,EAAEC,qBAAqB,EAAE9C,MAAM,EAAE;IAC/F,IAAI+C,yBAAyB,GAAGC,sBAAsB,CAACH,UAAU,CAACI,IAAI,EAAEJ,UAAU,CAAC7C,MAAM,CAACkD,UAAU,CAAC;IACrG,IAAIC,eAAe,GAAG/D,+BAA+B,CAAC2D,yBAAyB,EAAElF,2BAA2B,CAAC;IAC7G,OAAO,IAAI,EAAE;MACX,IAAIuF,aAAa,SAAS9F,iBAAiB,CAACuF,UAAU,CAACQ,QAAQ,CAACxB,aAAa,EAAEsB,eAAe,CAAC;MAC/F,IAAIG,QAAQ,GAAG9F,KAAK,CAACC,cAAc,CAAC2F,aAAa,CAAC,CAAC;MACnD;AACJ;AACA;AACA;MACI,IAAI,CAACE,QAAQ,CAACzE,IAAI,CAAC0E,iBAAiB,EAAE;QACpCD,QAAQ,CAACzE,IAAI,CAAC0E,iBAAiB,GAAG,EAAE;MACtC;;MAEA;MACA,IAAIC,YAAY,GAAGF,QAAQ,CAACzE,IAAI,CAAC0E,iBAAiB,CAACE,IAAI,CAACC,GAAG,IAAIA,GAAG,CAACC,cAAc,KAAKb,qBAAqB,IAAIY,GAAG,CAAC1D,MAAM,CAAC/B,OAAO,KAAK+B,MAAM,CAAC/B,OAAO,CAAC;MACrJ,IAAIuF,YAAY,EAAE;QAChB;MACF;;MAEA;MACAF,QAAQ,CAACzE,IAAI,CAAC0E,iBAAiB,CAACK,IAAI,CAAC;QACnCD,cAAc,EAAEb,qBAAqB;QACrC9C;MACF,CAAC,CAAC;MACF,IAAI;QACF,MAAMzC,WAAW,CAACsF,UAAU,CAACQ,QAAQ,CAACxB,aAAa,EAAE;UACnDgC,QAAQ,EAAEpG,cAAc,CAAC2F,aAAa,CAAC;UACvCrB,QAAQ,EAAEuB;QACZ,CAAC,EAAE,qCAAqC,CAAC;MAC3C,CAAC,CAAC,OAAOQ,GAAG,EAAE;QACZ,IAAI,CAAC5G,wBAAwB,CAAC4G,GAAG,CAAC,EAAE;UAClC,MAAMA,GAAG;QACX;QACA;MACF;IACF;EACF,CAAC;EAAA,OAAAlB,gCAAA,CAAAnD,KAAA,OAAAC,SAAA;AAAA;AAMD,OAAO,SAASsD,sBAAsBA,CAACC,IAAI,EAAEjD,MAAM,EAAE;EACnD,OAAOiD,IAAI,GAAG,GAAG,GAAGjD,MAAM,CAAC/B,OAAO;AACpC"},"metadata":{},"sourceType":"module","externalDependencies":[]}