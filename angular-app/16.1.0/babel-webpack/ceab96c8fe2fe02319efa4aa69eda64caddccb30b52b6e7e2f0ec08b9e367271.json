{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { InjectionToken } from '@angular/core';\nimport { createRxDatabase } from 'rxdb';\nimport { getRxStorageDexie } from 'rxdb/plugins/storage-dexie';\nimport { learnerSchema } from '../schema/identity';\nimport { nuggetSchema } from '../schema/nugget';\nimport { Subject } from 'rxjs';\nimport { replicateRxCollection } from 'rxdb/plugins/replication';\nimport * as i0 from \"@angular/core\";\nexport const APP_STORAGE = new InjectionToken('APP_STORAGE');\nexport const IDENTITY_TABLE = 'identity';\nexport const NUGGET_TABLE = 'nugget';\nclass LocalStorageService {\n  constructor() {\n    this.pullStream$ = new Subject();\n  }\n  init() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this._database = yield createRxDatabase({\n        name: 'offlinestore' + new Date().getTime(),\n        storage: getRxStorageDexie(),\n        cleanupPolicy: {\n          /**\n           * The minimum time in milliseconds for how long a document has to be deleted before it is purged by the cleanup.\n           * [default=one month]\n           */\n          minimumDeletedTime: 1000 * 60 * 60 * 24 * 31,\n          /**\n           * The minimum amount of that that the RxCollection must have existed.\n           * This ensures that at the initial page load, more important tasks are not slowed down because a cleanup process is running.\n           * [default=60 seconds]\n           */\n          minimumCollectionAge: 1000 * 60,\n          /**\n           * After the initial cleanup is done, a new cleanup is started after [runEach] milliseconds\n           * [default=5 minutes]\n           */\n          runEach: 1000 * 60 * 5,\n          /**\n           * If set to true, RxDB will await all running replications to not have a replication cycle running.\n           * This ensures we do not remove deleted documents when they might not have already been replicated.\n           * [default=true]\n           */\n          awaitReplicationsInSync: true\n        }\n      });\n      yield _this.createCollection({\n        identity: {\n          schema: learnerSchema\n        }\n      });\n      yield _this.createCollection({\n        nugget: {\n          schema: nuggetSchema\n        }\n      });\n    })();\n  }\n  createCollection(collection) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2._database.addCollections(collection);\n    })();\n  }\n  sync(collection) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      console.log('Syncing from server to client, and then client updates back to server');\n      const replicationState = replicateRxCollection({\n        collection: _this3._database[collection],\n        /**\n         * An id for the replication to identify it and so that RxDB is able to resume the replication on app reload.\n         * If you replicate with a remote server, it is recommended to put the server url into the replicationIdentifier.\n         */\n        replicationIdentifier: 'my-rest-replication-to-https://example.com/api/sync',\n        /**\n         * By default it will do an ongoing realtime replication.\n         * By settings live: false the replication will run once until the local state is in sync with the remote state, then it will cancel itself.\n         * (optional), default is true.\n         */\n        live: false,\n        /**\n         * Time in milliseconds after when a failed backend request has to be retried.\n         * This time will be skipped if a offline->online switch is detected via navigator.onLine\n         * (optional), default is 5 seconds.\n         */\n        retryTime: 600 * 1000,\n        /**\n         * When multiInstance is true, like when you use RxDB in multiple browser tabs, the replication should always run in only one of the open browser tabs.\n         * If waitForLeadership is true, it will wait until the current instance is leader.\n         * If waitForLeadership is false, it will start replicating, even if it is not leader.\n         * [default=true]\n         */\n        waitForLeadership: true,\n        /**\n         * If this is set to false, the replication will not start automatically but will wait for replicationState.start() being called.\n         * (optional), default is true\n         */\n        autoStart: true,\n        /**\n         * Custom deleted field, the boolean property of the document data that marks a document as being deleted.\n         * If your backend uses a different fieldname then '_deleted', set the fieldname here.\n         * RxDB will still store the documents internally with '_deleted', setting this field only maps the data on the data layer.\n         *\n         * If a custom deleted field contains a non-boolean value, the deleted state\n         * of the documents depends on if the value is truthy or not. So instead of providing a boolean * * deleted value, you could also work with using a 'deletedAt' timestamp instead.\n         *\n         * [default='_deleted']\n         */\n        deletedField: '_deleted',\n        /**\n         * Optional,\n         * only needed when you want to replicate local changes to the remote instance.\n         */\n        push: {\n          /**\n           * Push handler\n           */\n          handler(docs) {\n            return _asyncToGenerator(function* () {\n              /**\n               * Push the local documents to a remote REST server.\n               */\n              const rawResponse = yield fetch(`https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync/push?collection=${collection}`, {\n                method: 'POST',\n                headers: {\n                  'Accept': 'application/json',\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                  docs\n                })\n              });\n              /**\n               * Contains an array with all conflicts that appeared during this push.\n               * If there were no conflicts, return an empty array.\n               */\n              const response = yield rawResponse.json();\n              return response;\n            })();\n          },\n          /**\n           * Batch size, optional\n           * Defines how many documents will be given to the push handler at once.\n           */\n          batchSize: 5,\n          /**\n           * Modifies all documents before they are given to the push handler.\n           * Can be used to swap out a custom deleted flag instead of the '_deleted' field.\n           * (optional)\n           */\n          modifier: d => d\n        },\n        /**\n         * Optional,\n         * only needed when you want to replicate remote changes to the local state.\n         */\n        pull: {\n          /**\n           * Pull handler\n           */\n          handler(lastCheckpoint, batchSize) {\n            return _asyncToGenerator(function* () {\n              const minTimestamp = 0;\n              // const minTimestamp = lastCheckpoint ? lastCheckpoint.updatedAt : 0;\n              /**\n               * In this example we replicate with a remote REST server\n               */\n              const response = yield fetch(`https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync?minUpdatedAt=${minTimestamp}&limit=${batchSize}&collection=${collection}`);\n              const documentsFromRemote = yield response.json();\n              return {\n                /**\n                 * Contains the pulled documents from the remote.\n                 * Notice: If documentsFromRemote.length < batchSize,\n                 * then RxDB assumes that there are no more un-replicated documents\n                 * on the backend, so the replication will switch to 'Event observation' mode.\n                 */\n                documents: documentsFromRemote,\n                /**\n                 * The last checkpoint of the returned documents.\n                 * On the next call to the pull handler,\n                 * this checkpoint will be passed as 'lastCheckpoint'\n                 */\n                checkpoint: documentsFromRemote.length === 0 ? lastCheckpoint : {\n                  id: \"\",\n                  updatedAt: \"\"\n                }\n              };\n            })();\n          },\n          batchSize: 10,\n          /**\n           * Modifies all documents after they have been pulled\n           * but before they are used by RxDB.\n           * (optional)\n           */\n          modifier: d => d,\n          /**\n           * Stream of the backend document writes.\n           * See below.\n           * You only need a stream$ when you have set live=true\n           */\n          stream$: _this3.pullStream$.asObservable()\n        }\n      });\n      // emits each document that was received from the remote\n      replicationState.received$.subscribe(doc => console.dir(doc));\n      // emits each document that was send to the remote\n      replicationState.send$.subscribe(doc => console.dir(doc));\n      // emits all errors that happen when running the push- & pull-handlers.\n      replicationState.error$.subscribe(error => console.dir(error));\n      // emits true when the replication was canceled, false when not.\n      replicationState.canceled$.subscribe(bool => console.dir(bool));\n      // emits true when a replication cycle is running, false when not.\n      replicationState.active$.subscribe(bool => console.dir(bool));\n    })();\n  }\n  syncPush(collection) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      console.log('Syncing client to server');\n      const replicationState = replicateRxCollection({\n        collection: _this4._database[collection],\n        replicationIdentifier: 'my-rest-replication-to-https://example.com/api/sync',\n        live: false,\n        retryTime: 600 * 1000,\n        waitForLeadership: true,\n        autoStart: true,\n        deletedField: '_deleted',\n        push: {\n          handler(docs) {\n            return _asyncToGenerator(function* () {\n              const rawResponse = yield fetch(`https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync/push?collection=${collection}`, {\n                method: 'POST',\n                headers: {\n                  'Accept': 'application/json',\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                  docs\n                })\n              });\n              const response = yield rawResponse.json();\n              return response;\n            })();\n          },\n          batchSize: 5,\n          modifier: d => d\n        }\n      });\n      // emits each document that was received from the remote\n      replicationState.received$.subscribe(doc => console.dir(doc));\n      // emits each document that was send to the remote\n      replicationState.send$.subscribe(doc => console.dir(doc));\n      // emits all errors that happen when running the push- & pull-handlers.\n      replicationState.error$.subscribe(error => console.dir(error));\n      // emits true when the replication was canceled, false when not.\n      replicationState.canceled$.subscribe(bool => console.dir(bool));\n      // emits true when a replication cycle is running, false when not.\n      replicationState.active$.subscribe(bool => console.dir(bool));\n    })();\n  }\n  syncPull(collection) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      console.log('Syncing client to server');\n      const replicationState = replicateRxCollection({\n        collection: _this5._database[collection],\n        replicationIdentifier: 'my-rest-replication-to-https://example.com/api/sync',\n        live: false,\n        retryTime: 600 * 1000,\n        waitForLeadership: true,\n        autoStart: true,\n        deletedField: '_deleted',\n        pull: {\n          handler(lastCheckpoint, batchSize) {\n            return _asyncToGenerator(function* () {\n              const minTimestamp = 0;\n              const response = yield fetch(`https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync?minUpdatedAt=${minTimestamp}&limit=${batchSize}&collection=${collection}`);\n              const documentsFromRemote = yield response.json();\n              return {\n                documents: documentsFromRemote,\n                checkpoint: documentsFromRemote.length === 0 ? lastCheckpoint : {\n                  id: \"\",\n                  updatedAt: \"\"\n                }\n              };\n            })();\n          },\n          batchSize: 10,\n          modifier: d => d,\n          stream$: _this5.pullStream$.asObservable()\n        }\n      });\n      // emits each document that was received from the remote\n      replicationState.received$.subscribe(doc => console.dir(doc));\n      // emits each document that was send to the remote\n      replicationState.send$.subscribe(doc => console.dir(doc));\n      // emits all errors that happen when running the push- & pull-handlers.\n      replicationState.error$.subscribe(error => console.dir(error));\n      // emits true when the replication was canceled, false when not.\n      replicationState.canceled$.subscribe(bool => console.dir(bool));\n      // emits true when a replication cycle is running, false when not.\n      replicationState.active$.subscribe(bool => console.dir(bool));\n    })();\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Getter for database\n   */\n  get database() {\n    return this._database;\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be inserted.\n   * @param body - The data object representing the record to be inserted.\n   * @returns A Promise that resolves to void once the record has been successfully inserted.\n   *\n   * @example\n   * await post('orders', { id: 1, product: 'Phone', quantity: 2 });\n   * // Inserts a new record into the 'orders' table with the provided data.\n   */\n  post(table, body) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      yield _this6.database[table].insert(body);\n    })();\n  }\n  /**\n   * Retrieves a record from the specified table in the local offline storage based on the provided ID.\n   *\n   * @param table - The name of the table from which the record will be retrieved.\n   * @param id - The ID of the record to be retrieved.\n   * @returns A Promise that resolves to the retrieved record.\n   *\n   * @example\n   * const order = await get('orders', '456');\n   * // Retrieves the record with ID '456' from the 'orders' table.\n   */\n  get(table, id) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return _this7.database[table].findOne(id).exec();\n    })();\n  }\n  getCollection(table) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return _this8.database[table].find().exec();\n    })();\n  }\n  /**\n   * Retrieves an Observable stream of records from the specified table in the local offline storage.\n   *\n   * @param table - The name of the table from which the records will be retrieved.\n   * @returns An Observable that emits the records from the specified table.\n   *\n   * @example\n   * // Example usage:\n   * const users$ = get$('users');\n   * users$.subscribe((users) => {\n   *   console.log(users);\n   * });\n   * // Retrieves the records from the 'users' table and logs the emitted records whenever there is an update.\n   */\n  get$(table) {\n    return this.database[table].$;\n  }\n  /**\n   * Updates an existing record or inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be updated or inserted.\n   * @param body - The data object representing the record to be updated or inserted.\n   * @returns A Promise that resolves to void once the record has been successfully updated or inserted.\n   *\n   * @example\n   * await put('users', { id: '123', name: 'John Doe', age: 30 });\n   * // Updates the record with ID '123' in the 'users' table if it exists, or inserts a new record with the provided data if the record doesn't exist.\n   */\n  put(table, body) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      yield _this9.database[table].upsert(body);\n    })();\n  }\n  /**\n   * DELETE\n   */\n  delete() {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * REMOVE\n   */\n  deleteCollection(table) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      yield _this10.database[table].remove();\n    })();\n  }\n  /**\n   * Destroy\n   */\n  destroyCollection(table) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      yield _this11.database[table].destroy();\n    })();\n  }\n  destroy() {\n    this.database.remove();\n  }\n}\nLocalStorageService.ɵfac = function LocalStorageService_Factory(t) {\n  return new (t || LocalStorageService)();\n};\nLocalStorageService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: LocalStorageService,\n  factory: LocalStorageService.ɵfac,\n  providedIn: 'root'\n});\nexport { LocalStorageService };","map":{"version":3,"names":["InjectionToken","createRxDatabase","getRxStorageDexie","learnerSchema","nuggetSchema","Subject","replicateRxCollection","APP_STORAGE","IDENTITY_TABLE","NUGGET_TABLE","LocalStorageService","constructor","pullStream$","init","_this","_asyncToGenerator","_database","name","Date","getTime","storage","cleanupPolicy","minimumDeletedTime","minimumCollectionAge","runEach","awaitReplicationsInSync","createCollection","identity","schema","nugget","collection","_this2","addCollections","sync","_this3","console","log","replicationState","replicationIdentifier","live","retryTime","waitForLeadership","autoStart","deletedField","push","handler","docs","rawResponse","fetch","method","headers","body","JSON","stringify","response","json","batchSize","modifier","d","pull","lastCheckpoint","minTimestamp","documentsFromRemote","documents","checkpoint","length","id","updatedAt","stream$","asObservable","received$","subscribe","doc","dir","send$","error$","error","canceled$","bool","active$","syncPush","_this4","syncPull","_this5","database","post","table","_this6","insert","get","_this7","findOne","exec","getCollection","_this8","find","get$","$","put","_this9","upsert","delete","deleteCollection","_this10","remove","destroyCollection","_this11","destroy","factory","ɵfac","providedIn"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/src/app/repository/local-storage/local-storage.ts"],"sourcesContent":["import { Injectable, InjectionToken } from '@angular/core';\nimport { RxDatabase, RxReplicationPullStreamItem, createRxDatabase } from 'rxdb';\nimport { getRxStorageDexie } from 'rxdb/plugins/storage-dexie';\nimport { learnerSchema } from '../schema/identity';\nimport { nuggetSchema } from '../schema/nugget';\nimport { Observable, Subject } from 'rxjs';\nimport { replicateRxCollection } from 'rxdb/plugins/replication';\nimport { LocalStorage } from './local-storage-interface';\n\nexport const APP_STORAGE = new InjectionToken<any>('APP_STORAGE');\nexport const IDENTITY_TABLE = 'identity';\nexport const NUGGET_TABLE = 'nugget';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocalStorageService implements LocalStorage {\n  private _database: RxDatabase | undefined;\n  private pullStream$ = new Subject<RxReplicationPullStreamItem<any, any>>();\n\n  constructor() {}\n\n  async init() {\n    this._database = await createRxDatabase({\n      name: 'offlinestore'+ new Date().getTime(),\n      storage: getRxStorageDexie(),\n      cleanupPolicy: {\n        /**\n         * The minimum time in milliseconds for how long a document has to be deleted before it is purged by the cleanup.\n         * [default=one month]\n         */\n        minimumDeletedTime: 1000 * 60 * 60 * 24 * 31, // one month,\n        /**\n         * The minimum amount of that that the RxCollection must have existed.\n         * This ensures that at the initial page load, more important tasks are not slowed down because a cleanup process is running.\n         * [default=60 seconds]\n         */\n        minimumCollectionAge: 1000 * 60, // 60 seconds\n        /**\n         * After the initial cleanup is done, a new cleanup is started after [runEach] milliseconds\n         * [default=5 minutes]\n         */\n        runEach: 1000 * 60 * 5, // 5 minutes\n        /**\n         * If set to true, RxDB will await all running replications to not have a replication cycle running.\n         * This ensures we do not remove deleted documents when they might not have already been replicated.\n         * [default=true]\n         */\n        awaitReplicationsInSync: true,\n      }\n    });\n\n    await this.createCollection({identity: {\n      schema: learnerSchema\n    }})\n\n    await this.createCollection({nugget: {\n      schema: nuggetSchema\n    }})\n  }\n\n  async createCollection(collection:any) {\n    await this._database!.addCollections(collection);\n  }\n\n  async sync(collection:string) {\n    console.log('Syncing from server to client, and then client updates back to server');\n    const replicationState = replicateRxCollection({\n      collection: this._database![collection],\n      /**\n       * An id for the replication to identify it and so that RxDB is able to resume the replication on app reload.\n       * If you replicate with a remote server, it is recommended to put the server url into the replicationIdentifier.\n       */\n      replicationIdentifier: 'my-rest-replication-to-https://example.com/api/sync',\n      /**\n       * By default it will do an ongoing realtime replication.\n       * By settings live: false the replication will run once until the local state is in sync with the remote state, then it will cancel itself.\n       * (optional), default is true.\n       */\n      live: false,\n      /**\n       * Time in milliseconds after when a failed backend request has to be retried.\n       * This time will be skipped if a offline->online switch is detected via navigator.onLine\n       * (optional), default is 5 seconds.\n       */\n      retryTime: 600 * 1000,\n      /**\n       * When multiInstance is true, like when you use RxDB in multiple browser tabs, the replication should always run in only one of the open browser tabs.\n       * If waitForLeadership is true, it will wait until the current instance is leader.\n       * If waitForLeadership is false, it will start replicating, even if it is not leader.\n       * [default=true]\n       */\n      waitForLeadership: true,\n      /**\n       * If this is set to false, the replication will not start automatically but will wait for replicationState.start() being called.\n       * (optional), default is true\n       */\n      autoStart: true,\n\n      /**\n       * Custom deleted field, the boolean property of the document data that marks a document as being deleted.\n       * If your backend uses a different fieldname then '_deleted', set the fieldname here.\n       * RxDB will still store the documents internally with '_deleted', setting this field only maps the data on the data layer.\n       *\n       * If a custom deleted field contains a non-boolean value, the deleted state\n       * of the documents depends on if the value is truthy or not. So instead of providing a boolean * * deleted value, you could also work with using a 'deletedAt' timestamp instead.\n       *\n       * [default='_deleted']\n       */\n      deletedField: '_deleted',\n\n      /**\n       * Optional,\n       * only needed when you want to replicate local changes to the remote instance.\n       */\n      push: {\n          /**\n           * Push handler\n           */\n          async handler(docs) {\n              /**\n               * Push the local documents to a remote REST server.\n               */\n              const rawResponse = await fetch(`https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync/push?collection=${collection}`, {\n                  method: 'POST',\n                  headers: {\n                      'Accept': 'application/json',\n                      'Content-Type': 'application/json'\n                  },\n                  body: JSON.stringify({ docs })\n              });\n              /**\n               * Contains an array with all conflicts that appeared during this push.\n               * If there were no conflicts, return an empty array.\n               */\n              const response = await rawResponse.json();\n              return response;\n          },\n          /**\n           * Batch size, optional\n           * Defines how many documents will be given to the push handler at once.\n           */\n          batchSize: 5,\n          /**\n           * Modifies all documents before they are given to the push handler.\n           * Can be used to swap out a custom deleted flag instead of the '_deleted' field.\n           * (optional)\n           */\n          modifier: d => d\n      },\n      /**\n       * Optional,\n       * only needed when you want to replicate remote changes to the local state.\n       */\n      pull: {\n          /**\n           * Pull handler\n           */\n          async handler(lastCheckpoint, batchSize) {\n              const minTimestamp = 0;\n              // const minTimestamp = lastCheckpoint ? lastCheckpoint.updatedAt : 0;\n              /**\n               * In this example we replicate with a remote REST server\n               */\n              const response = await fetch(\n                  `https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync?minUpdatedAt=${minTimestamp}&limit=${batchSize}&collection=${collection}`\n              );\n              const documentsFromRemote = await response.json();\n              return {\n                  /**\n                   * Contains the pulled documents from the remote.\n                   * Notice: If documentsFromRemote.length < batchSize,\n                   * then RxDB assumes that there are no more un-replicated documents\n                   * on the backend, so the replication will switch to 'Event observation' mode.\n                   */\n                  documents: documentsFromRemote,\n                  /**\n                   * The last checkpoint of the returned documents.\n                   * On the next call to the pull handler,\n                   * this checkpoint will be passed as 'lastCheckpoint'\n                   */\n                  checkpoint: documentsFromRemote.length === 0 ? lastCheckpoint : {\n                      id: \"\",\n                      updatedAt: \"\"\n                  }\n              };\n          },\n          batchSize: 10,\n          /**\n           * Modifies all documents after they have been pulled\n           * but before they are used by RxDB.\n           * (optional)\n           */\n          modifier: d => d,\n          /**\n           * Stream of the backend document writes.\n           * See below.\n           * You only need a stream$ when you have set live=true\n           */\n          stream$: this.pullStream$.asObservable()\n      },\n    });\n\n\n\n    // emits each document that was received from the remote\n    replicationState.received$.subscribe(doc => console.dir(doc));\n\n    // emits each document that was send to the remote\n    replicationState.send$.subscribe(doc => console.dir(doc));\n\n    // emits all errors that happen when running the push- & pull-handlers.\n    replicationState.error$.subscribe(error => console.dir(error));\n\n    // emits true when the replication was canceled, false when not.\n    replicationState.canceled$.subscribe(bool => console.dir(bool));\n\n    // emits true when a replication cycle is running, false when not.\n    replicationState.active$.subscribe(bool => console.dir(bool));\n  }\n\n  async syncPush(collection:string) {\n    console.log('Syncing client to server');\n    const replicationState = replicateRxCollection({\n      collection: this._database![collection],\n      replicationIdentifier: 'my-rest-replication-to-https://example.com/api/sync',\n      live: false,\n      retryTime: 600 * 1000,\n      waitForLeadership: true,\n      autoStart: true,\n      deletedField: '_deleted',\n      push: {\n          async handler(docs) {\n              const rawResponse = await fetch(`https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync/push?collection=${collection}`, {\n                  method: 'POST',\n                  headers: {\n                      'Accept': 'application/json',\n                      'Content-Type': 'application/json'\n                  },\n                  body: JSON.stringify({ docs })\n              });\n              const response = await rawResponse.json();\n              return response;\n          },\n          batchSize: 5,\n          modifier: d => d\n      },\n    });\n\n    // emits each document that was received from the remote\n    replicationState.received$.subscribe(doc => console.dir(doc));\n\n    // emits each document that was send to the remote\n    replicationState.send$.subscribe(doc => console.dir(doc));\n\n    // emits all errors that happen when running the push- & pull-handlers.\n    replicationState.error$.subscribe(error => console.dir(error));\n\n    // emits true when the replication was canceled, false when not.\n    replicationState.canceled$.subscribe(bool => console.dir(bool));\n\n    // emits true when a replication cycle is running, false when not.\n    replicationState.active$.subscribe(bool => console.dir(bool));\n  }\n\n  async syncPull(collection:string) {\n    console.log('Syncing client to server');\n    const replicationState = replicateRxCollection({\n      collection: this._database![collection],\n      replicationIdentifier: 'my-rest-replication-to-https://example.com/api/sync',\n      live: false,\n      retryTime: 600 * 1000,\n      waitForLeadership: true,\n      autoStart: true,\n      deletedField: '_deleted',\n      pull: {\n        async handler(lastCheckpoint, batchSize) {\n            const minTimestamp = 0;\n            const response = await fetch(\n                `https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync?minUpdatedAt=${minTimestamp}&limit=${batchSize}&collection=${collection}`\n            );\n            const documentsFromRemote = await response.json();\n            return {\n                documents: documentsFromRemote,\n                checkpoint: documentsFromRemote.length === 0 ? lastCheckpoint : {\n                    id: \"\",\n                    updatedAt: \"\"\n                }\n            };\n        },\n        batchSize: 10,\n        modifier: d => d,\n        stream$: this.pullStream$.asObservable()\n    },\n    });\n\n    // emits each document that was received from the remote\n    replicationState.received$.subscribe(doc => console.dir(doc));\n\n    // emits each document that was send to the remote\n    replicationState.send$.subscribe(doc => console.dir(doc));\n\n    // emits all errors that happen when running the push- & pull-handlers.\n    replicationState.error$.subscribe(error => console.dir(error));\n\n    // emits true when the replication was canceled, false when not.\n    replicationState.canceled$.subscribe(bool => console.dir(bool));\n\n    // emits true when a replication cycle is running, false when not.\n    replicationState.active$.subscribe(bool => console.dir(bool));\n  }\n\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n\n  /**\n   * Getter for database\n   */\n  get database(): RxDatabase {\n    return this._database as RxDatabase;\n  }\n\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n\n  /**\n   * Inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be inserted.\n   * @param body - The data object representing the record to be inserted.\n   * @returns A Promise that resolves to void once the record has been successfully inserted.\n   *\n   * @example\n   * await post('orders', { id: 1, product: 'Phone', quantity: 2 });\n   * // Inserts a new record into the 'orders' table with the provided data.\n   */\n  async post(table: string, body: any): Promise<void> {\n    await this.database[table].insert(body);\n  }\n\n  /**\n   * Retrieves a record from the specified table in the local offline storage based on the provided ID.\n   *\n   * @param table - The name of the table from which the record will be retrieved.\n   * @param id - The ID of the record to be retrieved.\n   * @returns A Promise that resolves to the retrieved record.\n   *\n   * @example\n   * const order = await get('orders', '456');\n   * // Retrieves the record with ID '456' from the 'orders' table.\n   */\n  async get(table: string, id: string): Promise<any> {\n    return this.database[table].findOne(id).exec();\n  }\n\n  async getCollection(table: string): Promise<any> {\n    return this.database[table].find().exec();\n  }\n\n\n  /**\n   * Retrieves an Observable stream of records from the specified table in the local offline storage.\n   *\n   * @param table - The name of the table from which the records will be retrieved.\n   * @returns An Observable that emits the records from the specified table.\n   *\n   * @example\n   * // Example usage:\n   * const users$ = get$('users');\n   * users$.subscribe((users) => {\n   *   console.log(users);\n   * });\n   * // Retrieves the records from the 'users' table and logs the emitted records whenever there is an update.\n   */\n  get$(table: string): Observable<any> {\n    return this.database[table].$;\n  }\n\n  /**\n   * Updates an existing record or inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be updated or inserted.\n   * @param body - The data object representing the record to be updated or inserted.\n   * @returns A Promise that resolves to void once the record has been successfully updated or inserted.\n   *\n   * @example\n   * await put('users', { id: '123', name: 'John Doe', age: 30 });\n   * // Updates the record with ID '123' in the 'users' table if it exists, or inserts a new record with the provided data if the record doesn't exist.\n   */\n  async put(table: string, body: any): Promise<void> {\n    await this.database[table].upsert(body);\n  }\n\n\n  /**\n   * DELETE\n   */\n  async delete(): Promise<void> {\n\n  }\n\n  /**\n   * REMOVE\n   */\n  async deleteCollection(table: string): Promise<void> {\n    await this.database[table].remove();\n  }\n\n  /**\n   * Destroy\n   */\n  async destroyCollection(table: string): Promise<void> {\n    await this.database[table].destroy();\n  }\n\n  destroy(): void {\n    this.database.remove()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}