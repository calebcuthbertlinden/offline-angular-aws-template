{"ast":null,"code":"import { nextNodeId } from './util';\nimport { findSimilarNode } from './find-similar-node';\nexport class AbstractNode {\n  constructor(level, rootNode, type) {\n    this.level = level;\n    this.id = nextNodeId();\n    this.deleted = false;\n    this.type = type;\n    this.rootNode = rootNode;\n    if (rootNode) {\n      this.rootNode.addNode(this);\n    }\n  }\n  isEqualToOtherNode(otherNode,\n  // optimisation shortcut, is faster if own string already known\n  ownString = this.toString()) {\n    const ret = ownString === otherNode.toString();\n    return ret;\n  }\n  // deletes the whole node\n  remove() {\n    this.ensureNotDeleted('remove');\n    // console.log('AbstractNode().remove() node: ' + this.id);\n    // console.log(this.toJSON(true));\n    if (this.isInternalNode()) {\n      const useNode = this;\n      if (useNode.parents.size > 0) {\n        throw new Error('cannot remove node with parents ' + this.id);\n      }\n    }\n    if (this.branches) {\n      const useNode = this;\n      if (useNode.branches.areBranchesStrictEqual()) {\n        useNode.branches.getBranch('0').parents.remove(useNode);\n      } else {\n        useNode.branches.getBranch('0').parents.remove(useNode);\n        useNode.branches.getBranch('1').parents.remove(useNode);\n      }\n    }\n    this.deleted = true;\n    this.rootNode.removeNode(this);\n  }\n  toJSON(withId = false) {\n    const ret = {\n      id: withId ? this.id : undefined,\n      deleted: withId ? this.deleted : undefined,\n      type: this.type,\n      level: this.level\n    };\n    if (withId && this.parents) {\n      ret.parents = this.parents.toString();\n    }\n    if (this.isLeafNode()) {\n      ret.value = this.asLeafNode().value;\n    }\n    if (this.branches && !this.branches.deleted) {\n      const branches = this.branches;\n      ret.branches = {\n        '0': branches.getBranch('0').toJSON(withId),\n        '1': branches.getBranch('1').toJSON(withId)\n      };\n    }\n    return ret;\n  }\n  // a strange string-representation\n  // to make an equal check between nodes\n  toString() {\n    let ret = '' + '<' + this.type + ':' + this.level;\n    if (this.branches) {\n      const branches = this.branches;\n      ret += '|0:' + branches.getBranch('0');\n      ret += '|1:' + branches.getBranch('1');\n    }\n    if (this.isLeafNode()) {\n      ret += '|v:' + this.asLeafNode().value;\n    }\n    ret += '>';\n    return ret;\n  }\n  isRootNode() {\n    return this.type === 'RootNode';\n  }\n  isInternalNode() {\n    return this.type === 'InternalNode';\n  }\n  isLeafNode() {\n    return this.type === 'LeafNode';\n  }\n  asRootNode() {\n    if (!this.isRootNode()) {\n      throw new Error('ouch');\n    }\n    return this;\n  }\n  asInternalNode() {\n    if (!this.isInternalNode()) {\n      throw new Error('ouch');\n    }\n    return this;\n  }\n  asLeafNode() {\n    if (!this.isLeafNode()) {\n      throw new Error('ouch');\n    }\n    return this;\n  }\n  ensureNotDeleted(op = 'unknown') {\n    if (this.deleted) {\n      throw new Error('forbidden operation ' + op + ' on deleted node ' + this.id);\n    }\n  }\n  log() {\n    console.log(JSON.stringify(this.toJSON(true), null, 2));\n  }\n  /**\n  * by the elimination-rule of bdd,\n  * if two branches of the same level are equal,\n  * one can be removed\n  *\n  * See page 21 at:\n  * @link https://people.eecs.berkeley.edu/~sseshia/219c/lectures/BinaryDecisionDiagrams.pdf\n  */\n  applyEliminationRule(\n  // can be provided for better performance\n  nodesOfSameLevel) {\n    this.ensureNotDeleted('applyEliminationRule');\n    if (!nodesOfSameLevel) {\n      nodesOfSameLevel = this.rootNode.getNodesOfLevel(this.level);\n    }\n    const other = findSimilarNode(this, nodesOfSameLevel);\n    if (other) {\n      // console.log('applyEliminationRule() remove:' + this.id + '; other: ' + other.id);\n      // keep 'other', remove 'this'\n      // move own parents to other\n      const ownParents = this.parents.getAll();\n      const parentsWithStrictEqualBranches = [];\n      ownParents.forEach(parent => {\n        // console.log('ownParent: ' + parent.id);\n        const branchKey = parent.branches.getKeyOfNode(this);\n        // console.log('branchKey: ' + branchKey);\n        parent.branches.setBranch(branchKey, other);\n        if (parent.branches.areBranchesStrictEqual()) {\n          parentsWithStrictEqualBranches.push(parent);\n        }\n        // remove parents from own list\n        // this will auto-remove the connection to the other '1'-branch\n        this.parents.remove(parent);\n      });\n      // parents that now have equal branches, must be removed again\n      parentsWithStrictEqualBranches.forEach(node => {\n        if (node.isInternalNode()) {\n          // console.log('trigger applyReductionRule from applyEliminationRule');\n          node.applyReductionRule();\n        }\n      });\n      return true;\n    } else {\n      return false;\n    }\n  }\n}","map":{"version":3,"names":["nextNodeId","findSimilarNode","AbstractNode","constructor","level","rootNode","type","id","deleted","addNode","isEqualToOtherNode","otherNode","ownString","toString","ret","remove","ensureNotDeleted","isInternalNode","useNode","parents","size","Error","branches","areBranchesStrictEqual","getBranch","removeNode","toJSON","withId","undefined","isLeafNode","value","asLeafNode","isRootNode","asRootNode","asInternalNode","op","log","console","JSON","stringify","applyEliminationRule","nodesOfSameLevel","getNodesOfLevel","other","ownParents","getAll","parentsWithStrictEqualBranches","forEach","parent","branchKey","getKeyOfNode","setBranch","push","node","applyReductionRule"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/binary-decision-diagram/dist/es/abstract-node.js"],"sourcesContent":["import { nextNodeId } from './util';\nimport { findSimilarNode } from './find-similar-node';\nexport class AbstractNode {\n    constructor(level, rootNode, type) {\n        this.level = level;\n        this.id = nextNodeId();\n        this.deleted = false;\n        this.type = type;\n        this.rootNode = rootNode;\n        if (rootNode) {\n            this.rootNode.addNode(this);\n        }\n    }\n    isEqualToOtherNode(otherNode, \n    // optimisation shortcut, is faster if own string already known\n    ownString = this.toString()) {\n        const ret = ownString === otherNode.toString();\n        return ret;\n    }\n    // deletes the whole node\n    remove() {\n        this.ensureNotDeleted('remove');\n        // console.log('AbstractNode().remove() node: ' + this.id);\n        // console.log(this.toJSON(true));\n        if (this.isInternalNode()) {\n            const useNode = this;\n            if (useNode.parents.size > 0) {\n                throw new Error('cannot remove node with parents ' + this.id);\n            }\n        }\n        if (this.branches) {\n            const useNode = this;\n            if (useNode.branches.areBranchesStrictEqual()) {\n                useNode.branches.getBranch('0').parents.remove(useNode);\n            }\n            else {\n                useNode.branches.getBranch('0').parents.remove(useNode);\n                useNode.branches.getBranch('1').parents.remove(useNode);\n            }\n        }\n        this.deleted = true;\n        this.rootNode.removeNode(this);\n    }\n    toJSON(withId = false) {\n        const ret = {\n            id: withId ? this.id : undefined,\n            deleted: withId ? this.deleted : undefined,\n            type: this.type,\n            level: this.level\n        };\n        if (withId && this.parents) {\n            ret.parents = this.parents.toString();\n        }\n        if (this.isLeafNode()) {\n            ret.value = this.asLeafNode().value;\n        }\n        if (this.branches && !this.branches.deleted) {\n            const branches = this.branches;\n            ret.branches = {\n                '0': branches.getBranch('0').toJSON(withId),\n                '1': branches.getBranch('1').toJSON(withId)\n            };\n        }\n        return ret;\n    }\n    // a strange string-representation\n    // to make an equal check between nodes\n    toString() {\n        let ret = '' +\n            '<' +\n            this.type + ':' + this.level;\n        if (this.branches) {\n            const branches = this.branches;\n            ret += '|0:' + branches.getBranch('0');\n            ret += '|1:' + branches.getBranch('1');\n        }\n        if (this.isLeafNode()) {\n            ret += '|v:' + this.asLeafNode().value;\n        }\n        ret += '>';\n        return ret;\n    }\n    isRootNode() {\n        return this.type === 'RootNode';\n    }\n    isInternalNode() {\n        return this.type === 'InternalNode';\n    }\n    isLeafNode() {\n        return this.type === 'LeafNode';\n    }\n    asRootNode() {\n        if (!this.isRootNode()) {\n            throw new Error('ouch');\n        }\n        return this;\n    }\n    asInternalNode() {\n        if (!this.isInternalNode()) {\n            throw new Error('ouch');\n        }\n        return this;\n    }\n    asLeafNode() {\n        if (!this.isLeafNode()) {\n            throw new Error('ouch');\n        }\n        return this;\n    }\n    ensureNotDeleted(op = 'unknown') {\n        if (this.deleted) {\n            throw new Error('forbidden operation ' + op + ' on deleted node ' + this.id);\n        }\n    }\n    log() {\n        console.log(JSON.stringify(this.toJSON(true), null, 2));\n    }\n    /**\n * by the elimination-rule of bdd,\n * if two branches of the same level are equal,\n * one can be removed\n *\n * See page 21 at:\n * @link https://people.eecs.berkeley.edu/~sseshia/219c/lectures/BinaryDecisionDiagrams.pdf\n */\n    applyEliminationRule(\n    // can be provided for better performance\n    nodesOfSameLevel) {\n        this.ensureNotDeleted('applyEliminationRule');\n        if (!nodesOfSameLevel) {\n            nodesOfSameLevel = this.rootNode.getNodesOfLevel(this.level);\n        }\n        const other = findSimilarNode(this, nodesOfSameLevel);\n        if (other) {\n            // console.log('applyEliminationRule() remove:' + this.id + '; other: ' + other.id);\n            // keep 'other', remove 'this'\n            // move own parents to other\n            const ownParents = this.parents.getAll();\n            const parentsWithStrictEqualBranches = [];\n            ownParents.forEach((parent) => {\n                // console.log('ownParent: ' + parent.id);\n                const branchKey = parent.branches.getKeyOfNode(this);\n                // console.log('branchKey: ' + branchKey);\n                parent.branches.setBranch(branchKey, other);\n                if (parent.branches.areBranchesStrictEqual()) {\n                    parentsWithStrictEqualBranches.push(parent);\n                }\n                // remove parents from own list\n                // this will auto-remove the connection to the other '1'-branch\n                this.parents.remove(parent);\n            });\n            // parents that now have equal branches, must be removed again\n            parentsWithStrictEqualBranches.forEach(node => {\n                if (node.isInternalNode()) {\n                    // console.log('trigger applyReductionRule from applyEliminationRule');\n                    node.applyReductionRule();\n                }\n            });\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}