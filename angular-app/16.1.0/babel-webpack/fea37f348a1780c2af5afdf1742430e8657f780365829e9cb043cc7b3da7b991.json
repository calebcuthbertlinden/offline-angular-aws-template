{"ast":null,"code":"import _defineProperty from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { getOperator, initOptions, OperatorType, ProcessingMode } from \"./core\";\nimport { Lazy } from \"./lazy\";\nimport { assert, cloneDeep, intersection, isEmpty } from \"./util\";\n/**\n * Provides functionality for the mongoDB aggregation pipeline\n *\n * @param pipeline an Array of pipeline operators\n * @param options An optional Options to pass the aggregator\n * @constructor\n */\nexport class Aggregator {\n  constructor(pipeline, options) {\n    _defineProperty(this, \"pipeline\", void 0);\n    _defineProperty(this, \"options\", void 0);\n    this.pipeline = pipeline;\n    this.options = options;\n    this.options = initOptions(options);\n  }\n  /**\n   * Returns an `Lazy` iterator for processing results of pipeline\n   *\n   * @param {*} collection An array or iterator object\n   * @param {Query} query the `Query` object to use as context\n   * @returns {Iterator} an iterator object\n   */\n  stream(collection) {\n    let iterator = Lazy(collection);\n    const mode = this.options.processingMode;\n    if (mode == ProcessingMode.CLONE_ALL || mode == ProcessingMode.CLONE_INPUT) {\n      iterator.map(cloneDeep);\n    }\n    const pipelineOperators = [];\n    if (!isEmpty(this.pipeline)) {\n      // run aggregation pipeline\n      for (const operator of this.pipeline) {\n        const operatorKeys = Object.keys(operator);\n        const op = operatorKeys[0];\n        const call = getOperator(OperatorType.PIPELINE, op);\n        assert(operatorKeys.length === 1 && !!call, `invalid aggregation operator ${op}`);\n        pipelineOperators.push(op);\n        iterator = call(iterator, operator[op], this.options);\n      }\n    }\n    // operators that may share object graphs of inputs.\n    // we only need to clone the output for these since the objects will already be distinct for other operators.\n    if (mode == ProcessingMode.CLONE_OUTPUT || mode == ProcessingMode.CLONE_ALL && !!intersection([[\"$group\", \"$unwind\"], pipelineOperators]).length) {\n      iterator.map(cloneDeep);\n    }\n    return iterator;\n  }\n  /**\n   * Return the results of the aggregation as an array.\n   *\n   * @param {*} collection\n   * @param {*} query\n   */\n  run(collection) {\n    return this.stream(collection).value();\n  }\n}","map":{"version":3,"names":["getOperator","initOptions","OperatorType","ProcessingMode","Lazy","assert","cloneDeep","intersection","isEmpty","Aggregator","constructor","pipeline","options","_defineProperty","stream","collection","iterator","mode","processingMode","CLONE_ALL","CLONE_INPUT","map","pipelineOperators","operator","operatorKeys","Object","keys","op","call","PIPELINE","length","push","CLONE_OUTPUT","run","value"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/mingo/es/aggregator.js"],"sourcesContent":["import { getOperator, initOptions, OperatorType, ProcessingMode, } from \"./core\";\nimport { Lazy } from \"./lazy\";\nimport { assert, cloneDeep, intersection, isEmpty } from \"./util\";\n/**\n * Provides functionality for the mongoDB aggregation pipeline\n *\n * @param pipeline an Array of pipeline operators\n * @param options An optional Options to pass the aggregator\n * @constructor\n */\nexport class Aggregator {\n    pipeline;\n    options;\n    constructor(pipeline, options) {\n        this.pipeline = pipeline;\n        this.options = options;\n        this.options = initOptions(options);\n    }\n    /**\n     * Returns an `Lazy` iterator for processing results of pipeline\n     *\n     * @param {*} collection An array or iterator object\n     * @param {Query} query the `Query` object to use as context\n     * @returns {Iterator} an iterator object\n     */\n    stream(collection) {\n        let iterator = Lazy(collection);\n        const mode = this.options.processingMode;\n        if (mode == ProcessingMode.CLONE_ALL ||\n            mode == ProcessingMode.CLONE_INPUT) {\n            iterator.map(cloneDeep);\n        }\n        const pipelineOperators = [];\n        if (!isEmpty(this.pipeline)) {\n            // run aggregation pipeline\n            for (const operator of this.pipeline) {\n                const operatorKeys = Object.keys(operator);\n                const op = operatorKeys[0];\n                const call = getOperator(OperatorType.PIPELINE, op);\n                assert(operatorKeys.length === 1 && !!call, `invalid aggregation operator ${op}`);\n                pipelineOperators.push(op);\n                iterator = call(iterator, operator[op], this.options);\n            }\n        }\n        // operators that may share object graphs of inputs.\n        // we only need to clone the output for these since the objects will already be distinct for other operators.\n        if (mode == ProcessingMode.CLONE_OUTPUT ||\n            (mode == ProcessingMode.CLONE_ALL &&\n                !!intersection([[\"$group\", \"$unwind\"], pipelineOperators]).length)) {\n            iterator.map(cloneDeep);\n        }\n        return iterator;\n    }\n    /**\n     * Return the results of the aggregation as an array.\n     *\n     * @param {*} collection\n     * @param {*} query\n     */\n    run(collection) {\n        return this.stream(collection).value();\n    }\n}\n"],"mappings":";AAAA,SAASA,WAAW,EAAEC,WAAW,EAAEC,YAAY,EAAEC,cAAc,QAAS,QAAQ;AAChF,SAASC,IAAI,QAAQ,QAAQ;AAC7B,SAASC,MAAM,EAAEC,SAAS,EAAEC,YAAY,EAAEC,OAAO,QAAQ,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,CAAC;EAGpBC,WAAWA,CAACC,QAAQ,EAAEC,OAAO,EAAE;IAAAC,eAAA;IAAAA,eAAA;IAC3B,IAAI,CAACF,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACA,OAAO,GAAGX,WAAW,CAACW,OAAO,CAAC;EACvC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIE,MAAMA,CAACC,UAAU,EAAE;IACf,IAAIC,QAAQ,GAAGZ,IAAI,CAACW,UAAU,CAAC;IAC/B,MAAME,IAAI,GAAG,IAAI,CAACL,OAAO,CAACM,cAAc;IACxC,IAAID,IAAI,IAAId,cAAc,CAACgB,SAAS,IAChCF,IAAI,IAAId,cAAc,CAACiB,WAAW,EAAE;MACpCJ,QAAQ,CAACK,GAAG,CAACf,SAAS,CAAC;IAC3B;IACA,MAAMgB,iBAAiB,GAAG,EAAE;IAC5B,IAAI,CAACd,OAAO,CAAC,IAAI,CAACG,QAAQ,CAAC,EAAE;MACzB;MACA,KAAK,MAAMY,QAAQ,IAAI,IAAI,CAACZ,QAAQ,EAAE;QAClC,MAAMa,YAAY,GAAGC,MAAM,CAACC,IAAI,CAACH,QAAQ,CAAC;QAC1C,MAAMI,EAAE,GAAGH,YAAY,CAAC,CAAC,CAAC;QAC1B,MAAMI,IAAI,GAAG5B,WAAW,CAACE,YAAY,CAAC2B,QAAQ,EAAEF,EAAE,CAAC;QACnDtB,MAAM,CAACmB,YAAY,CAACM,MAAM,KAAK,CAAC,IAAI,CAAC,CAACF,IAAI,EAAG,gCAA+BD,EAAG,EAAC,CAAC;QACjFL,iBAAiB,CAACS,IAAI,CAACJ,EAAE,CAAC;QAC1BX,QAAQ,GAAGY,IAAI,CAACZ,QAAQ,EAAEO,QAAQ,CAACI,EAAE,CAAC,EAAE,IAAI,CAACf,OAAO,CAAC;MACzD;IACJ;IACA;IACA;IACA,IAAIK,IAAI,IAAId,cAAc,CAAC6B,YAAY,IAClCf,IAAI,IAAId,cAAc,CAACgB,SAAS,IAC7B,CAAC,CAACZ,YAAY,CAAC,CAAC,CAAC,QAAQ,EAAE,SAAS,CAAC,EAAEe,iBAAiB,CAAC,CAAC,CAACQ,MAAO,EAAE;MACxEd,QAAQ,CAACK,GAAG,CAACf,SAAS,CAAC;IAC3B;IACA,OAAOU,QAAQ;EACnB;EACA;AACJ;AACA;AACA;AACA;AACA;EACIiB,GAAGA,CAAClB,UAAU,EAAE;IACZ,OAAO,IAAI,CAACD,MAAM,CAACC,UAAU,CAAC,CAACmB,KAAK,CAAC,CAAC;EAC1C;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}