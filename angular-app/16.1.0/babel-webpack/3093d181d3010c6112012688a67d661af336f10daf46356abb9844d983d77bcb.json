{"ast":null,"code":"/**\n * returns a promise that resolves on the next tick\n */\nexport function nextTick() {\n  return new Promise(res => setTimeout(res, 0));\n}\nexport function promiseWait(ms = 0) {\n  return new Promise(res => setTimeout(res, ms));\n}\nexport function toPromise(maybePromise) {\n  if (maybePromise && typeof maybePromise.then === 'function') {\n    // is promise\n    return maybePromise;\n  } else {\n    return Promise.resolve(maybePromise);\n  }\n}\n\n/**\n * Reusing resolved promises has a better\n * performance than creating new ones each time.\n */\nexport var PROMISE_RESOLVE_TRUE = Promise.resolve(true);\nexport var PROMISE_RESOLVE_FALSE = Promise.resolve(false);\nexport var PROMISE_RESOLVE_NULL = Promise.resolve(null);\nexport var PROMISE_RESOLVE_VOID = Promise.resolve();\n\n/**\n * If multiple operations wait for an requestIdlePromise\n * we do not want them to resolve all at the same time.\n * So we have to queue the calls.\n */\nvar idlePromiseQueue = PROMISE_RESOLVE_VOID;\nexport function requestIdlePromise(timeout = null) {\n  return new Promise(res => {\n    idlePromiseQueue = idlePromiseQueue.then(() => {\n      if (typeof window === 'object' && window['requestIdleCallback']) {\n        window['requestIdleCallback'](res, {\n          timeout\n        });\n      } else {\n        promiseWait(0).then(res);\n      }\n    });\n  });\n}\n\n/**\n * run the callback if requestIdleCallback available\n * do nothing if not\n * @link https://developer.mozilla.org/de/docs/Web/API/Window/requestIdleCallback\n */\nexport function requestIdleCallbackIfAvailable(fun) {\n  if (typeof window === 'object' && window['requestIdleCallback']) window['requestIdleCallback'](fun);\n}\n\n/**\n * like Promise.all() but runs in series instead of parallel\n * @link https://github.com/egoist/promise.series/blob/master/index.js\n * @param tasks array with functions that return a promise\n */\nexport function promiseSeries(tasks, initial) {\n  return tasks.reduce((current, next) => current.then(next), Promise.resolve(initial));\n}","map":{"version":3,"names":["nextTick","Promise","res","setTimeout","promiseWait","ms","toPromise","maybePromise","then","resolve","PROMISE_RESOLVE_TRUE","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_NULL","PROMISE_RESOLVE_VOID","idlePromiseQueue","requestIdlePromise","timeout","window","requestIdleCallbackIfAvailable","fun","promiseSeries","tasks","initial","reduce","current","next"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/plugins/utils/utils-promise.js"],"sourcesContent":["/**\n * returns a promise that resolves on the next tick\n */\nexport function nextTick() {\n  return new Promise(res => setTimeout(res, 0));\n}\nexport function promiseWait(ms = 0) {\n  return new Promise(res => setTimeout(res, ms));\n}\nexport function toPromise(maybePromise) {\n  if (maybePromise && typeof maybePromise.then === 'function') {\n    // is promise\n    return maybePromise;\n  } else {\n    return Promise.resolve(maybePromise);\n  }\n}\n\n/**\n * Reusing resolved promises has a better\n * performance than creating new ones each time.\n */\nexport var PROMISE_RESOLVE_TRUE = Promise.resolve(true);\nexport var PROMISE_RESOLVE_FALSE = Promise.resolve(false);\nexport var PROMISE_RESOLVE_NULL = Promise.resolve(null);\nexport var PROMISE_RESOLVE_VOID = Promise.resolve();\n\n/**\n * If multiple operations wait for an requestIdlePromise\n * we do not want them to resolve all at the same time.\n * So we have to queue the calls.\n */\nvar idlePromiseQueue = PROMISE_RESOLVE_VOID;\nexport function requestIdlePromise(timeout = null) {\n  return new Promise(res => {\n    idlePromiseQueue = idlePromiseQueue.then(() => {\n      if (typeof window === 'object' && window['requestIdleCallback']) {\n        window['requestIdleCallback'](res, {\n          timeout\n        });\n      } else {\n        promiseWait(0).then(res);\n      }\n    });\n  });\n}\n\n/**\n * run the callback if requestIdleCallback available\n * do nothing if not\n * @link https://developer.mozilla.org/de/docs/Web/API/Window/requestIdleCallback\n */\nexport function requestIdleCallbackIfAvailable(fun) {\n  if (typeof window === 'object' && window['requestIdleCallback']) window['requestIdleCallback'](fun);\n}\n\n/**\n * like Promise.all() but runs in series instead of parallel\n * @link https://github.com/egoist/promise.series/blob/master/index.js\n * @param tasks array with functions that return a promise\n */\nexport function promiseSeries(tasks, initial) {\n  return tasks.reduce((current, next) => current.then(next), Promise.resolve(initial));\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAO,SAASA,QAAQA,CAAA,EAAG;EACzB,OAAO,IAAIC,OAAO,CAACC,GAAG,IAAIC,UAAU,CAACD,GAAG,EAAE,CAAC,CAAC,CAAC;AAC/C;AACA,OAAO,SAASE,WAAWA,CAACC,EAAE,GAAG,CAAC,EAAE;EAClC,OAAO,IAAIJ,OAAO,CAACC,GAAG,IAAIC,UAAU,CAACD,GAAG,EAAEG,EAAE,CAAC,CAAC;AAChD;AACA,OAAO,SAASC,SAASA,CAACC,YAAY,EAAE;EACtC,IAAIA,YAAY,IAAI,OAAOA,YAAY,CAACC,IAAI,KAAK,UAAU,EAAE;IAC3D;IACA,OAAOD,YAAY;EACrB,CAAC,MAAM;IACL,OAAON,OAAO,CAACQ,OAAO,CAACF,YAAY,CAAC;EACtC;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,IAAIG,oBAAoB,GAAGT,OAAO,CAACQ,OAAO,CAAC,IAAI,CAAC;AACvD,OAAO,IAAIE,qBAAqB,GAAGV,OAAO,CAACQ,OAAO,CAAC,KAAK,CAAC;AACzD,OAAO,IAAIG,oBAAoB,GAAGX,OAAO,CAACQ,OAAO,CAAC,IAAI,CAAC;AACvD,OAAO,IAAII,oBAAoB,GAAGZ,OAAO,CAACQ,OAAO,CAAC,CAAC;;AAEnD;AACA;AACA;AACA;AACA;AACA,IAAIK,gBAAgB,GAAGD,oBAAoB;AAC3C,OAAO,SAASE,kBAAkBA,CAACC,OAAO,GAAG,IAAI,EAAE;EACjD,OAAO,IAAIf,OAAO,CAACC,GAAG,IAAI;IACxBY,gBAAgB,GAAGA,gBAAgB,CAACN,IAAI,CAAC,MAAM;MAC7C,IAAI,OAAOS,MAAM,KAAK,QAAQ,IAAIA,MAAM,CAAC,qBAAqB,CAAC,EAAE;QAC/DA,MAAM,CAAC,qBAAqB,CAAC,CAACf,GAAG,EAAE;UACjCc;QACF,CAAC,CAAC;MACJ,CAAC,MAAM;QACLZ,WAAW,CAAC,CAAC,CAAC,CAACI,IAAI,CAACN,GAAG,CAAC;MAC1B;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASgB,8BAA8BA,CAACC,GAAG,EAAE;EAClD,IAAI,OAAOF,MAAM,KAAK,QAAQ,IAAIA,MAAM,CAAC,qBAAqB,CAAC,EAAEA,MAAM,CAAC,qBAAqB,CAAC,CAACE,GAAG,CAAC;AACrG;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAACC,KAAK,EAAEC,OAAO,EAAE;EAC5C,OAAOD,KAAK,CAACE,MAAM,CAAC,CAACC,OAAO,EAAEC,IAAI,KAAKD,OAAO,CAAChB,IAAI,CAACiB,IAAI,CAAC,EAAExB,OAAO,CAACQ,OAAO,CAACa,OAAO,CAAC,CAAC;AACtF"},"metadata":{},"sourceType":"module","externalDependencies":[]}