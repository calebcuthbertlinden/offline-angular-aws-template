{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { createBddFromTruthTable } from './create-bdd-from-truth-table';\nimport { firstKeyOfMap, shuffleArray, lastOfArray } from './util';\n/**\n * returns the bdd with less nodes\n */\nexport const defaultCompareResults = function (a, b) {\n  if (a.countNodes() <= b.countNodes()) {\n    return a;\n  } else {\n    return b;\n  }\n};\n/**\n * optimises the ordering of the boolean functions\n * by randomly sorting the array\n * and checking the resulting bdd\n */\nexport function optimizeBruteForce(_x) {\n  return _optimizeBruteForce.apply(this, arguments);\n}\nfunction _optimizeBruteForce() {\n  _optimizeBruteForce = _asyncToGenerator(function* ({\n    truthTable,\n    iterations = Infinity,\n    onBetterBdd = () => null,\n    compareResults = defaultCompareResults,\n    afterBddCreation = () => null,\n    log = false\n  }) {\n    const initialBdd = createBddFromTruthTable(truthTable);\n    afterBddCreation(initialBdd);\n    initialBdd.minimize();\n    let currentBestResult = {\n      truthTable,\n      bdd: initialBdd\n    };\n    if (log) {\n      initialBdd.log();\n      console.log('initial nodes amount: ' + initialBdd.countNodes());\n    }\n    let t = 0;\n    while (t < iterations) {\n      t++;\n      if (log) {\n        console.log('-'.repeat(50));\n        console.log('optimizeBruteForce() itterate once');\n      }\n      const shuffledOrdering = shuffleBooleanOrdering(truthTable);\n      const nextBdd = createBddFromTruthTable(shuffledOrdering.newTable);\n      // change the levels of each node\n      const newNodesByLevel = new Map();\n      const lastLevel = lastOfArray(nextBdd.getLevels());\n      const newSortedLevels = [];\n      nextBdd.getLevels().filter(level => level !== lastLevel).forEach(level => {\n        const newLevel = shuffledOrdering.mappingBeforeToAfter[level];\n        newSortedLevels.push(newLevel);\n        const levelSet = new Set();\n        newNodesByLevel.set(newLevel, levelSet);\n        nextBdd.getNodesOfLevel(level).forEach(node => {\n          node.level = newLevel;\n          levelSet.add(node);\n        });\n      });\n      const lastLevelSet = new Set();\n      nextBdd.getNodesOfLevel(lastLevel).forEach(node => lastLevelSet.add(node));\n      newNodesByLevel.set(lastLevel, lastLevelSet);\n      newSortedLevels.push(lastLevel);\n      nextBdd.nodesByLevel = newNodesByLevel;\n      nextBdd.levels = newSortedLevels;\n      afterBddCreation(nextBdd);\n      nextBdd.minimize();\n      if (log) {\n        console.log('got new bdd with nodes amount of ' + nextBdd.countNodes());\n        //            nextBdd.log();\n        console.dir(shuffledOrdering.mappingBeforeToAfter);\n      }\n      const betterBdd = yield compareResults(currentBestResult.bdd, nextBdd);\n      if (betterBdd.type !== 'RootNode') {\n        throw new Error('compareResults did not return a bdd');\n      }\n      if (betterBdd === nextBdd) {\n        if (log) {\n          console.log('#'.repeat(50));\n          console.log('found better bdd ' + nextBdd.countNodes());\n        }\n        currentBestResult = {\n          bdd: nextBdd,\n          truthTable: shuffledOrdering.newTable\n        };\n        onBetterBdd(currentBestResult);\n      }\n    }\n    return currentBestResult;\n  });\n  return _optimizeBruteForce.apply(this, arguments);\n}\nexport function shuffleBooleanOrdering(truthTable) {\n  const firstKey = firstKeyOfMap(truthTable);\n  const arrayWithIndexes = getArrayWithIndexes(firstKey.length);\n  const shuffled = shuffleArray(arrayWithIndexes);\n  const mapping = {};\n  const mappingBeforeToAfter = {};\n  shuffled.forEach((indexBefore, indexAfter) => {\n    mapping[indexAfter] = indexBefore;\n    mappingBeforeToAfter[indexBefore] = indexAfter;\n  });\n  const newTable = new Map();\n  for (const [key, value] of truthTable.entries()) {\n    const newKey = changeKeyOrder(key, mapping);\n    newTable.set(newKey, value);\n  }\n  return {\n    newTable,\n    mapping,\n    mappingBeforeToAfter\n  };\n}\nexport function changeKeyOrder(oldKey, mappingBeforeToAfter) {\n  const chars = oldKey.split('').map((char, indexBefore) => {\n    return {\n      char,\n      indexBefore,\n      indexAfter: mappingBeforeToAfter[indexBefore]\n    };\n  }).sort((a, b) => a.indexAfter - b.indexAfter).map(charObj => charObj.char).join('');\n  return chars;\n}\nexport function getArrayWithIndexes(size) {\n  const ret = [];\n  let last = 0;\n  while (last < size) {\n    ret.push(last);\n    last++;\n  }\n  return ret;\n}","map":{"version":3,"names":["createBddFromTruthTable","firstKeyOfMap","shuffleArray","lastOfArray","defaultCompareResults","a","b","countNodes","optimizeBruteForce","_x","_optimizeBruteForce","apply","arguments","_asyncToGenerator","truthTable","iterations","Infinity","onBetterBdd","compareResults","afterBddCreation","log","initialBdd","minimize","currentBestResult","bdd","console","t","repeat","shuffledOrdering","shuffleBooleanOrdering","nextBdd","newTable","newNodesByLevel","Map","lastLevel","getLevels","newSortedLevels","filter","level","forEach","newLevel","mappingBeforeToAfter","push","levelSet","Set","set","getNodesOfLevel","node","add","lastLevelSet","nodesByLevel","levels","dir","betterBdd","type","Error","firstKey","arrayWithIndexes","getArrayWithIndexes","length","shuffled","mapping","indexBefore","indexAfter","key","value","entries","newKey","changeKeyOrder","oldKey","chars","split","map","char","sort","charObj","join","size","ret","last"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/binary-decision-diagram/dist/es/optimize-brute-force.js"],"sourcesContent":["import { createBddFromTruthTable } from './create-bdd-from-truth-table';\nimport { firstKeyOfMap, shuffleArray, lastOfArray } from './util';\n/**\n * returns the bdd with less nodes\n */\nexport const defaultCompareResults = function (a, b) {\n    if (a.countNodes() <= b.countNodes()) {\n        return a;\n    }\n    else {\n        return b;\n    }\n};\n/**\n * optimises the ordering of the boolean functions\n * by randomly sorting the array\n * and checking the resulting bdd\n */\nexport async function optimizeBruteForce({ truthTable, iterations = Infinity, onBetterBdd = () => null, compareResults = defaultCompareResults, afterBddCreation = () => null, log = false }) {\n    const initialBdd = createBddFromTruthTable(truthTable);\n    afterBddCreation(initialBdd);\n    initialBdd.minimize();\n    let currentBestResult = {\n        truthTable,\n        bdd: initialBdd\n    };\n    if (log) {\n        initialBdd.log();\n        console.log('initial nodes amount: ' + initialBdd.countNodes());\n    }\n    let t = 0;\n    while (t < iterations) {\n        t++;\n        if (log) {\n            console.log('-'.repeat(50));\n            console.log('optimizeBruteForce() itterate once');\n        }\n        const shuffledOrdering = shuffleBooleanOrdering(truthTable);\n        const nextBdd = createBddFromTruthTable(shuffledOrdering.newTable);\n        // change the levels of each node\n        const newNodesByLevel = new Map();\n        const lastLevel = lastOfArray(nextBdd.getLevels());\n        const newSortedLevels = [];\n        nextBdd.getLevels()\n            .filter(level => level !== lastLevel)\n            .forEach(level => {\n            const newLevel = shuffledOrdering.mappingBeforeToAfter[level];\n            newSortedLevels.push(newLevel);\n            const levelSet = new Set();\n            newNodesByLevel.set(newLevel, levelSet);\n            nextBdd.getNodesOfLevel(level).forEach(node => {\n                node.level = newLevel;\n                levelSet.add(node);\n            });\n        });\n        const lastLevelSet = new Set();\n        nextBdd.getNodesOfLevel(lastLevel).forEach(node => lastLevelSet.add(node));\n        newNodesByLevel.set(lastLevel, lastLevelSet);\n        newSortedLevels.push(lastLevel);\n        nextBdd.nodesByLevel = newNodesByLevel;\n        nextBdd.levels = newSortedLevels;\n        afterBddCreation(nextBdd);\n        nextBdd.minimize();\n        if (log) {\n            console.log('got new bdd with nodes amount of ' + nextBdd.countNodes());\n            //            nextBdd.log();\n            console.dir(shuffledOrdering.mappingBeforeToAfter);\n        }\n        const betterBdd = await compareResults(currentBestResult.bdd, nextBdd);\n        if (betterBdd.type !== 'RootNode') {\n            throw new Error('compareResults did not return a bdd');\n        }\n        if (betterBdd === nextBdd) {\n            if (log) {\n                console.log('#'.repeat(50));\n                console.log('found better bdd ' + nextBdd.countNodes());\n            }\n            currentBestResult = {\n                bdd: nextBdd,\n                truthTable: shuffledOrdering.newTable\n            };\n            onBetterBdd(currentBestResult);\n        }\n    }\n    return currentBestResult;\n}\nexport function shuffleBooleanOrdering(truthTable) {\n    const firstKey = firstKeyOfMap(truthTable);\n    const arrayWithIndexes = getArrayWithIndexes(firstKey.length);\n    const shuffled = shuffleArray(arrayWithIndexes);\n    const mapping = {};\n    const mappingBeforeToAfter = {};\n    shuffled.forEach((indexBefore, indexAfter) => {\n        mapping[indexAfter] = indexBefore;\n        mappingBeforeToAfter[indexBefore] = indexAfter;\n    });\n    const newTable = new Map();\n    for (const [key, value] of truthTable.entries()) {\n        const newKey = changeKeyOrder(key, mapping);\n        newTable.set(newKey, value);\n    }\n    return {\n        newTable,\n        mapping,\n        mappingBeforeToAfter\n    };\n}\nexport function changeKeyOrder(oldKey, mappingBeforeToAfter) {\n    const chars = oldKey\n        .split('')\n        .map((char, indexBefore) => {\n        return {\n            char,\n            indexBefore,\n            indexAfter: mappingBeforeToAfter[indexBefore]\n        };\n    })\n        .sort((a, b) => a.indexAfter - b.indexAfter)\n        .map(charObj => charObj.char)\n        .join('');\n    return chars;\n}\nexport function getArrayWithIndexes(size) {\n    const ret = [];\n    let last = 0;\n    while (last < size) {\n        ret.push(last);\n        last++;\n    }\n    return ret;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}