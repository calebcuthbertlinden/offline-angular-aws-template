{"ast":null,"code":"import { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData, getLengthOfPrimaryKey } from '../rx-schema-helper';\nimport { flatCloneDocWithMeta } from '../rx-storage-helper';\nimport { getDefaultRevision, createRevision, now } from '../plugins/utils';\nexport function getRxReplicationMetaInstanceSchema(replicatedDocumentsSchema, encrypted) {\n  var parentPrimaryKeyLength = getLengthOfPrimaryKey(replicatedDocumentsSchema);\n  var baseSchema = {\n    primaryKey: {\n      key: 'id',\n      fields: ['itemId', 'isCheckpoint'],\n      separator: '|'\n    },\n    type: 'object',\n    version: 0,\n    additionalProperties: false,\n    properties: {\n      id: {\n        type: 'string',\n        minLength: 1,\n        // add +1 for the '|' and +1 for the 'isCheckpoint' flag\n        maxLength: parentPrimaryKeyLength + 2\n      },\n      isCheckpoint: {\n        type: 'string',\n        enum: ['0', '1'],\n        minLength: 1,\n        maxLength: 1\n      },\n      itemId: {\n        type: 'string',\n        maxLength: parentPrimaryKeyLength\n      },\n      data: {\n        type: 'object',\n        additionalProperties: true\n      },\n      isResolvedConflict: {\n        type: 'string'\n      }\n    },\n    required: ['id', 'isCheckpoint', 'itemId', 'data']\n  };\n  if (encrypted) {\n    baseSchema.encrypted = ['data'];\n  }\n  var metaInstanceSchema = fillWithDefaultSettings(baseSchema);\n  return metaInstanceSchema;\n}\n\n/**\n * Returns the document states of what the fork instance\n * assumes to be the latest state on the master instance.\n */\nexport function getAssumedMasterState(state, docIds) {\n  return state.input.metaInstance.findDocumentsById(docIds.map(docId => {\n    var useId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {\n      itemId: docId,\n      isCheckpoint: '0'\n    });\n    return useId;\n  }), true).then(metaDocs => {\n    var ret = {};\n    Object.values(metaDocs).forEach(metaDoc => {\n      ret[metaDoc.itemId] = {\n        docData: metaDoc.data,\n        metaDocument: metaDoc\n      };\n    });\n    return ret;\n  });\n}\nexport function getMetaWriteRow(state, newMasterDocState, previous, isResolvedConflict) {\n  var docId = newMasterDocState[state.primaryPath];\n  var newMeta = previous ? flatCloneDocWithMeta(previous) : {\n    id: '',\n    isCheckpoint: '0',\n    itemId: docId,\n    data: newMasterDocState,\n    _attachments: {},\n    _deleted: false,\n    _rev: getDefaultRevision(),\n    _meta: {\n      lwt: 0\n    }\n  };\n  newMeta.data = newMasterDocState;\n  newMeta.isResolvedConflict = isResolvedConflict;\n  newMeta._meta.lwt = now();\n  newMeta.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newMeta);\n  newMeta._rev = createRevision(state.input.identifier, previous);\n  return {\n    previous,\n    document: newMeta\n  };\n}","map":{"version":3,"names":["fillWithDefaultSettings","getComposedPrimaryKeyOfDocumentData","getLengthOfPrimaryKey","flatCloneDocWithMeta","getDefaultRevision","createRevision","now","getRxReplicationMetaInstanceSchema","replicatedDocumentsSchema","encrypted","parentPrimaryKeyLength","baseSchema","primaryKey","key","fields","separator","type","version","additionalProperties","properties","id","minLength","maxLength","isCheckpoint","enum","itemId","data","isResolvedConflict","required","metaInstanceSchema","getAssumedMasterState","state","docIds","input","metaInstance","findDocumentsById","map","docId","useId","schema","then","metaDocs","ret","Object","values","forEach","metaDoc","docData","metaDocument","getMetaWriteRow","newMasterDocState","previous","primaryPath","newMeta","_attachments","_deleted","_rev","_meta","lwt","identifier","document"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/replication-protocol/meta-instance.js"],"sourcesContent":["import { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData, getLengthOfPrimaryKey } from '../rx-schema-helper';\nimport { flatCloneDocWithMeta } from '../rx-storage-helper';\nimport { getDefaultRevision, createRevision, now } from '../plugins/utils';\nexport function getRxReplicationMetaInstanceSchema(replicatedDocumentsSchema, encrypted) {\n  var parentPrimaryKeyLength = getLengthOfPrimaryKey(replicatedDocumentsSchema);\n  var baseSchema = {\n    primaryKey: {\n      key: 'id',\n      fields: ['itemId', 'isCheckpoint'],\n      separator: '|'\n    },\n    type: 'object',\n    version: 0,\n    additionalProperties: false,\n    properties: {\n      id: {\n        type: 'string',\n        minLength: 1,\n        // add +1 for the '|' and +1 for the 'isCheckpoint' flag\n        maxLength: parentPrimaryKeyLength + 2\n      },\n      isCheckpoint: {\n        type: 'string',\n        enum: ['0', '1'],\n        minLength: 1,\n        maxLength: 1\n      },\n      itemId: {\n        type: 'string',\n        maxLength: parentPrimaryKeyLength\n      },\n      data: {\n        type: 'object',\n        additionalProperties: true\n      },\n      isResolvedConflict: {\n        type: 'string'\n      }\n    },\n    required: ['id', 'isCheckpoint', 'itemId', 'data']\n  };\n  if (encrypted) {\n    baseSchema.encrypted = ['data'];\n  }\n  var metaInstanceSchema = fillWithDefaultSettings(baseSchema);\n  return metaInstanceSchema;\n}\n\n/**\n * Returns the document states of what the fork instance\n * assumes to be the latest state on the master instance.\n */\nexport function getAssumedMasterState(state, docIds) {\n  return state.input.metaInstance.findDocumentsById(docIds.map(docId => {\n    var useId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {\n      itemId: docId,\n      isCheckpoint: '0'\n    });\n    return useId;\n  }), true).then(metaDocs => {\n    var ret = {};\n    Object.values(metaDocs).forEach(metaDoc => {\n      ret[metaDoc.itemId] = {\n        docData: metaDoc.data,\n        metaDocument: metaDoc\n      };\n    });\n    return ret;\n  });\n}\nexport function getMetaWriteRow(state, newMasterDocState, previous, isResolvedConflict) {\n  var docId = newMasterDocState[state.primaryPath];\n  var newMeta = previous ? flatCloneDocWithMeta(previous) : {\n    id: '',\n    isCheckpoint: '0',\n    itemId: docId,\n    data: newMasterDocState,\n    _attachments: {},\n    _deleted: false,\n    _rev: getDefaultRevision(),\n    _meta: {\n      lwt: 0\n    }\n  };\n  newMeta.data = newMasterDocState;\n  newMeta.isResolvedConflict = isResolvedConflict;\n  newMeta._meta.lwt = now();\n  newMeta.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newMeta);\n  newMeta._rev = createRevision(state.input.identifier, previous);\n  return {\n    previous,\n    document: newMeta\n  };\n}\n"],"mappings":"AAAA,SAASA,uBAAuB,EAAEC,mCAAmC,EAAEC,qBAAqB,QAAQ,qBAAqB;AACzH,SAASC,oBAAoB,QAAQ,sBAAsB;AAC3D,SAASC,kBAAkB,EAAEC,cAAc,EAAEC,GAAG,QAAQ,kBAAkB;AAC1E,OAAO,SAASC,kCAAkCA,CAACC,yBAAyB,EAAEC,SAAS,EAAE;EACvF,IAAIC,sBAAsB,GAAGR,qBAAqB,CAACM,yBAAyB,CAAC;EAC7E,IAAIG,UAAU,GAAG;IACfC,UAAU,EAAE;MACVC,GAAG,EAAE,IAAI;MACTC,MAAM,EAAE,CAAC,QAAQ,EAAE,cAAc,CAAC;MAClCC,SAAS,EAAE;IACb,CAAC;IACDC,IAAI,EAAE,QAAQ;IACdC,OAAO,EAAE,CAAC;IACVC,oBAAoB,EAAE,KAAK;IAC3BC,UAAU,EAAE;MACVC,EAAE,EAAE;QACFJ,IAAI,EAAE,QAAQ;QACdK,SAAS,EAAE,CAAC;QACZ;QACAC,SAAS,EAAEZ,sBAAsB,GAAG;MACtC,CAAC;MACDa,YAAY,EAAE;QACZP,IAAI,EAAE,QAAQ;QACdQ,IAAI,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC;QAChBH,SAAS,EAAE,CAAC;QACZC,SAAS,EAAE;MACb,CAAC;MACDG,MAAM,EAAE;QACNT,IAAI,EAAE,QAAQ;QACdM,SAAS,EAAEZ;MACb,CAAC;MACDgB,IAAI,EAAE;QACJV,IAAI,EAAE,QAAQ;QACdE,oBAAoB,EAAE;MACxB,CAAC;MACDS,kBAAkB,EAAE;QAClBX,IAAI,EAAE;MACR;IACF,CAAC;IACDY,QAAQ,EAAE,CAAC,IAAI,EAAE,cAAc,EAAE,QAAQ,EAAE,MAAM;EACnD,CAAC;EACD,IAAInB,SAAS,EAAE;IACbE,UAAU,CAACF,SAAS,GAAG,CAAC,MAAM,CAAC;EACjC;EACA,IAAIoB,kBAAkB,GAAG7B,uBAAuB,CAACW,UAAU,CAAC;EAC5D,OAAOkB,kBAAkB;AAC3B;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASC,qBAAqBA,CAACC,KAAK,EAAEC,MAAM,EAAE;EACnD,OAAOD,KAAK,CAACE,KAAK,CAACC,YAAY,CAACC,iBAAiB,CAACH,MAAM,CAACI,GAAG,CAACC,KAAK,IAAI;IACpE,IAAIC,KAAK,GAAGrC,mCAAmC,CAAC8B,KAAK,CAACE,KAAK,CAACC,YAAY,CAACK,MAAM,EAAE;MAC/Ed,MAAM,EAAEY,KAAK;MACbd,YAAY,EAAE;IAChB,CAAC,CAAC;IACF,OAAOe,KAAK;EACd,CAAC,CAAC,EAAE,IAAI,CAAC,CAACE,IAAI,CAACC,QAAQ,IAAI;IACzB,IAAIC,GAAG,GAAG,CAAC,CAAC;IACZC,MAAM,CAACC,MAAM,CAACH,QAAQ,CAAC,CAACI,OAAO,CAACC,OAAO,IAAI;MACzCJ,GAAG,CAACI,OAAO,CAACrB,MAAM,CAAC,GAAG;QACpBsB,OAAO,EAAED,OAAO,CAACpB,IAAI;QACrBsB,YAAY,EAAEF;MAChB,CAAC;IACH,CAAC,CAAC;IACF,OAAOJ,GAAG;EACZ,CAAC,CAAC;AACJ;AACA,OAAO,SAASO,eAAeA,CAAClB,KAAK,EAAEmB,iBAAiB,EAAEC,QAAQ,EAAExB,kBAAkB,EAAE;EACtF,IAAIU,KAAK,GAAGa,iBAAiB,CAACnB,KAAK,CAACqB,WAAW,CAAC;EAChD,IAAIC,OAAO,GAAGF,QAAQ,GAAGhD,oBAAoB,CAACgD,QAAQ,CAAC,GAAG;IACxD/B,EAAE,EAAE,EAAE;IACNG,YAAY,EAAE,GAAG;IACjBE,MAAM,EAAEY,KAAK;IACbX,IAAI,EAAEwB,iBAAiB;IACvBI,YAAY,EAAE,CAAC,CAAC;IAChBC,QAAQ,EAAE,KAAK;IACfC,IAAI,EAAEpD,kBAAkB,CAAC,CAAC;IAC1BqD,KAAK,EAAE;MACLC,GAAG,EAAE;IACP;EACF,CAAC;EACDL,OAAO,CAAC3B,IAAI,GAAGwB,iBAAiB;EAChCG,OAAO,CAAC1B,kBAAkB,GAAGA,kBAAkB;EAC/C0B,OAAO,CAACI,KAAK,CAACC,GAAG,GAAGpD,GAAG,CAAC,CAAC;EACzB+C,OAAO,CAACjC,EAAE,GAAGnB,mCAAmC,CAAC8B,KAAK,CAACE,KAAK,CAACC,YAAY,CAACK,MAAM,EAAEc,OAAO,CAAC;EAC1FA,OAAO,CAACG,IAAI,GAAGnD,cAAc,CAAC0B,KAAK,CAACE,KAAK,CAAC0B,UAAU,EAAER,QAAQ,CAAC;EAC/D,OAAO;IACLA,QAAQ;IACRS,QAAQ,EAAEP;EACZ,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}