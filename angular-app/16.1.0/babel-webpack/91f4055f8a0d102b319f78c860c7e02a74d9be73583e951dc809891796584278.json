{"ast":null,"code":"import { getCharOfLevel, getCharOfValue, getNextCharId } from './string-format';\nimport { FIRST_CHAR_CODE_FOR_ID } from './string-format';\nexport function bddToMinimalString(bdd) {\n  let ret = '';\n  let currentCharCode = FIRST_CHAR_CODE_FOR_ID;\n  // add leaf node count\n  const leafNodeAmount = bdd.getLeafNodes().length;\n  if (leafNodeAmount > 99) {\n    throw new Error('cannot build string with too many leaf nodes');\n  }\n  ret += leafNodeAmount.toString().padStart(2, '0');\n  const levelsHighestFirst = bdd.levels.slice().reverse();\n  const idByNode = new Map();\n  levelsHighestFirst.forEach(level => {\n    const nodes = bdd.getNodesOfLevel(level);\n    nodes.forEach(node => {\n      const stringRep = nodeToString(node, idByNode, currentCharCode);\n      currentCharCode = stringRep.nextCode;\n      idByNode.set(node, stringRep.id);\n      ret += stringRep.str;\n    });\n  });\n  return ret;\n}\nexport function nodeToString(node, idByNode, lastCode) {\n  const nextId = getNextCharId(lastCode);\n  switch (node.type) {\n    case 'LeafNode':\n      const valueChar = getCharOfValue(node.asLeafNode().value);\n      return {\n        id: nextId.char,\n        nextCode: nextId.nextCode,\n        str: nextId.char + valueChar\n      };\n    case 'InternalNode':\n      const branch0Id = idByNode.get(node.asInternalNode().branches.getBranch('0'));\n      const branch1Id = idByNode.get(node.asInternalNode().branches.getBranch('1'));\n      return {\n        id: nextId.char,\n        nextCode: nextId.nextCode,\n        str: nextId.char + branch0Id + branch1Id + getCharOfLevel(node.level)\n      };\n    case 'RootNode':\n      const branch0IdRoot = idByNode.get(node.asRootNode().branches.getBranch('0'));\n      const branch1IdRoot = idByNode.get(node.asRootNode().branches.getBranch('1'));\n      return {\n        id: nextId.char,\n        nextCode: nextId.nextCode,\n        str: '' + branch0IdRoot + branch1IdRoot + getCharOfLevel(node.level)\n      };\n    default:\n      throw new Error('unknown node type');\n  }\n}","map":{"version":3,"names":["getCharOfLevel","getCharOfValue","getNextCharId","FIRST_CHAR_CODE_FOR_ID","bddToMinimalString","bdd","ret","currentCharCode","leafNodeAmount","getLeafNodes","length","Error","toString","padStart","levelsHighestFirst","levels","slice","reverse","idByNode","Map","forEach","level","nodes","getNodesOfLevel","node","stringRep","nodeToString","nextCode","set","id","str","lastCode","nextId","type","valueChar","asLeafNode","value","char","branch0Id","get","asInternalNode","branches","getBranch","branch1Id","branch0IdRoot","asRootNode","branch1IdRoot"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/binary-decision-diagram/dist/es/minimal-string/bdd-to-minimal-string.js"],"sourcesContent":["import { getCharOfLevel, getCharOfValue, getNextCharId } from './string-format';\nimport { FIRST_CHAR_CODE_FOR_ID } from './string-format';\nexport function bddToMinimalString(bdd) {\n    let ret = '';\n    let currentCharCode = FIRST_CHAR_CODE_FOR_ID;\n    // add leaf node count\n    const leafNodeAmount = bdd.getLeafNodes().length;\n    if (leafNodeAmount > 99) {\n        throw new Error('cannot build string with too many leaf nodes');\n    }\n    ret += leafNodeAmount.toString().padStart(2, '0');\n    const levelsHighestFirst = bdd.levels.slice().reverse();\n    const idByNode = new Map();\n    levelsHighestFirst.forEach(level => {\n        const nodes = bdd.getNodesOfLevel(level);\n        nodes.forEach(node => {\n            const stringRep = nodeToString(node, idByNode, currentCharCode);\n            currentCharCode = stringRep.nextCode;\n            idByNode.set(node, stringRep.id);\n            ret += stringRep.str;\n        });\n    });\n    return ret;\n}\nexport function nodeToString(node, idByNode, lastCode) {\n    const nextId = getNextCharId(lastCode);\n    switch (node.type) {\n        case 'LeafNode':\n            const valueChar = getCharOfValue(node.asLeafNode().value);\n            return {\n                id: nextId.char,\n                nextCode: nextId.nextCode,\n                str: nextId.char + valueChar\n            };\n        case 'InternalNode':\n            const branch0Id = idByNode.get(node.asInternalNode().branches.getBranch('0'));\n            const branch1Id = idByNode.get(node.asInternalNode().branches.getBranch('1'));\n            return {\n                id: nextId.char,\n                nextCode: nextId.nextCode,\n                str: nextId.char + branch0Id + branch1Id + getCharOfLevel(node.level)\n            };\n        case 'RootNode':\n            const branch0IdRoot = idByNode.get(node.asRootNode().branches.getBranch('0'));\n            const branch1IdRoot = idByNode.get(node.asRootNode().branches.getBranch('1'));\n            return {\n                id: nextId.char,\n                nextCode: nextId.nextCode,\n                str: '' + branch0IdRoot + branch1IdRoot + getCharOfLevel(node.level)\n            };\n        default:\n            throw new Error('unknown node type');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}