{"ast":null,"code":"import { countUntilNotMatching } from './plugins/utils';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nexport var INDEX_MAX = String.fromCharCode(65535);\n\n/**\n * Do not use -Infinity here because it would be\n * transformed to null on JSON.stringify() which can break things\n * when the query plan is send to the storage as json.\n * @link https://stackoverflow.com/a/16644751\n * Notice that for IndexedDB IDBKeyRange we have\n * to transform the value back to -Infinity\n * before we can use it in IDBKeyRange.bound.\n *\n */\nexport var INDEX_MIN = Number.MIN_VALUE;\n\n/**\n * Returns the query plan which contains\n * information about how to run the query\n * and which indexes to use.\n *\n * This is used in some storage like Memory, dexie.js and IndexedDB.\n */\nexport function getQueryPlan(schema, query) {\n  var primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n  var selector = query.selector;\n  var indexes = schema.indexes ? schema.indexes.slice(0) : [];\n  if (query.index) {\n    indexes = [query.index];\n  } else {\n    indexes.push([primaryPath]);\n  }\n  var optimalSortIndex = query.sort.map(sortField => Object.keys(sortField)[0]);\n  var optimalSortIndexCompareString = optimalSortIndex.join(',');\n  /**\n   * Most storages do not support descending indexes\n   * so having a 'desc' in the sorting, means we always have to re-sort the results.\n   */\n  var hasDescSorting = !!query.sort.find(sortField => Object.values(sortField)[0] === 'desc');\n  var currentBestQuality = -1;\n  var currentBestQueryPlan;\n  indexes.forEach(index => {\n    var inclusiveEnd = true;\n    var inclusiveStart = true;\n    var opts = index.map(indexField => {\n      var matcher = selector[indexField];\n      var operators = matcher ? Object.keys(matcher) : [];\n      var matcherOpts = {};\n      if (!matcher || !operators.length) {\n        var startKey = inclusiveStart ? INDEX_MIN : INDEX_MAX;\n        matcherOpts = {\n          startKey,\n          endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,\n          inclusiveStart: true,\n          inclusiveEnd: true\n        };\n      } else {\n        operators.forEach(operator => {\n          if (LOGICAL_OPERATORS.has(operator)) {\n            var operatorValue = matcher[operator];\n            var partialOpts = getMatcherQueryOpts(operator, operatorValue);\n            matcherOpts = Object.assign(matcherOpts, partialOpts);\n          }\n        });\n      }\n\n      // fill missing attributes\n      if (typeof matcherOpts.startKey === 'undefined') {\n        matcherOpts.startKey = INDEX_MIN;\n      }\n      if (typeof matcherOpts.endKey === 'undefined') {\n        matcherOpts.endKey = INDEX_MAX;\n      }\n      if (typeof matcherOpts.inclusiveStart === 'undefined') {\n        matcherOpts.inclusiveStart = true;\n      }\n      if (typeof matcherOpts.inclusiveEnd === 'undefined') {\n        matcherOpts.inclusiveEnd = true;\n      }\n      if (inclusiveStart && !matcherOpts.inclusiveStart) {\n        inclusiveStart = false;\n      }\n      if (inclusiveEnd && !matcherOpts.inclusiveEnd) {\n        inclusiveEnd = false;\n      }\n      return matcherOpts;\n    });\n    var queryPlan = {\n      index,\n      startKeys: opts.map(opt => opt.startKey),\n      endKeys: opts.map(opt => opt.endKey),\n      inclusiveEnd,\n      inclusiveStart,\n      sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === index.join(','),\n      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query.selector)\n    };\n    var quality = rateQueryPlan(schema, query, queryPlan);\n    if (quality > 0 && quality > currentBestQuality || query.index) {\n      currentBestQuality = quality;\n      currentBestQueryPlan = queryPlan;\n    }\n  });\n\n  /**\n   * No index found, use the default index\n   */\n  if (!currentBestQueryPlan) {\n    currentBestQueryPlan = {\n      index: [primaryPath],\n      startKeys: [INDEX_MIN],\n      endKeys: [INDEX_MAX],\n      inclusiveEnd: true,\n      inclusiveStart: true,\n      sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === primaryPath,\n      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex([primaryPath], query.selector)\n    };\n  }\n  return currentBestQueryPlan;\n}\nexport var LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte', '$lt', '$lte']);\nexport var LOWER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte']);\nexport var UPPER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$lt', '$lte']);\nexport function isSelectorSatisfiedByIndex(index, selector) {\n  var selectorEntries = Object.entries(selector);\n  var hasNonMatchingOperator = selectorEntries.find(([fieldName, operation]) => {\n    if (!index.includes(fieldName)) {\n      return true;\n    }\n    var hasNonLogicOperator = Object.entries(operation).find(([op, _value]) => !LOGICAL_OPERATORS.has(op));\n    return hasNonLogicOperator;\n  });\n  if (hasNonMatchingOperator) {\n    return false;\n  }\n  var prevLowerBoundaryField;\n  var hasMoreThenOneLowerBoundaryField = index.find(fieldName => {\n    var operation = selector[fieldName];\n    if (!operation) {\n      return false;\n    }\n    var hasLowerLogicOp = Object.keys(operation).find(key => LOWER_BOUND_LOGICAL_OPERATORS.has(key));\n    if (prevLowerBoundaryField && hasLowerLogicOp) {\n      return true;\n    } else if (hasLowerLogicOp !== '$eq') {\n      prevLowerBoundaryField = hasLowerLogicOp;\n    }\n    return false;\n  });\n  if (hasMoreThenOneLowerBoundaryField) {\n    return false;\n  }\n  var prevUpperBoundaryField;\n  var hasMoreThenOneUpperBoundaryField = index.find(fieldName => {\n    var operation = selector[fieldName];\n    if (!operation) {\n      return false;\n    }\n    var hasUpperLogicOp = Object.keys(operation).find(key => UPPER_BOUND_LOGICAL_OPERATORS.has(key));\n    if (prevUpperBoundaryField && hasUpperLogicOp) {\n      return true;\n    } else if (hasUpperLogicOp !== '$eq') {\n      prevUpperBoundaryField = hasUpperLogicOp;\n    }\n    return false;\n  });\n  if (hasMoreThenOneUpperBoundaryField) {\n    return false;\n  }\n  return true;\n}\nexport function getMatcherQueryOpts(operator, operatorValue) {\n  switch (operator) {\n    case '$eq':\n      return {\n        startKey: operatorValue,\n        endKey: operatorValue\n      };\n    case '$lte':\n      return {\n        endKey: operatorValue\n      };\n    case '$gte':\n      return {\n        startKey: operatorValue\n      };\n    case '$lt':\n      return {\n        endKey: operatorValue,\n        inclusiveEnd: false\n      };\n    case '$gt':\n      return {\n        startKey: operatorValue,\n        inclusiveStart: false\n      };\n    default:\n      throw new Error('SNH');\n  }\n}\n\n/**\n * Returns a number that determines the quality of the query plan.\n * Higher number means better query plan.\n */\nexport function rateQueryPlan(schema, query, queryPlan) {\n  var quality = 0;\n  var addQuality = value => {\n    if (value > 0) {\n      quality = quality + value;\n    }\n  };\n  var pointsPerMatchingKey = 10;\n  var nonMinKeyCount = countUntilNotMatching(queryPlan.startKeys, keyValue => keyValue !== INDEX_MIN && keyValue !== INDEX_MAX);\n  addQuality(nonMinKeyCount * pointsPerMatchingKey);\n  var nonMaxKeyCount = countUntilNotMatching(queryPlan.startKeys, keyValue => keyValue !== INDEX_MAX && keyValue !== INDEX_MIN);\n  addQuality(nonMaxKeyCount * pointsPerMatchingKey);\n  var equalKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue, idx) => {\n    if (keyValue === queryPlan.endKeys[idx]) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n  addQuality(equalKeyCount * pointsPerMatchingKey * 1.5);\n  var pointsIfNoReSortMustBeDone = queryPlan.sortFieldsSameAsIndexFields ? 5 : 0;\n  addQuality(pointsIfNoReSortMustBeDone);\n\n  // console.log('rateQueryPlan() result:');\n  // console.log({\n  //     query,\n  //     queryPlan,\n  //     nonMinKeyCount,\n  //     nonMaxKeyCount,\n  //     equalKeyCount,\n  //     pointsIfNoReSortMustBeDone,\n  //     quality\n  // });\n\n  return quality;\n}","map":{"version":3,"names":["countUntilNotMatching","getPrimaryFieldOfPrimaryKey","INDEX_MAX","String","fromCharCode","INDEX_MIN","Number","MIN_VALUE","getQueryPlan","schema","query","primaryPath","primaryKey","selector","indexes","slice","index","push","optimalSortIndex","sort","map","sortField","Object","keys","optimalSortIndexCompareString","join","hasDescSorting","find","values","currentBestQuality","currentBestQueryPlan","forEach","inclusiveEnd","inclusiveStart","opts","indexField","matcher","operators","matcherOpts","length","startKey","endKey","operator","LOGICAL_OPERATORS","has","operatorValue","partialOpts","getMatcherQueryOpts","assign","queryPlan","startKeys","opt","endKeys","sortFieldsSameAsIndexFields","selectorSatisfiedByIndex","isSelectorSatisfiedByIndex","quality","rateQueryPlan","Set","LOWER_BOUND_LOGICAL_OPERATORS","UPPER_BOUND_LOGICAL_OPERATORS","selectorEntries","entries","hasNonMatchingOperator","fieldName","operation","includes","hasNonLogicOperator","op","_value","prevLowerBoundaryField","hasMoreThenOneLowerBoundaryField","hasLowerLogicOp","key","prevUpperBoundaryField","hasMoreThenOneUpperBoundaryField","hasUpperLogicOp","Error","addQuality","value","pointsPerMatchingKey","nonMinKeyCount","keyValue","nonMaxKeyCount","equalKeyCount","idx","pointsIfNoReSortMustBeDone"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/query-planner.js"],"sourcesContent":["import { countUntilNotMatching } from './plugins/utils';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nexport var INDEX_MAX = String.fromCharCode(65535);\n\n/**\n * Do not use -Infinity here because it would be\n * transformed to null on JSON.stringify() which can break things\n * when the query plan is send to the storage as json.\n * @link https://stackoverflow.com/a/16644751\n * Notice that for IndexedDB IDBKeyRange we have\n * to transform the value back to -Infinity\n * before we can use it in IDBKeyRange.bound.\n *\n */\nexport var INDEX_MIN = Number.MIN_VALUE;\n\n/**\n * Returns the query plan which contains\n * information about how to run the query\n * and which indexes to use.\n *\n * This is used in some storage like Memory, dexie.js and IndexedDB.\n */\nexport function getQueryPlan(schema, query) {\n  var primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n  var selector = query.selector;\n  var indexes = schema.indexes ? schema.indexes.slice(0) : [];\n  if (query.index) {\n    indexes = [query.index];\n  } else {\n    indexes.push([primaryPath]);\n  }\n  var optimalSortIndex = query.sort.map(sortField => Object.keys(sortField)[0]);\n  var optimalSortIndexCompareString = optimalSortIndex.join(',');\n  /**\n   * Most storages do not support descending indexes\n   * so having a 'desc' in the sorting, means we always have to re-sort the results.\n   */\n  var hasDescSorting = !!query.sort.find(sortField => Object.values(sortField)[0] === 'desc');\n  var currentBestQuality = -1;\n  var currentBestQueryPlan;\n  indexes.forEach(index => {\n    var inclusiveEnd = true;\n    var inclusiveStart = true;\n    var opts = index.map(indexField => {\n      var matcher = selector[indexField];\n      var operators = matcher ? Object.keys(matcher) : [];\n      var matcherOpts = {};\n      if (!matcher || !operators.length) {\n        var startKey = inclusiveStart ? INDEX_MIN : INDEX_MAX;\n        matcherOpts = {\n          startKey,\n          endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,\n          inclusiveStart: true,\n          inclusiveEnd: true\n        };\n      } else {\n        operators.forEach(operator => {\n          if (LOGICAL_OPERATORS.has(operator)) {\n            var operatorValue = matcher[operator];\n            var partialOpts = getMatcherQueryOpts(operator, operatorValue);\n            matcherOpts = Object.assign(matcherOpts, partialOpts);\n          }\n        });\n      }\n\n      // fill missing attributes\n      if (typeof matcherOpts.startKey === 'undefined') {\n        matcherOpts.startKey = INDEX_MIN;\n      }\n      if (typeof matcherOpts.endKey === 'undefined') {\n        matcherOpts.endKey = INDEX_MAX;\n      }\n      if (typeof matcherOpts.inclusiveStart === 'undefined') {\n        matcherOpts.inclusiveStart = true;\n      }\n      if (typeof matcherOpts.inclusiveEnd === 'undefined') {\n        matcherOpts.inclusiveEnd = true;\n      }\n      if (inclusiveStart && !matcherOpts.inclusiveStart) {\n        inclusiveStart = false;\n      }\n      if (inclusiveEnd && !matcherOpts.inclusiveEnd) {\n        inclusiveEnd = false;\n      }\n      return matcherOpts;\n    });\n    var queryPlan = {\n      index,\n      startKeys: opts.map(opt => opt.startKey),\n      endKeys: opts.map(opt => opt.endKey),\n      inclusiveEnd,\n      inclusiveStart,\n      sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === index.join(','),\n      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query.selector)\n    };\n    var quality = rateQueryPlan(schema, query, queryPlan);\n    if (quality > 0 && quality > currentBestQuality || query.index) {\n      currentBestQuality = quality;\n      currentBestQueryPlan = queryPlan;\n    }\n  });\n\n  /**\n   * No index found, use the default index\n   */\n  if (!currentBestQueryPlan) {\n    currentBestQueryPlan = {\n      index: [primaryPath],\n      startKeys: [INDEX_MIN],\n      endKeys: [INDEX_MAX],\n      inclusiveEnd: true,\n      inclusiveStart: true,\n      sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === primaryPath,\n      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex([primaryPath], query.selector)\n    };\n  }\n  return currentBestQueryPlan;\n}\nexport var LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte', '$lt', '$lte']);\nexport var LOWER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte']);\nexport var UPPER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$lt', '$lte']);\nexport function isSelectorSatisfiedByIndex(index, selector) {\n  var selectorEntries = Object.entries(selector);\n  var hasNonMatchingOperator = selectorEntries.find(([fieldName, operation]) => {\n    if (!index.includes(fieldName)) {\n      return true;\n    }\n    var hasNonLogicOperator = Object.entries(operation).find(([op, _value]) => !LOGICAL_OPERATORS.has(op));\n    return hasNonLogicOperator;\n  });\n  if (hasNonMatchingOperator) {\n    return false;\n  }\n  var prevLowerBoundaryField;\n  var hasMoreThenOneLowerBoundaryField = index.find(fieldName => {\n    var operation = selector[fieldName];\n    if (!operation) {\n      return false;\n    }\n    var hasLowerLogicOp = Object.keys(operation).find(key => LOWER_BOUND_LOGICAL_OPERATORS.has(key));\n    if (prevLowerBoundaryField && hasLowerLogicOp) {\n      return true;\n    } else if (hasLowerLogicOp !== '$eq') {\n      prevLowerBoundaryField = hasLowerLogicOp;\n    }\n    return false;\n  });\n  if (hasMoreThenOneLowerBoundaryField) {\n    return false;\n  }\n  var prevUpperBoundaryField;\n  var hasMoreThenOneUpperBoundaryField = index.find(fieldName => {\n    var operation = selector[fieldName];\n    if (!operation) {\n      return false;\n    }\n    var hasUpperLogicOp = Object.keys(operation).find(key => UPPER_BOUND_LOGICAL_OPERATORS.has(key));\n    if (prevUpperBoundaryField && hasUpperLogicOp) {\n      return true;\n    } else if (hasUpperLogicOp !== '$eq') {\n      prevUpperBoundaryField = hasUpperLogicOp;\n    }\n    return false;\n  });\n  if (hasMoreThenOneUpperBoundaryField) {\n    return false;\n  }\n  return true;\n}\nexport function getMatcherQueryOpts(operator, operatorValue) {\n  switch (operator) {\n    case '$eq':\n      return {\n        startKey: operatorValue,\n        endKey: operatorValue\n      };\n    case '$lte':\n      return {\n        endKey: operatorValue\n      };\n    case '$gte':\n      return {\n        startKey: operatorValue\n      };\n    case '$lt':\n      return {\n        endKey: operatorValue,\n        inclusiveEnd: false\n      };\n    case '$gt':\n      return {\n        startKey: operatorValue,\n        inclusiveStart: false\n      };\n    default:\n      throw new Error('SNH');\n  }\n}\n\n/**\n * Returns a number that determines the quality of the query plan.\n * Higher number means better query plan.\n */\nexport function rateQueryPlan(schema, query, queryPlan) {\n  var quality = 0;\n  var addQuality = value => {\n    if (value > 0) {\n      quality = quality + value;\n    }\n  };\n  var pointsPerMatchingKey = 10;\n  var nonMinKeyCount = countUntilNotMatching(queryPlan.startKeys, keyValue => keyValue !== INDEX_MIN && keyValue !== INDEX_MAX);\n  addQuality(nonMinKeyCount * pointsPerMatchingKey);\n  var nonMaxKeyCount = countUntilNotMatching(queryPlan.startKeys, keyValue => keyValue !== INDEX_MAX && keyValue !== INDEX_MIN);\n  addQuality(nonMaxKeyCount * pointsPerMatchingKey);\n  var equalKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue, idx) => {\n    if (keyValue === queryPlan.endKeys[idx]) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n  addQuality(equalKeyCount * pointsPerMatchingKey * 1.5);\n  var pointsIfNoReSortMustBeDone = queryPlan.sortFieldsSameAsIndexFields ? 5 : 0;\n  addQuality(pointsIfNoReSortMustBeDone);\n\n  // console.log('rateQueryPlan() result:');\n  // console.log({\n  //     query,\n  //     queryPlan,\n  //     nonMinKeyCount,\n  //     nonMaxKeyCount,\n  //     equalKeyCount,\n  //     pointsIfNoReSortMustBeDone,\n  //     quality\n  // });\n\n  return quality;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}