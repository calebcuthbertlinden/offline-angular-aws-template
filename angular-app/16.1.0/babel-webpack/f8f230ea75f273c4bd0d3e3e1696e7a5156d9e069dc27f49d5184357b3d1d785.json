{"ast":null,"code":"/**\n * does additional checks over the schema-json\n * to ensure nothing is broken or not supported\n */\nimport { newRxError } from '../../rx-error';\nimport { getPrimaryFieldOfPrimaryKey, getSchemaByObjectPath } from '../../rx-schema-helper';\nimport { appendToArray, flattenObject, getProperty, isMaybeReadonlyArray, trimDots } from '../../plugins/utils';\nimport { rxDocumentProperties } from './entity-properties';\n\n/**\n * checks if the fieldname is allowed\n * this makes sure that the fieldnames can be transformed into javascript-vars\n * and does not conquer the observe$ and populate_ fields\n * @throws {Error}\n */\nexport function checkFieldNameRegex(fieldName) {\n  if (fieldName === '_deleted') {\n    return;\n  }\n  if (['properties'].includes(fieldName)) {\n    throw newRxError('SC23', {\n      fieldName\n    });\n  }\n  var regexStr = '^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$';\n  var regex = new RegExp(regexStr);\n  if (\n  /**\n   * It must be allowed to set _id as primaryKey.\n   * This makes it sometimes easier to work with RxDB+CouchDB\n   * @link https://github.com/pubkey/rxdb/issues/681\n   */\n  fieldName !== '_id' && !fieldName.match(regex)) {\n    throw newRxError('SC1', {\n      regex: regexStr,\n      fieldName\n    });\n  }\n}\n\n/**\n * validate that all schema-related things are ok\n */\nexport function validateFieldsDeep(rxJsonSchema) {\n  var primaryPath = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);\n  function checkField(fieldName, schemaObj, path) {\n    if (typeof fieldName === 'string' && typeof schemaObj === 'object' && !Array.isArray(schemaObj)) checkFieldNameRegex(fieldName);\n\n    // 'item' only allowed it type=='array'\n    if (schemaObj.hasOwnProperty('item') && schemaObj.type !== 'array') {\n      throw newRxError('SC2', {\n        fieldName\n      });\n    }\n\n    /**\n     * required fields cannot be set via 'required: true',\n     * but must be set via required: []\n     */\n    if (schemaObj.hasOwnProperty('required') && typeof schemaObj.required === 'boolean') {\n      throw newRxError('SC24', {\n        fieldName\n      });\n    }\n\n    // if ref given, must be type=='string', type=='array' with string-items or type==['string','null']\n    if (schemaObj.hasOwnProperty('ref')) {\n      if (Array.isArray(schemaObj.type)) {\n        if (schemaObj.type.length > 2 || !schemaObj.type.includes('string') || !schemaObj.type.includes('null')) {\n          throw newRxError('SC4', {\n            fieldName\n          });\n        }\n      } else {\n        switch (schemaObj.type) {\n          case 'string':\n            break;\n          case 'array':\n            if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== 'string') {\n              throw newRxError('SC3', {\n                fieldName\n              });\n            }\n            break;\n          default:\n            throw newRxError('SC4', {\n              fieldName\n            });\n        }\n      }\n    }\n    var isNested = path.split('.').length >= 2;\n\n    // nested only\n    if (isNested) {\n      if (schemaObj.primary) {\n        throw newRxError('SC6', {\n          path,\n          primary: schemaObj.primary\n        });\n      }\n      if (schemaObj.default) {\n        throw newRxError('SC7', {\n          path\n        });\n      }\n    }\n\n    // first level\n    if (!isNested) {\n      // if _id is used, it must be primaryKey\n      if (fieldName === '_id' && primaryPath !== '_id') {\n        throw newRxError('COL2', {\n          fieldName\n        });\n      }\n\n      // check underscore fields\n      if (fieldName.charAt(0) === '_') {\n        if (\n        // exceptional allow underscore on these fields.\n        fieldName === '_id' || fieldName === '_deleted') {\n          return;\n        }\n        throw newRxError('SC8', {\n          fieldName\n        });\n      }\n    }\n  }\n  function traverse(currentObj, currentPath) {\n    if (!currentObj || typeof currentObj !== 'object') {\n      return;\n    }\n    Object.keys(currentObj).forEach(attributeName => {\n      var schemaObj = currentObj[attributeName];\n      if (!currentObj.properties && schemaObj && typeof schemaObj === 'object' && !Array.isArray(currentObj)) {\n        checkField(attributeName, schemaObj, currentPath);\n      }\n      var nextPath = currentPath;\n      if (attributeName !== 'properties') nextPath = nextPath + '.' + attributeName;\n      traverse(schemaObj, nextPath);\n    });\n  }\n  traverse(rxJsonSchema, '');\n  return true;\n}\nexport function checkPrimaryKey(jsonSchema) {\n  if (!jsonSchema.primaryKey) {\n    throw newRxError('SC30', {\n      schema: jsonSchema\n    });\n  }\n  function validatePrimarySchemaPart(schemaPart) {\n    if (!schemaPart) {\n      throw newRxError('SC33', {\n        schema: jsonSchema\n      });\n    }\n    var type = schemaPart.type;\n    if (!type || !['string', 'number', 'integer'].includes(type)) {\n      throw newRxError('SC32', {\n        schema: jsonSchema,\n        args: {\n          schemaPart\n        }\n      });\n    }\n  }\n  if (typeof jsonSchema.primaryKey === 'string') {\n    var key = jsonSchema.primaryKey;\n    var schemaPart = jsonSchema.properties[key];\n    validatePrimarySchemaPart(schemaPart);\n  } else {\n    var compositePrimaryKey = jsonSchema.primaryKey;\n    var keySchemaPart = getSchemaByObjectPath(jsonSchema, compositePrimaryKey.key);\n    validatePrimarySchemaPart(keySchemaPart);\n    compositePrimaryKey.fields.forEach(field => {\n      var schemaPart = getSchemaByObjectPath(jsonSchema, field);\n      validatePrimarySchemaPart(schemaPart);\n    });\n  }\n\n  /**\n   * The primary key must have a maxLength set\n   * which is required by some RxStorage implementations\n   * to ensure we can craft custom index strings.\n   */\n  var primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);\n  var primaryPathSchemaPart = jsonSchema.properties[primaryPath];\n  if (!primaryPathSchemaPart.maxLength) {\n    throw newRxError('SC39', {\n      schema: jsonSchema,\n      args: {\n        primaryPathSchemaPart\n      }\n    });\n  }\n}\n\n/**\n * computes real path of the object path in the collection schema\n */\nfunction getSchemaPropertyRealPath(shortPath) {\n  var pathParts = shortPath.split('.');\n  var realPath = '';\n  for (var i = 0; i < pathParts.length; i += 1) {\n    if (pathParts[i] !== '[]') {\n      realPath = realPath.concat('.properties.'.concat(pathParts[i]));\n    } else {\n      realPath = realPath.concat('.items');\n    }\n  }\n  return trimDots(realPath);\n}\n\n/**\n * does the checking\n * @throws {Error} if something is not ok\n */\nexport function checkSchema(jsonSchema) {\n  if (!jsonSchema.primaryKey) {\n    throw newRxError('SC30', {\n      schema: jsonSchema\n    });\n  }\n  if (!jsonSchema.hasOwnProperty('properties')) {\n    throw newRxError('SC29', {\n      schema: jsonSchema\n    });\n  }\n\n  // _rev MUST NOT exist, it is added by RxDB\n  if (jsonSchema.properties._rev) {\n    throw newRxError('SC10', {\n      schema: jsonSchema\n    });\n  }\n\n  // check version\n  if (!jsonSchema.hasOwnProperty('version') || typeof jsonSchema.version !== 'number' || jsonSchema.version < 0) {\n    throw newRxError('SC11', {\n      version: jsonSchema.version\n    });\n  }\n  validateFieldsDeep(jsonSchema);\n  checkPrimaryKey(jsonSchema);\n  Object.keys(jsonSchema.properties).forEach(key => {\n    var value = jsonSchema.properties[key];\n    // check primary\n    if (key === jsonSchema.primaryKey) {\n      if (jsonSchema.indexes && jsonSchema.indexes.includes(key)) {\n        throw newRxError('SC13', {\n          value,\n          schema: jsonSchema\n        });\n      }\n      if (value.unique) {\n        throw newRxError('SC14', {\n          value,\n          schema: jsonSchema\n        });\n      }\n      if (jsonSchema.encrypted && jsonSchema.encrypted.includes(key)) {\n        throw newRxError('SC15', {\n          value,\n          schema: jsonSchema\n        });\n      }\n      if (value.type !== 'string') {\n        throw newRxError('SC16', {\n          value,\n          schema: jsonSchema\n        });\n      }\n    }\n\n    // check if RxDocument-property\n    if (rxDocumentProperties().includes(key)) {\n      throw newRxError('SC17', {\n        key,\n        schema: jsonSchema\n      });\n    }\n  });\n\n  // check format of jsonSchema.indexes\n  if (jsonSchema.indexes) {\n    // should be an array\n    if (!isMaybeReadonlyArray(jsonSchema.indexes)) {\n      throw newRxError('SC18', {\n        indexes: jsonSchema.indexes,\n        schema: jsonSchema\n      });\n    }\n    jsonSchema.indexes.forEach(index => {\n      // should contain strings or array of strings\n      if (!(typeof index === 'string' || Array.isArray(index))) {\n        throw newRxError('SC19', {\n          index,\n          schema: jsonSchema\n        });\n      }\n      // if is a compound index it must contain strings\n      if (Array.isArray(index)) {\n        for (var i = 0; i < index.length; i += 1) {\n          if (typeof index[i] !== 'string') {\n            throw newRxError('SC20', {\n              index,\n              schema: jsonSchema\n            });\n          }\n        }\n      }\n\n      /**\n       * To be able to craft custom indexable string with compound fields,\n       * we need to know the maximum fieldlength of the fields values\n       * when they are transformed to strings.\n       * Therefore we need to enforce some properties inside of the schema.\n       */\n      var indexAsArray = isMaybeReadonlyArray(index) ? index : [index];\n      indexAsArray.forEach(fieldName => {\n        var schemaPart = getSchemaByObjectPath(jsonSchema, fieldName);\n        var type = schemaPart.type;\n        switch (type) {\n          case 'string':\n            var maxLength = schemaPart.maxLength;\n            if (!maxLength) {\n              throw newRxError('SC34', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            break;\n          case 'number':\n          case 'integer':\n            var multipleOf = schemaPart.multipleOf;\n            if (!multipleOf) {\n              throw newRxError('SC35', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            var maximum = schemaPart.maximum;\n            var minimum = schemaPart.minimum;\n            if (typeof maximum === 'undefined' || typeof minimum === 'undefined') {\n              throw newRxError('SC37', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            break;\n          case 'boolean':\n            /**\n             * If a boolean field is used as an index,\n             * it must be required.\n             */\n            var parentPath = '';\n            var lastPathPart = fieldName;\n            if (fieldName.includes('.')) {\n              var partParts = fieldName.split('.');\n              lastPathPart = partParts.pop();\n              parentPath = partParts.join('.');\n            }\n            var parentSchemaPart = parentPath === '' ? jsonSchema : getSchemaByObjectPath(jsonSchema, parentPath);\n            if (!parentSchemaPart.required || !parentSchemaPart.required.includes(lastPathPart)) {\n              throw newRxError('SC38', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            break;\n          default:\n            throw newRxError('SC36', {\n              fieldName,\n              type: schemaPart.type,\n              schema: jsonSchema\n            });\n        }\n      });\n    });\n  }\n\n  // remove backward-compatibility for index: true\n  Object.keys(flattenObject(jsonSchema)).map(key => {\n    // flattenObject returns only ending paths, we need all paths pointing to an object\n    var split = key.split('.');\n    split.pop(); // all but last\n    return split.join('.');\n  }).filter(key => key !== '').filter((elem, pos, arr) => arr.indexOf(elem) === pos) // unique\n  .filter(key => {\n    // check if this path defines an index\n    var value = getProperty(jsonSchema, key);\n    return value && !!value.index;\n  }).forEach(key => {\n    // replace inner properties\n    key = key.replace('properties.', ''); // first\n    key = key.replace(/\\.properties\\./g, '.'); // middle\n    throw newRxError('SC26', {\n      index: trimDots(key),\n      schema: jsonSchema\n    });\n  });\n\n  /* check types of the indexes */\n  (jsonSchema.indexes || []).reduce((indexPaths, currentIndex) => {\n    if (isMaybeReadonlyArray(currentIndex)) {\n      appendToArray(indexPaths, currentIndex);\n    } else {\n      indexPaths.push(currentIndex);\n    }\n    return indexPaths;\n  }, []).filter((elem, pos, arr) => arr.indexOf(elem) === pos) // from now on working only with unique indexes\n  .map(indexPath => {\n    var realPath = getSchemaPropertyRealPath(indexPath); // real path in the collection schema\n    var schemaObj = getProperty(jsonSchema, realPath); // get the schema of the indexed property\n    if (!schemaObj || typeof schemaObj !== 'object') {\n      throw newRxError('SC21', {\n        index: indexPath,\n        schema: jsonSchema\n      });\n    }\n    return {\n      indexPath,\n      schemaObj\n    };\n  }).filter(index => index.schemaObj.type !== 'string' && index.schemaObj.type !== 'integer' && index.schemaObj.type !== 'number' && index.schemaObj.type !== 'boolean').forEach(index => {\n    throw newRxError('SC22', {\n      key: index.indexPath,\n      type: index.schemaObj.type,\n      schema: jsonSchema\n    });\n  });\n\n  /**\n   * TODO\n   * in 9.0.0 we changed the way encrypted fields are defined\n   * This check ensures people do not oversee the breaking change\n   * Remove this check in the future\n   */\n  Object.keys(flattenObject(jsonSchema)).map(key => {\n    // flattenObject returns only ending paths, we need all paths pointing to an object\n    var split = key.split('.');\n    split.pop(); // all but last\n    return split.join('.');\n  }).filter(key => key !== '' && key !== 'attachments').filter((elem, pos, arr) => arr.indexOf(elem) === pos) // unique\n  .filter(key => {\n    // check if this path defines an encrypted field\n    var value = getProperty(jsonSchema, key);\n    return value && !!value.encrypted;\n  }).forEach(key => {\n    // replace inner properties\n    key = key.replace('properties.', ''); // first\n    key = key.replace(/\\.properties\\./g, '.'); // middle\n    throw newRxError('SC27', {\n      index: trimDots(key),\n      schema: jsonSchema\n    });\n  });\n\n  /* ensure encrypted fields exist in the schema */\n  if (jsonSchema.encrypted) {\n    jsonSchema.encrypted.forEach(propPath => {\n      // real path in the collection schema\n      var realPath = getSchemaPropertyRealPath(propPath);\n      // get the schema of the indexed property\n      var schemaObj = getProperty(jsonSchema, realPath);\n      if (!schemaObj || typeof schemaObj !== 'object') {\n        throw newRxError('SC28', {\n          field: propPath,\n          schema: jsonSchema\n        });\n      }\n    });\n  }\n}","map":{"version":3,"names":["newRxError","getPrimaryFieldOfPrimaryKey","getSchemaByObjectPath","appendToArray","flattenObject","getProperty","isMaybeReadonlyArray","trimDots","rxDocumentProperties","checkFieldNameRegex","fieldName","includes","regexStr","regex","RegExp","match","validateFieldsDeep","rxJsonSchema","primaryPath","primaryKey","checkField","schemaObj","path","Array","isArray","hasOwnProperty","type","required","length","items","isNested","split","primary","default","charAt","traverse","currentObj","currentPath","Object","keys","forEach","attributeName","properties","nextPath","checkPrimaryKey","jsonSchema","schema","validatePrimarySchemaPart","schemaPart","args","key","compositePrimaryKey","keySchemaPart","fields","field","primaryPathSchemaPart","maxLength","getSchemaPropertyRealPath","shortPath","pathParts","realPath","i","concat","checkSchema","_rev","version","value","indexes","unique","encrypted","index","indexAsArray","multipleOf","maximum","minimum","parentPath","lastPathPart","partParts","pop","join","parentSchemaPart","map","filter","elem","pos","arr","indexOf","replace","reduce","indexPaths","currentIndex","push","indexPath","propPath"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/plugins/dev-mode/check-schema.js"],"sourcesContent":["/**\n * does additional checks over the schema-json\n * to ensure nothing is broken or not supported\n */\nimport { newRxError } from '../../rx-error';\nimport { getPrimaryFieldOfPrimaryKey, getSchemaByObjectPath } from '../../rx-schema-helper';\nimport { appendToArray, flattenObject, getProperty, isMaybeReadonlyArray, trimDots } from '../../plugins/utils';\nimport { rxDocumentProperties } from './entity-properties';\n\n/**\n * checks if the fieldname is allowed\n * this makes sure that the fieldnames can be transformed into javascript-vars\n * and does not conquer the observe$ and populate_ fields\n * @throws {Error}\n */\nexport function checkFieldNameRegex(fieldName) {\n  if (fieldName === '_deleted') {\n    return;\n  }\n  if (['properties'].includes(fieldName)) {\n    throw newRxError('SC23', {\n      fieldName\n    });\n  }\n  var regexStr = '^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$';\n  var regex = new RegExp(regexStr);\n  if (\n  /**\n   * It must be allowed to set _id as primaryKey.\n   * This makes it sometimes easier to work with RxDB+CouchDB\n   * @link https://github.com/pubkey/rxdb/issues/681\n   */\n  fieldName !== '_id' && !fieldName.match(regex)) {\n    throw newRxError('SC1', {\n      regex: regexStr,\n      fieldName\n    });\n  }\n}\n\n/**\n * validate that all schema-related things are ok\n */\nexport function validateFieldsDeep(rxJsonSchema) {\n  var primaryPath = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);\n  function checkField(fieldName, schemaObj, path) {\n    if (typeof fieldName === 'string' && typeof schemaObj === 'object' && !Array.isArray(schemaObj)) checkFieldNameRegex(fieldName);\n\n    // 'item' only allowed it type=='array'\n    if (schemaObj.hasOwnProperty('item') && schemaObj.type !== 'array') {\n      throw newRxError('SC2', {\n        fieldName\n      });\n    }\n\n    /**\n     * required fields cannot be set via 'required: true',\n     * but must be set via required: []\n     */\n    if (schemaObj.hasOwnProperty('required') && typeof schemaObj.required === 'boolean') {\n      throw newRxError('SC24', {\n        fieldName\n      });\n    }\n\n    // if ref given, must be type=='string', type=='array' with string-items or type==['string','null']\n    if (schemaObj.hasOwnProperty('ref')) {\n      if (Array.isArray(schemaObj.type)) {\n        if (schemaObj.type.length > 2 || !schemaObj.type.includes('string') || !schemaObj.type.includes('null')) {\n          throw newRxError('SC4', {\n            fieldName\n          });\n        }\n      } else {\n        switch (schemaObj.type) {\n          case 'string':\n            break;\n          case 'array':\n            if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== 'string') {\n              throw newRxError('SC3', {\n                fieldName\n              });\n            }\n            break;\n          default:\n            throw newRxError('SC4', {\n              fieldName\n            });\n        }\n      }\n    }\n    var isNested = path.split('.').length >= 2;\n\n    // nested only\n    if (isNested) {\n      if (schemaObj.primary) {\n        throw newRxError('SC6', {\n          path,\n          primary: schemaObj.primary\n        });\n      }\n      if (schemaObj.default) {\n        throw newRxError('SC7', {\n          path\n        });\n      }\n    }\n\n    // first level\n    if (!isNested) {\n      // if _id is used, it must be primaryKey\n      if (fieldName === '_id' && primaryPath !== '_id') {\n        throw newRxError('COL2', {\n          fieldName\n        });\n      }\n\n      // check underscore fields\n      if (fieldName.charAt(0) === '_') {\n        if (\n        // exceptional allow underscore on these fields.\n        fieldName === '_id' || fieldName === '_deleted') {\n          return;\n        }\n        throw newRxError('SC8', {\n          fieldName\n        });\n      }\n    }\n  }\n  function traverse(currentObj, currentPath) {\n    if (!currentObj || typeof currentObj !== 'object') {\n      return;\n    }\n    Object.keys(currentObj).forEach(attributeName => {\n      var schemaObj = currentObj[attributeName];\n      if (!currentObj.properties && schemaObj && typeof schemaObj === 'object' && !Array.isArray(currentObj)) {\n        checkField(attributeName, schemaObj, currentPath);\n      }\n      var nextPath = currentPath;\n      if (attributeName !== 'properties') nextPath = nextPath + '.' + attributeName;\n      traverse(schemaObj, nextPath);\n    });\n  }\n  traverse(rxJsonSchema, '');\n  return true;\n}\nexport function checkPrimaryKey(jsonSchema) {\n  if (!jsonSchema.primaryKey) {\n    throw newRxError('SC30', {\n      schema: jsonSchema\n    });\n  }\n  function validatePrimarySchemaPart(schemaPart) {\n    if (!schemaPart) {\n      throw newRxError('SC33', {\n        schema: jsonSchema\n      });\n    }\n    var type = schemaPart.type;\n    if (!type || !['string', 'number', 'integer'].includes(type)) {\n      throw newRxError('SC32', {\n        schema: jsonSchema,\n        args: {\n          schemaPart\n        }\n      });\n    }\n  }\n  if (typeof jsonSchema.primaryKey === 'string') {\n    var key = jsonSchema.primaryKey;\n    var schemaPart = jsonSchema.properties[key];\n    validatePrimarySchemaPart(schemaPart);\n  } else {\n    var compositePrimaryKey = jsonSchema.primaryKey;\n    var keySchemaPart = getSchemaByObjectPath(jsonSchema, compositePrimaryKey.key);\n    validatePrimarySchemaPart(keySchemaPart);\n    compositePrimaryKey.fields.forEach(field => {\n      var schemaPart = getSchemaByObjectPath(jsonSchema, field);\n      validatePrimarySchemaPart(schemaPart);\n    });\n  }\n\n  /**\n   * The primary key must have a maxLength set\n   * which is required by some RxStorage implementations\n   * to ensure we can craft custom index strings.\n   */\n  var primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);\n  var primaryPathSchemaPart = jsonSchema.properties[primaryPath];\n  if (!primaryPathSchemaPart.maxLength) {\n    throw newRxError('SC39', {\n      schema: jsonSchema,\n      args: {\n        primaryPathSchemaPart\n      }\n    });\n  }\n}\n\n/**\n * computes real path of the object path in the collection schema\n */\nfunction getSchemaPropertyRealPath(shortPath) {\n  var pathParts = shortPath.split('.');\n  var realPath = '';\n  for (var i = 0; i < pathParts.length; i += 1) {\n    if (pathParts[i] !== '[]') {\n      realPath = realPath.concat('.properties.'.concat(pathParts[i]));\n    } else {\n      realPath = realPath.concat('.items');\n    }\n  }\n  return trimDots(realPath);\n}\n\n/**\n * does the checking\n * @throws {Error} if something is not ok\n */\nexport function checkSchema(jsonSchema) {\n  if (!jsonSchema.primaryKey) {\n    throw newRxError('SC30', {\n      schema: jsonSchema\n    });\n  }\n  if (!jsonSchema.hasOwnProperty('properties')) {\n    throw newRxError('SC29', {\n      schema: jsonSchema\n    });\n  }\n\n  // _rev MUST NOT exist, it is added by RxDB\n  if (jsonSchema.properties._rev) {\n    throw newRxError('SC10', {\n      schema: jsonSchema\n    });\n  }\n\n  // check version\n  if (!jsonSchema.hasOwnProperty('version') || typeof jsonSchema.version !== 'number' || jsonSchema.version < 0) {\n    throw newRxError('SC11', {\n      version: jsonSchema.version\n    });\n  }\n  validateFieldsDeep(jsonSchema);\n  checkPrimaryKey(jsonSchema);\n  Object.keys(jsonSchema.properties).forEach(key => {\n    var value = jsonSchema.properties[key];\n    // check primary\n    if (key === jsonSchema.primaryKey) {\n      if (jsonSchema.indexes && jsonSchema.indexes.includes(key)) {\n        throw newRxError('SC13', {\n          value,\n          schema: jsonSchema\n        });\n      }\n      if (value.unique) {\n        throw newRxError('SC14', {\n          value,\n          schema: jsonSchema\n        });\n      }\n      if (jsonSchema.encrypted && jsonSchema.encrypted.includes(key)) {\n        throw newRxError('SC15', {\n          value,\n          schema: jsonSchema\n        });\n      }\n      if (value.type !== 'string') {\n        throw newRxError('SC16', {\n          value,\n          schema: jsonSchema\n        });\n      }\n    }\n\n    // check if RxDocument-property\n    if (rxDocumentProperties().includes(key)) {\n      throw newRxError('SC17', {\n        key,\n        schema: jsonSchema\n      });\n    }\n  });\n\n  // check format of jsonSchema.indexes\n  if (jsonSchema.indexes) {\n    // should be an array\n    if (!isMaybeReadonlyArray(jsonSchema.indexes)) {\n      throw newRxError('SC18', {\n        indexes: jsonSchema.indexes,\n        schema: jsonSchema\n      });\n    }\n    jsonSchema.indexes.forEach(index => {\n      // should contain strings or array of strings\n      if (!(typeof index === 'string' || Array.isArray(index))) {\n        throw newRxError('SC19', {\n          index,\n          schema: jsonSchema\n        });\n      }\n      // if is a compound index it must contain strings\n      if (Array.isArray(index)) {\n        for (var i = 0; i < index.length; i += 1) {\n          if (typeof index[i] !== 'string') {\n            throw newRxError('SC20', {\n              index,\n              schema: jsonSchema\n            });\n          }\n        }\n      }\n\n      /**\n       * To be able to craft custom indexable string with compound fields,\n       * we need to know the maximum fieldlength of the fields values\n       * when they are transformed to strings.\n       * Therefore we need to enforce some properties inside of the schema.\n       */\n      var indexAsArray = isMaybeReadonlyArray(index) ? index : [index];\n      indexAsArray.forEach(fieldName => {\n        var schemaPart = getSchemaByObjectPath(jsonSchema, fieldName);\n        var type = schemaPart.type;\n        switch (type) {\n          case 'string':\n            var maxLength = schemaPart.maxLength;\n            if (!maxLength) {\n              throw newRxError('SC34', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            break;\n          case 'number':\n          case 'integer':\n            var multipleOf = schemaPart.multipleOf;\n            if (!multipleOf) {\n              throw newRxError('SC35', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            var maximum = schemaPart.maximum;\n            var minimum = schemaPart.minimum;\n            if (typeof maximum === 'undefined' || typeof minimum === 'undefined') {\n              throw newRxError('SC37', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            break;\n          case 'boolean':\n            /**\n             * If a boolean field is used as an index,\n             * it must be required.\n             */\n            var parentPath = '';\n            var lastPathPart = fieldName;\n            if (fieldName.includes('.')) {\n              var partParts = fieldName.split('.');\n              lastPathPart = partParts.pop();\n              parentPath = partParts.join('.');\n            }\n            var parentSchemaPart = parentPath === '' ? jsonSchema : getSchemaByObjectPath(jsonSchema, parentPath);\n            if (!parentSchemaPart.required || !parentSchemaPart.required.includes(lastPathPart)) {\n              throw newRxError('SC38', {\n                index,\n                field: fieldName,\n                schema: jsonSchema\n              });\n            }\n            break;\n          default:\n            throw newRxError('SC36', {\n              fieldName,\n              type: schemaPart.type,\n              schema: jsonSchema\n            });\n        }\n      });\n    });\n  }\n\n  // remove backward-compatibility for index: true\n  Object.keys(flattenObject(jsonSchema)).map(key => {\n    // flattenObject returns only ending paths, we need all paths pointing to an object\n    var split = key.split('.');\n    split.pop(); // all but last\n    return split.join('.');\n  }).filter(key => key !== '').filter((elem, pos, arr) => arr.indexOf(elem) === pos) // unique\n  .filter(key => {\n    // check if this path defines an index\n    var value = getProperty(jsonSchema, key);\n    return value && !!value.index;\n  }).forEach(key => {\n    // replace inner properties\n    key = key.replace('properties.', ''); // first\n    key = key.replace(/\\.properties\\./g, '.'); // middle\n    throw newRxError('SC26', {\n      index: trimDots(key),\n      schema: jsonSchema\n    });\n  });\n\n  /* check types of the indexes */\n  (jsonSchema.indexes || []).reduce((indexPaths, currentIndex) => {\n    if (isMaybeReadonlyArray(currentIndex)) {\n      appendToArray(indexPaths, currentIndex);\n    } else {\n      indexPaths.push(currentIndex);\n    }\n    return indexPaths;\n  }, []).filter((elem, pos, arr) => arr.indexOf(elem) === pos) // from now on working only with unique indexes\n  .map(indexPath => {\n    var realPath = getSchemaPropertyRealPath(indexPath); // real path in the collection schema\n    var schemaObj = getProperty(jsonSchema, realPath); // get the schema of the indexed property\n    if (!schemaObj || typeof schemaObj !== 'object') {\n      throw newRxError('SC21', {\n        index: indexPath,\n        schema: jsonSchema\n      });\n    }\n    return {\n      indexPath,\n      schemaObj\n    };\n  }).filter(index => index.schemaObj.type !== 'string' && index.schemaObj.type !== 'integer' && index.schemaObj.type !== 'number' && index.schemaObj.type !== 'boolean').forEach(index => {\n    throw newRxError('SC22', {\n      key: index.indexPath,\n      type: index.schemaObj.type,\n      schema: jsonSchema\n    });\n  });\n\n  /**\n   * TODO\n   * in 9.0.0 we changed the way encrypted fields are defined\n   * This check ensures people do not oversee the breaking change\n   * Remove this check in the future\n   */\n  Object.keys(flattenObject(jsonSchema)).map(key => {\n    // flattenObject returns only ending paths, we need all paths pointing to an object\n    var split = key.split('.');\n    split.pop(); // all but last\n    return split.join('.');\n  }).filter(key => key !== '' && key !== 'attachments').filter((elem, pos, arr) => arr.indexOf(elem) === pos) // unique\n  .filter(key => {\n    // check if this path defines an encrypted field\n    var value = getProperty(jsonSchema, key);\n    return value && !!value.encrypted;\n  }).forEach(key => {\n    // replace inner properties\n    key = key.replace('properties.', ''); // first\n    key = key.replace(/\\.properties\\./g, '.'); // middle\n    throw newRxError('SC27', {\n      index: trimDots(key),\n      schema: jsonSchema\n    });\n  });\n\n  /* ensure encrypted fields exist in the schema */\n  if (jsonSchema.encrypted) {\n    jsonSchema.encrypted.forEach(propPath => {\n      // real path in the collection schema\n      var realPath = getSchemaPropertyRealPath(propPath);\n      // get the schema of the indexed property\n      var schemaObj = getProperty(jsonSchema, realPath);\n      if (!schemaObj || typeof schemaObj !== 'object') {\n        throw newRxError('SC28', {\n          field: propPath,\n          schema: jsonSchema\n        });\n      }\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}