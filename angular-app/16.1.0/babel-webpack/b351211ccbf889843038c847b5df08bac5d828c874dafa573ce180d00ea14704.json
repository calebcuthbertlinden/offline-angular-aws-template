{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { filter, map, mergeMap } from 'rxjs/operators';\nimport { ucfirst, flatClone, promiseSeries, pluginMissing, ensureNotFalsy, getFromMapOrThrow, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_VOID, appendToArray } from './plugins/utils';\nimport { fillObjectDataBeforeInsert, createRxCollectionStorageInstance, removeCollectionStorages } from './rx-collection-helper';\nimport { createRxQuery, _getDefaultQuery } from './rx-query';\nimport { newRxError, newRxTypeError } from './rx-error';\nimport { DocumentCache } from './doc-cache';\nimport { createQueryCache, defaultCacheReplacementPolicy } from './query-cache';\nimport { createChangeEventBuffer } from './change-event-buffer';\nimport { runAsyncPluginHooks, runPluginHooks } from './hooks';\nimport { createNewRxDocument } from './rx-document-prototype-merge';\nimport { getWrappedStorageInstance, storageChangeEventToRxChangeEvent, throwIfIsStorageWriteError } from './rx-storage-helper';\nimport { defaultConflictHandler } from './replication-protocol';\nimport { IncrementalWriteQueue } from './incremental-write';\nimport { beforeDocumentUpdateWrite } from './rx-document';\nimport { overwritable } from './overwritable';\nvar HOOKS_WHEN = ['pre', 'post'];\nvar HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nvar hooksApplied = false;\nexport var RxCollectionBase = /*#__PURE__*/function () {\n  /**\n   * Stores all 'normal' documents\n   */\n\n  function RxCollectionBase(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options = {}, cacheReplacementPolicy = defaultCacheReplacementPolicy, statics = {}, conflictHandler = defaultConflictHandler) {\n    this.storageInstance = {};\n    this.timeouts = new Set();\n    this.incrementalWriteQueue = {};\n    this._incrementalUpsertQueues = new Map();\n    this.synced = false;\n    this.hooks = {};\n    this._subs = [];\n    this._docCache = {};\n    this._queryCache = createQueryCache();\n    this.$ = {};\n    this.checkpoint$ = {};\n    this._changeEventBuffer = {};\n    this.onDestroy = [];\n    this.destroyed = false;\n    this.database = database;\n    this.name = name;\n    this.schema = schema;\n    this.internalStorageInstance = internalStorageInstance;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.migrationStrategies = migrationStrategies;\n    this.methods = methods;\n    this.attachments = attachments;\n    this.options = options;\n    this.cacheReplacementPolicy = cacheReplacementPolicy;\n    this.statics = statics;\n    this.conflictHandler = conflictHandler;\n    _applyHookFunctions(this.asRxCollection);\n  }\n  var _proto = RxCollectionBase.prototype;\n  _proto.prepare = /*#__PURE__*/function () {\n    var _prepare = _asyncToGenerator(function* () {\n      this.storageInstance = getWrappedStorageInstance(this.database, this.internalStorageInstance, this.schema.jsonSchema);\n      this.incrementalWriteQueue = new IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => beforeDocumentUpdateWrite(this, newData, oldData), result => this._runHooks('post', 'save', result));\n      var collectionEventBulks$ = this.database.eventBulks$.pipe(filter(changeEventBulk => changeEventBulk.collectionName === this.name));\n      this.$ = collectionEventBulks$.pipe(mergeMap(changeEventBulk => changeEventBulk.events));\n      this.checkpoint$ = collectionEventBulks$.pipe(map(changeEventBulk => changeEventBulk.checkpoint));\n      this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n      this._docCache = new DocumentCache(this.schema.primaryPath, this.$.pipe(filter(cE => !cE.isLocal)), docData => createNewRxDocument(this.asRxCollection, docData));\n\n      /**\n       * Instead of resolving the EventBulk array here and spit it into\n       * single events, we should fully work with event bulks internally\n       * to save performance.\n       */\n      var databaseStorageToken = yield this.database.storageToken;\n      var subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n        var changeEventBulk = {\n          id: eventBulk.id,\n          internal: false,\n          collectionName: this.name,\n          storageToken: databaseStorageToken,\n          events: eventBulk.events.map(ev => storageChangeEventToRxChangeEvent(false, ev, this)),\n          databaseToken: this.database.token,\n          checkpoint: eventBulk.checkpoint,\n          context: eventBulk.context\n        };\n        this.database.$emit(changeEventBulk);\n      });\n      this._subs.push(subDocs);\n\n      /**\n       * Resolve the conflict tasks\n       * of the RxStorageInstance\n       */\n      this._subs.push(this.storageInstance.conflictResultionTasks().subscribe(task => {\n        this.conflictHandler(task.input, task.context).then(output => {\n          this.storageInstance.resolveConflictResultionTask({\n            id: task.id,\n            output\n          });\n        });\n      }));\n      return PROMISE_RESOLVE_VOID;\n    });\n    function prepare() {\n      return _prepare.apply(this, arguments);\n    }\n    return prepare;\n  }()\n\n  // overwritten by migration-plugin\n  ;\n\n  _proto.migrationNeeded = function migrationNeeded() {\n    throw pluginMissing('migration');\n  };\n  _proto.getDataMigrator = function getDataMigrator() {\n    throw pluginMissing('migration');\n  };\n  _proto.migrate = function migrate(batchSize = 10) {\n    return this.getDataMigrator().migrate(batchSize);\n  };\n  _proto.migratePromise = function migratePromise(batchSize = 10) {\n    return this.getDataMigrator().migratePromise(batchSize);\n  };\n  _proto.insert = /*#__PURE__*/function () {\n    var _insert = _asyncToGenerator(function* (json) {\n      var writeResult = yield this.bulkInsert([json]);\n      var isError = writeResult.error[0];\n      throwIfIsStorageWriteError(this, json[this.schema.primaryPath], json, isError);\n      var insertResult = ensureNotFalsy(writeResult.success[0]);\n      return insertResult;\n    });\n    function insert(_x) {\n      return _insert.apply(this, arguments);\n    }\n    return insert;\n  }();\n  _proto.bulkInsert = /*#__PURE__*/function () {\n    var _bulkInsert = _asyncToGenerator(function* (docsData) {\n      /**\n       * Optimization shortcut,\n       * do nothing when called with an empty array\n      */\n      if (docsData.length === 0) {\n        return {\n          success: [],\n          error: []\n        };\n      }\n      var primaryPath = this.schema.primaryPath;\n      var useDocs = docsData.map(docData => {\n        var useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n        return useDocData;\n      });\n      var docs = this.hasHooks('pre', 'insert') ? yield Promise.all(useDocs.map(doc => {\n        return this._runHooks('pre', 'insert', doc).then(() => {\n          return doc;\n        });\n      })) : useDocs;\n      var docsMap = new Map();\n      var insertRows = docs.map(doc => {\n        docsMap.set(doc[primaryPath], doc);\n        var row = {\n          document: doc\n        };\n        return row;\n      });\n      var results = yield this.storageInstance.bulkWrite(insertRows, 'rx-collection-bulk-insert');\n\n      // create documents\n      var rxDocuments = Object.values(results.success).map(writtenDocData => this._docCache.getCachedRxDocument(writtenDocData));\n      if (this.hasHooks('post', 'insert')) {\n        yield Promise.all(rxDocuments.map(doc => {\n          return this._runHooks('post', 'insert', docsMap.get(doc.primary), doc);\n        }));\n      }\n      return {\n        success: rxDocuments,\n        error: Object.values(results.error)\n      };\n    });\n    function bulkInsert(_x2) {\n      return _bulkInsert.apply(this, arguments);\n    }\n    return bulkInsert;\n  }();\n  _proto.bulkRemove = /*#__PURE__*/function () {\n    var _bulkRemove = _asyncToGenerator(function* (ids) {\n      /**\n       * Optimization shortcut,\n       * do nothing when called with an empty array\n       */\n      if (ids.length === 0) {\n        return {\n          success: [],\n          error: []\n        };\n      }\n      var rxDocumentMap = yield this.findByIds(ids).exec();\n      var docsData = [];\n      var docsMap = new Map();\n      Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n        var data = rxDocument.toMutableJSON(true);\n        docsData.push(data);\n        docsMap.set(rxDocument.primary, data);\n      });\n      yield Promise.all(docsData.map(doc => {\n        var primary = doc[this.schema.primaryPath];\n        return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n      }));\n      var removeDocs = docsData.map(doc => {\n        var writeDoc = flatClone(doc);\n        writeDoc._deleted = true;\n        return {\n          previous: doc,\n          document: writeDoc\n        };\n      });\n      var results = yield this.storageInstance.bulkWrite(removeDocs, 'rx-collection-bulk-remove');\n      var successIds = Object.keys(results.success);\n\n      // run hooks\n      yield Promise.all(successIds.map(id => {\n        return this._runHooks('post', 'remove', docsMap.get(id), rxDocumentMap.get(id));\n      }));\n      var rxDocuments = successIds.map(id => getFromMapOrThrow(rxDocumentMap, id));\n      return {\n        success: rxDocuments,\n        error: Object.values(results.error)\n      };\n    });\n    function bulkRemove(_x3) {\n      return _bulkRemove.apply(this, arguments);\n    }\n    return bulkRemove;\n  }()\n\n  /**\n   * same as bulkInsert but overwrites existing document with same primary\n   */;\n  _proto.bulkUpsert = /*#__PURE__*/function () {\n    var _bulkUpsert = _asyncToGenerator(function* (docsData) {\n      var _this = this;\n      var insertData = [];\n      var useJsonByDocId = new Map();\n      docsData.forEach(docData => {\n        var useJson = fillObjectDataBeforeInsert(this.schema, docData);\n        var primary = useJson[this.schema.primaryPath];\n        if (!primary) {\n          throw newRxError('COL3', {\n            primaryPath: this.schema.primaryPath,\n            data: useJson,\n            schema: this.schema.jsonSchema\n          });\n        }\n        useJsonByDocId.set(primary, useJson);\n        insertData.push(useJson);\n      });\n      var insertResult = yield this.bulkInsert(insertData);\n      var ret = insertResult.success.slice(0);\n      var updatedDocs = yield Promise.all(insertResult.error.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (error) {\n          if (error.status !== 409) {\n            throw newRxError('VD2', {\n              collection: _this.name,\n              writeError: error\n            });\n          }\n          var id = error.documentId;\n          var writeData = getFromMapOrThrow(useJsonByDocId, id);\n          var docDataInDb = ensureNotFalsy(error.documentInDb);\n          var doc = _this._docCache.getCachedRxDocument(docDataInDb);\n          var newDoc = yield doc.incrementalModify(() => writeData);\n          return newDoc;\n        });\n        return function (_x5) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n      appendToArray(ret, updatedDocs);\n      return ret;\n    });\n    function bulkUpsert(_x4) {\n      return _bulkUpsert.apply(this, arguments);\n    }\n    return bulkUpsert;\n  }()\n\n  /**\n   * same as insert but overwrites existing document with same primary\n   */;\n  _proto.upsert = function upsert(json) {\n    return this.bulkUpsert([json]).then(result => result[0]);\n  }\n\n  /**\n   * upserts to a RxDocument, uses incrementalModify if document already exists\n   */;\n  _proto.incrementalUpsert = function incrementalUpsert(json) {\n    var useJson = fillObjectDataBeforeInsert(this.schema, json);\n    var primary = useJson[this.schema.primaryPath];\n    if (!primary) {\n      throw newRxError('COL4', {\n        data: json\n      });\n    }\n\n    // ensure that it won't try 2 parallel runs\n    var queue = this._incrementalUpsertQueues.get(primary);\n    if (!queue) {\n      queue = PROMISE_RESOLVE_VOID;\n    }\n    queue = queue.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then(wasInserted => {\n      if (!wasInserted.inserted) {\n        return _incrementalUpsertUpdate(wasInserted.doc, useJson);\n      } else {\n        return wasInserted.doc;\n      }\n    });\n    this._incrementalUpsertQueues.set(primary, queue);\n    return queue;\n  };\n  _proto.find = function find(queryObj) {\n    if (typeof queryObj === 'string') {\n      throw newRxError('COL5', {\n        queryObj\n      });\n    }\n    if (!queryObj) {\n      queryObj = _getDefaultQuery();\n    }\n    var query = createRxQuery('find', queryObj, this);\n    return query;\n  };\n  _proto.findOne = function findOne(queryObj) {\n    var query;\n    if (typeof queryObj === 'string') {\n      query = createRxQuery('findOne', {\n        selector: {\n          [this.schema.primaryPath]: queryObj\n        },\n        limit: 1\n      }, this);\n    } else {\n      if (!queryObj) {\n        queryObj = _getDefaultQuery();\n      }\n\n      // cannot have limit on findOne queries because it will be overwritten\n      if (queryObj.limit) {\n        throw newRxError('QU6');\n      }\n      queryObj.limit = 1;\n      query = createRxQuery('findOne', queryObj, this);\n    }\n    if (typeof queryObj === 'number' || Array.isArray(queryObj)) {\n      throw newRxTypeError('COL6', {\n        queryObj\n      });\n    }\n    return query;\n  };\n  _proto.count = function count(queryObj) {\n    if (!queryObj) {\n      queryObj = _getDefaultQuery();\n    }\n    var query = createRxQuery('count', queryObj, this);\n    return query;\n  }\n\n  /**\n   * find a list documents by their primary key\n   * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n   */;\n  _proto.findByIds = function findByIds(ids) {\n    var mangoQuery = {\n      selector: {\n        [this.schema.primaryPath]: {\n          $in: ids.slice(0)\n        }\n      }\n    };\n    var query = createRxQuery('findByIds', mangoQuery, this);\n    return query;\n  }\n\n  /**\n   * Export collection to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON() {\n    throw pluginMissing('json-dump');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.insertCRDT = function insertCRDT(_updateObj) {\n    throw pluginMissing('crdt');\n  }\n\n  /**\n   * HOOKS\n   */;\n  _proto.addHook = function addHook(when, key, fun, parallel = false) {\n    if (typeof fun !== 'function') {\n      throw newRxTypeError('COL7', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_WHEN.includes(when)) {\n      throw newRxTypeError('COL8', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_KEYS.includes(key)) {\n      throw newRxError('COL9', {\n        key\n      });\n    }\n    if (when === 'post' && key === 'create' && parallel === true) {\n      throw newRxError('COL10', {\n        when,\n        key,\n        parallel\n      });\n    }\n\n    // bind this-scope to hook-function\n    var boundFun = fun.bind(this);\n    var runName = parallel ? 'parallel' : 'series';\n    this.hooks[key] = this.hooks[key] || {};\n    this.hooks[key][when] = this.hooks[key][when] || {\n      series: [],\n      parallel: []\n    };\n    this.hooks[key][when][runName].push(boundFun);\n  };\n  _proto.getHooks = function getHooks(when, key) {\n    if (!this.hooks[key] || !this.hooks[key][when]) {\n      return {\n        series: [],\n        parallel: []\n      };\n    }\n    return this.hooks[key][when];\n  };\n  _proto.hasHooks = function hasHooks(when, key) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return false;\n    }\n    return hooks.series.length > 0 || hooks.parallel.length > 0;\n  };\n  _proto._runHooks = function _runHooks(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return PROMISE_RESOLVE_VOID;\n    }\n\n    // run parallel: false\n    var tasks = hooks.series.map(hook => () => hook(data, instance));\n    return promiseSeries(tasks)\n    // run parallel: true\n    .then(() => Promise.all(hooks.parallel.map(hook => hook(data, instance))));\n  }\n\n  /**\n   * does the same as ._runHooks() but with non-async-functions\n   */;\n  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return;\n    hooks.series.forEach(hook => hook(data, instance));\n  }\n\n  /**\n   * Returns a promise that resolves after the given time.\n   * Ensures that is properly cleans up when the collection is destroyed\n   * so that no running timeouts prevent the exit of the JavaScript process.\n   */;\n  _proto.promiseWait = function promiseWait(time) {\n    var ret = new Promise(res => {\n      var timeout = setTimeout(() => {\n        this.timeouts.delete(timeout);\n        res();\n      }, time);\n      this.timeouts.add(timeout);\n    });\n    return ret;\n  };\n  _proto.destroy = function destroy() {\n    if (this.destroyed) {\n      return PROMISE_RESOLVE_FALSE;\n    }\n\n    /**\n     * Settings destroyed = true\n     * must be the first thing to do,\n     * so for example the replication can directly stop\n     * instead of sending requests to a closed storage.\n     */\n    this.destroyed = true;\n    Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n    if (this._changeEventBuffer) {\n      this._changeEventBuffer.destroy();\n    }\n    /**\n     * First wait until the whole database is idle.\n     * This ensures that the storage does not get closed\n     * while some operation is running.\n     * It is important that we do not intercept a running call\n     * because it might lead to undefined behavior like when a doc is written\n     * but the change is not added to the changes collection.\n     */\n    return this.database.requestIdlePromise().then(() => Promise.all(this.onDestroy.map(fn => fn()))).then(() => this.storageInstance.close()).then(() => {\n      /**\n       * Unsubscribing must be done AFTER the storageInstance.close()\n       * Because the conflict handling is part of the subscriptions and\n       * otherwise there might be open conflicts to be resolved which\n       * will then stuck and never resolve.\n       */\n      this._subs.forEach(sub => sub.unsubscribe());\n      delete this.database.collections[this.name];\n      return runAsyncPluginHooks('postDestroyRxCollection', this).then(() => true);\n    });\n  }\n\n  /**\n   * remove all data of the collection\n   */;\n  _proto.remove = /*#__PURE__*/function () {\n    var _remove = _asyncToGenerator(function* () {\n      yield this.destroy();\n      yield removeCollectionStorages(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.hashFunction);\n    });\n    function remove() {\n      return _remove.apply(this, arguments);\n    }\n    return remove;\n  }();\n  _createClass(RxCollectionBase, [{\n    key: \"insert$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'INSERT'));\n    }\n  }, {\n    key: \"update$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'UPDATE'));\n    }\n  }, {\n    key: \"remove$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'DELETE'));\n    }\n\n    // defaults\n\n    /**\n     * When the collection is destroyed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n     */\n  }, {\n    key: \"asRxCollection\",\n    get: function () {\n      return this;\n    }\n  }]);\n  return RxCollectionBase;\n}();\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(collection) {\n  if (hooksApplied) return; // already run\n  hooksApplied = true;\n  var colProto = Object.getPrototypeOf(collection);\n  HOOKS_KEYS.forEach(key => {\n    HOOKS_WHEN.map(when => {\n      var fnName = when + ucfirst(key);\n      colProto[fnName] = function (fun, parallel) {\n        return this.addHook(when, key, fun, parallel);\n      };\n    });\n  });\n}\nfunction _incrementalUpsertUpdate(doc, json) {\n  return doc.incrementalModify(_innerDoc => {\n    return json;\n  });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _incrementalUpsertEnsureRxDocumentExists(rxCollection, primary, json) {\n  /**\n   * Optimisation shortcut,\n   * first try to find the document in the doc-cache\n   */\n  var docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);\n  if (docDataFromCache) {\n    return Promise.resolve({\n      doc: rxCollection._docCache.getCachedRxDocument(docDataFromCache),\n      inserted: false\n    });\n  }\n  return rxCollection.findOne(primary).exec().then(doc => {\n    if (!doc) {\n      return rxCollection.insert(json).then(newDoc => ({\n        doc: newDoc,\n        inserted: true\n      }));\n    } else {\n      return {\n        doc,\n        inserted: false\n      };\n    }\n  });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection({\n  database,\n  name,\n  schema,\n  instanceCreationOptions = {},\n  migrationStrategies = {},\n  autoMigrate = true,\n  statics = {},\n  methods = {},\n  attachments = {},\n  options = {},\n  localDocuments = false,\n  cacheReplacementPolicy = defaultCacheReplacementPolicy,\n  conflictHandler = defaultConflictHandler\n}) {\n  var storageInstanceCreationParams = {\n    databaseInstanceToken: database.token,\n    databaseName: database.name,\n    collectionName: name,\n    schema: schema.jsonSchema,\n    options: instanceCreationOptions,\n    multiInstance: database.multiInstance,\n    password: database.password,\n    devMode: overwritable.isDevMode()\n  };\n  runPluginHooks('preCreateRxStorageInstance', storageInstanceCreationParams);\n  return createRxCollectionStorageInstance(database, storageInstanceCreationParams).then(storageInstance => {\n    var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics, conflictHandler);\n    return collection.prepare().then(() => {\n      // ORM add statics\n      Object.entries(statics).forEach(([funName, fun]) => {\n        Object.defineProperty(collection, funName, {\n          get: () => fun.bind(collection)\n        });\n      });\n      var ret = PROMISE_RESOLVE_VOID;\n      if (autoMigrate && collection.schema.version !== 0) {\n        ret = collection.migratePromise();\n      }\n      return ret;\n    }).then(() => {\n      runPluginHooks('createRxCollection', {\n        collection,\n        creator: {\n          name,\n          schema,\n          storageInstance,\n          instanceCreationOptions,\n          migrationStrategies,\n          methods,\n          attachments,\n          options,\n          cacheReplacementPolicy,\n          localDocuments,\n          statics\n        }\n      });\n      return collection;\n    })\n    /**\n     * If the collection creation fails,\n     * we yet have to close the storage instances.\n     */.catch(err => {\n      return storageInstance.close().then(() => Promise.reject(err));\n    });\n  });\n}\nexport function isRxCollection(obj) {\n  return obj instanceof RxCollectionBase;\n}","map":{"version":3,"names":["_createClass","filter","map","mergeMap","ucfirst","flatClone","promiseSeries","pluginMissing","ensureNotFalsy","getFromMapOrThrow","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_VOID","appendToArray","fillObjectDataBeforeInsert","createRxCollectionStorageInstance","removeCollectionStorages","createRxQuery","_getDefaultQuery","newRxError","newRxTypeError","DocumentCache","createQueryCache","defaultCacheReplacementPolicy","createChangeEventBuffer","runAsyncPluginHooks","runPluginHooks","createNewRxDocument","getWrappedStorageInstance","storageChangeEventToRxChangeEvent","throwIfIsStorageWriteError","defaultConflictHandler","IncrementalWriteQueue","beforeDocumentUpdateWrite","overwritable","HOOKS_WHEN","HOOKS_KEYS","hooksApplied","RxCollectionBase","database","name","schema","internalStorageInstance","instanceCreationOptions","migrationStrategies","methods","attachments","options","cacheReplacementPolicy","statics","conflictHandler","storageInstance","timeouts","Set","incrementalWriteQueue","_incrementalUpsertQueues","Map","synced","hooks","_subs","_docCache","_queryCache","$","checkpoint$","_changeEventBuffer","onDestroy","destroyed","_applyHookFunctions","asRxCollection","_proto","prototype","prepare","_prepare","_asyncToGenerator","jsonSchema","primaryPath","newData","oldData","result","_runHooks","collectionEventBulks$","eventBulks$","pipe","changeEventBulk","collectionName","events","checkpoint","cE","isLocal","docData","databaseStorageToken","storageToken","subDocs","changeStream","subscribe","eventBulk","id","internal","ev","databaseToken","token","context","$emit","push","conflictResultionTasks","task","input","then","output","resolveConflictResultionTask","apply","arguments","migrationNeeded","getDataMigrator","migrate","batchSize","migratePromise","insert","_insert","json","writeResult","bulkInsert","isError","error","insertResult","success","_x","_bulkInsert","docsData","length","useDocs","useDocData","docs","hasHooks","Promise","all","doc","docsMap","insertRows","set","row","document","results","bulkWrite","rxDocuments","Object","values","writtenDocData","getCachedRxDocument","get","primary","_x2","bulkRemove","_bulkRemove","ids","rxDocumentMap","findByIds","exec","Array","from","forEach","rxDocument","data","toMutableJSON","removeDocs","writeDoc","_deleted","previous","successIds","keys","_x3","bulkUpsert","_bulkUpsert","_this","insertData","useJsonByDocId","useJson","ret","slice","updatedDocs","_ref","status","collection","writeError","documentId","writeData","docDataInDb","documentInDb","newDoc","incrementalModify","_x5","_x4","upsert","incrementalUpsert","queue","_incrementalUpsertEnsureRxDocumentExists","wasInserted","inserted","_incrementalUpsertUpdate","find","queryObj","query","findOne","selector","limit","isArray","count","mangoQuery","$in","exportJSON","importJSON","_exportedJSON","insertCRDT","_updateObj","addHook","when","key","fun","parallel","includes","boundFun","bind","runName","series","getHooks","instance","tasks","hook","_runHooksSync","promiseWait","time","res","timeout","setTimeout","delete","add","destroy","clearTimeout","requestIdlePromise","fn","close","sub","unsubscribe","collections","remove","_remove","storage","internalStore","hashFunction","operation","colProto","getPrototypeOf","fnName","_innerDoc","rxCollection","docDataFromCache","getLatestDocumentDataIfExists","resolve","createRxCollection","autoMigrate","localDocuments","storageInstanceCreationParams","databaseInstanceToken","databaseName","multiInstance","password","devMode","isDevMode","entries","funName","defineProperty","version","creator","catch","err","reject","isRxCollection","obj"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/rx-collection.js"],"sourcesContent":["import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { filter, map, mergeMap } from 'rxjs/operators';\nimport { ucfirst, flatClone, promiseSeries, pluginMissing, ensureNotFalsy, getFromMapOrThrow, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_VOID, appendToArray } from './plugins/utils';\nimport { fillObjectDataBeforeInsert, createRxCollectionStorageInstance, removeCollectionStorages } from './rx-collection-helper';\nimport { createRxQuery, _getDefaultQuery } from './rx-query';\nimport { newRxError, newRxTypeError } from './rx-error';\nimport { DocumentCache } from './doc-cache';\nimport { createQueryCache, defaultCacheReplacementPolicy } from './query-cache';\nimport { createChangeEventBuffer } from './change-event-buffer';\nimport { runAsyncPluginHooks, runPluginHooks } from './hooks';\nimport { createNewRxDocument } from './rx-document-prototype-merge';\nimport { getWrappedStorageInstance, storageChangeEventToRxChangeEvent, throwIfIsStorageWriteError } from './rx-storage-helper';\nimport { defaultConflictHandler } from './replication-protocol';\nimport { IncrementalWriteQueue } from './incremental-write';\nimport { beforeDocumentUpdateWrite } from './rx-document';\nimport { overwritable } from './overwritable';\nvar HOOKS_WHEN = ['pre', 'post'];\nvar HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nvar hooksApplied = false;\nexport var RxCollectionBase = /*#__PURE__*/function () {\n  /**\n   * Stores all 'normal' documents\n   */\n\n  function RxCollectionBase(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options = {}, cacheReplacementPolicy = defaultCacheReplacementPolicy, statics = {}, conflictHandler = defaultConflictHandler) {\n    this.storageInstance = {};\n    this.timeouts = new Set();\n    this.incrementalWriteQueue = {};\n    this._incrementalUpsertQueues = new Map();\n    this.synced = false;\n    this.hooks = {};\n    this._subs = [];\n    this._docCache = {};\n    this._queryCache = createQueryCache();\n    this.$ = {};\n    this.checkpoint$ = {};\n    this._changeEventBuffer = {};\n    this.onDestroy = [];\n    this.destroyed = false;\n    this.database = database;\n    this.name = name;\n    this.schema = schema;\n    this.internalStorageInstance = internalStorageInstance;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.migrationStrategies = migrationStrategies;\n    this.methods = methods;\n    this.attachments = attachments;\n    this.options = options;\n    this.cacheReplacementPolicy = cacheReplacementPolicy;\n    this.statics = statics;\n    this.conflictHandler = conflictHandler;\n    _applyHookFunctions(this.asRxCollection);\n  }\n  var _proto = RxCollectionBase.prototype;\n  _proto.prepare = async function prepare() {\n    this.storageInstance = getWrappedStorageInstance(this.database, this.internalStorageInstance, this.schema.jsonSchema);\n    this.incrementalWriteQueue = new IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => beforeDocumentUpdateWrite(this, newData, oldData), result => this._runHooks('post', 'save', result));\n    var collectionEventBulks$ = this.database.eventBulks$.pipe(filter(changeEventBulk => changeEventBulk.collectionName === this.name));\n    this.$ = collectionEventBulks$.pipe(mergeMap(changeEventBulk => changeEventBulk.events));\n    this.checkpoint$ = collectionEventBulks$.pipe(map(changeEventBulk => changeEventBulk.checkpoint));\n    this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n    this._docCache = new DocumentCache(this.schema.primaryPath, this.$.pipe(filter(cE => !cE.isLocal)), docData => createNewRxDocument(this.asRxCollection, docData));\n\n    /**\n     * Instead of resolving the EventBulk array here and spit it into\n     * single events, we should fully work with event bulks internally\n     * to save performance.\n     */\n    var databaseStorageToken = await this.database.storageToken;\n    var subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n      var changeEventBulk = {\n        id: eventBulk.id,\n        internal: false,\n        collectionName: this.name,\n        storageToken: databaseStorageToken,\n        events: eventBulk.events.map(ev => storageChangeEventToRxChangeEvent(false, ev, this)),\n        databaseToken: this.database.token,\n        checkpoint: eventBulk.checkpoint,\n        context: eventBulk.context\n      };\n      this.database.$emit(changeEventBulk);\n    });\n    this._subs.push(subDocs);\n\n    /**\n     * Resolve the conflict tasks\n     * of the RxStorageInstance\n     */\n    this._subs.push(this.storageInstance.conflictResultionTasks().subscribe(task => {\n      this.conflictHandler(task.input, task.context).then(output => {\n        this.storageInstance.resolveConflictResultionTask({\n          id: task.id,\n          output\n        });\n      });\n    }));\n    return PROMISE_RESOLVE_VOID;\n  }\n\n  // overwritten by migration-plugin\n  ;\n  _proto.migrationNeeded = function migrationNeeded() {\n    throw pluginMissing('migration');\n  };\n  _proto.getDataMigrator = function getDataMigrator() {\n    throw pluginMissing('migration');\n  };\n  _proto.migrate = function migrate(batchSize = 10) {\n    return this.getDataMigrator().migrate(batchSize);\n  };\n  _proto.migratePromise = function migratePromise(batchSize = 10) {\n    return this.getDataMigrator().migratePromise(batchSize);\n  };\n  _proto.insert = async function insert(json) {\n    var writeResult = await this.bulkInsert([json]);\n    var isError = writeResult.error[0];\n    throwIfIsStorageWriteError(this, json[this.schema.primaryPath], json, isError);\n    var insertResult = ensureNotFalsy(writeResult.success[0]);\n    return insertResult;\n  };\n  _proto.bulkInsert = async function bulkInsert(docsData) {\n    /**\n     * Optimization shortcut,\n     * do nothing when called with an empty array\n    */\n    if (docsData.length === 0) {\n      return {\n        success: [],\n        error: []\n      };\n    }\n    var primaryPath = this.schema.primaryPath;\n    var useDocs = docsData.map(docData => {\n      var useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n      return useDocData;\n    });\n    var docs = this.hasHooks('pre', 'insert') ? await Promise.all(useDocs.map(doc => {\n      return this._runHooks('pre', 'insert', doc).then(() => {\n        return doc;\n      });\n    })) : useDocs;\n    var docsMap = new Map();\n    var insertRows = docs.map(doc => {\n      docsMap.set(doc[primaryPath], doc);\n      var row = {\n        document: doc\n      };\n      return row;\n    });\n    var results = await this.storageInstance.bulkWrite(insertRows, 'rx-collection-bulk-insert');\n\n    // create documents\n    var rxDocuments = Object.values(results.success).map(writtenDocData => this._docCache.getCachedRxDocument(writtenDocData));\n    if (this.hasHooks('post', 'insert')) {\n      await Promise.all(rxDocuments.map(doc => {\n        return this._runHooks('post', 'insert', docsMap.get(doc.primary), doc);\n      }));\n    }\n    return {\n      success: rxDocuments,\n      error: Object.values(results.error)\n    };\n  };\n  _proto.bulkRemove = async function bulkRemove(ids) {\n    /**\n     * Optimization shortcut,\n     * do nothing when called with an empty array\n     */\n    if (ids.length === 0) {\n      return {\n        success: [],\n        error: []\n      };\n    }\n    var rxDocumentMap = await this.findByIds(ids).exec();\n    var docsData = [];\n    var docsMap = new Map();\n    Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n      var data = rxDocument.toMutableJSON(true);\n      docsData.push(data);\n      docsMap.set(rxDocument.primary, data);\n    });\n    await Promise.all(docsData.map(doc => {\n      var primary = doc[this.schema.primaryPath];\n      return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n    }));\n    var removeDocs = docsData.map(doc => {\n      var writeDoc = flatClone(doc);\n      writeDoc._deleted = true;\n      return {\n        previous: doc,\n        document: writeDoc\n      };\n    });\n    var results = await this.storageInstance.bulkWrite(removeDocs, 'rx-collection-bulk-remove');\n    var successIds = Object.keys(results.success);\n\n    // run hooks\n    await Promise.all(successIds.map(id => {\n      return this._runHooks('post', 'remove', docsMap.get(id), rxDocumentMap.get(id));\n    }));\n    var rxDocuments = successIds.map(id => getFromMapOrThrow(rxDocumentMap, id));\n    return {\n      success: rxDocuments,\n      error: Object.values(results.error)\n    };\n  }\n\n  /**\n   * same as bulkInsert but overwrites existing document with same primary\n   */;\n  _proto.bulkUpsert = async function bulkUpsert(docsData) {\n    var insertData = [];\n    var useJsonByDocId = new Map();\n    docsData.forEach(docData => {\n      var useJson = fillObjectDataBeforeInsert(this.schema, docData);\n      var primary = useJson[this.schema.primaryPath];\n      if (!primary) {\n        throw newRxError('COL3', {\n          primaryPath: this.schema.primaryPath,\n          data: useJson,\n          schema: this.schema.jsonSchema\n        });\n      }\n      useJsonByDocId.set(primary, useJson);\n      insertData.push(useJson);\n    });\n    var insertResult = await this.bulkInsert(insertData);\n    var ret = insertResult.success.slice(0);\n    var updatedDocs = await Promise.all(insertResult.error.map(async error => {\n      if (error.status !== 409) {\n        throw newRxError('VD2', {\n          collection: this.name,\n          writeError: error\n        });\n      }\n      var id = error.documentId;\n      var writeData = getFromMapOrThrow(useJsonByDocId, id);\n      var docDataInDb = ensureNotFalsy(error.documentInDb);\n      var doc = this._docCache.getCachedRxDocument(docDataInDb);\n      var newDoc = await doc.incrementalModify(() => writeData);\n      return newDoc;\n    }));\n    appendToArray(ret, updatedDocs);\n    return ret;\n  }\n\n  /**\n   * same as insert but overwrites existing document with same primary\n   */;\n  _proto.upsert = function upsert(json) {\n    return this.bulkUpsert([json]).then(result => result[0]);\n  }\n\n  /**\n   * upserts to a RxDocument, uses incrementalModify if document already exists\n   */;\n  _proto.incrementalUpsert = function incrementalUpsert(json) {\n    var useJson = fillObjectDataBeforeInsert(this.schema, json);\n    var primary = useJson[this.schema.primaryPath];\n    if (!primary) {\n      throw newRxError('COL4', {\n        data: json\n      });\n    }\n\n    // ensure that it won't try 2 parallel runs\n    var queue = this._incrementalUpsertQueues.get(primary);\n    if (!queue) {\n      queue = PROMISE_RESOLVE_VOID;\n    }\n    queue = queue.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then(wasInserted => {\n      if (!wasInserted.inserted) {\n        return _incrementalUpsertUpdate(wasInserted.doc, useJson);\n      } else {\n        return wasInserted.doc;\n      }\n    });\n    this._incrementalUpsertQueues.set(primary, queue);\n    return queue;\n  };\n  _proto.find = function find(queryObj) {\n    if (typeof queryObj === 'string') {\n      throw newRxError('COL5', {\n        queryObj\n      });\n    }\n    if (!queryObj) {\n      queryObj = _getDefaultQuery();\n    }\n    var query = createRxQuery('find', queryObj, this);\n    return query;\n  };\n  _proto.findOne = function findOne(queryObj) {\n    var query;\n    if (typeof queryObj === 'string') {\n      query = createRxQuery('findOne', {\n        selector: {\n          [this.schema.primaryPath]: queryObj\n        },\n        limit: 1\n      }, this);\n    } else {\n      if (!queryObj) {\n        queryObj = _getDefaultQuery();\n      }\n\n      // cannot have limit on findOne queries because it will be overwritten\n      if (queryObj.limit) {\n        throw newRxError('QU6');\n      }\n      queryObj.limit = 1;\n      query = createRxQuery('findOne', queryObj, this);\n    }\n    if (typeof queryObj === 'number' || Array.isArray(queryObj)) {\n      throw newRxTypeError('COL6', {\n        queryObj\n      });\n    }\n    return query;\n  };\n  _proto.count = function count(queryObj) {\n    if (!queryObj) {\n      queryObj = _getDefaultQuery();\n    }\n    var query = createRxQuery('count', queryObj, this);\n    return query;\n  }\n\n  /**\n   * find a list documents by their primary key\n   * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n   */;\n  _proto.findByIds = function findByIds(ids) {\n    var mangoQuery = {\n      selector: {\n        [this.schema.primaryPath]: {\n          $in: ids.slice(0)\n        }\n      }\n    };\n    var query = createRxQuery('findByIds', mangoQuery, this);\n    return query;\n  }\n\n  /**\n   * Export collection to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON() {\n    throw pluginMissing('json-dump');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.insertCRDT = function insertCRDT(_updateObj) {\n    throw pluginMissing('crdt');\n  }\n\n  /**\n   * HOOKS\n   */;\n  _proto.addHook = function addHook(when, key, fun, parallel = false) {\n    if (typeof fun !== 'function') {\n      throw newRxTypeError('COL7', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_WHEN.includes(when)) {\n      throw newRxTypeError('COL8', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_KEYS.includes(key)) {\n      throw newRxError('COL9', {\n        key\n      });\n    }\n    if (when === 'post' && key === 'create' && parallel === true) {\n      throw newRxError('COL10', {\n        when,\n        key,\n        parallel\n      });\n    }\n\n    // bind this-scope to hook-function\n    var boundFun = fun.bind(this);\n    var runName = parallel ? 'parallel' : 'series';\n    this.hooks[key] = this.hooks[key] || {};\n    this.hooks[key][when] = this.hooks[key][when] || {\n      series: [],\n      parallel: []\n    };\n    this.hooks[key][when][runName].push(boundFun);\n  };\n  _proto.getHooks = function getHooks(when, key) {\n    if (!this.hooks[key] || !this.hooks[key][when]) {\n      return {\n        series: [],\n        parallel: []\n      };\n    }\n    return this.hooks[key][when];\n  };\n  _proto.hasHooks = function hasHooks(when, key) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return false;\n    }\n    return hooks.series.length > 0 || hooks.parallel.length > 0;\n  };\n  _proto._runHooks = function _runHooks(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return PROMISE_RESOLVE_VOID;\n    }\n\n    // run parallel: false\n    var tasks = hooks.series.map(hook => () => hook(data, instance));\n    return promiseSeries(tasks)\n    // run parallel: true\n    .then(() => Promise.all(hooks.parallel.map(hook => hook(data, instance))));\n  }\n\n  /**\n   * does the same as ._runHooks() but with non-async-functions\n   */;\n  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return;\n    hooks.series.forEach(hook => hook(data, instance));\n  }\n\n  /**\n   * Returns a promise that resolves after the given time.\n   * Ensures that is properly cleans up when the collection is destroyed\n   * so that no running timeouts prevent the exit of the JavaScript process.\n   */;\n  _proto.promiseWait = function promiseWait(time) {\n    var ret = new Promise(res => {\n      var timeout = setTimeout(() => {\n        this.timeouts.delete(timeout);\n        res();\n      }, time);\n      this.timeouts.add(timeout);\n    });\n    return ret;\n  };\n  _proto.destroy = function destroy() {\n    if (this.destroyed) {\n      return PROMISE_RESOLVE_FALSE;\n    }\n\n    /**\n     * Settings destroyed = true\n     * must be the first thing to do,\n     * so for example the replication can directly stop\n     * instead of sending requests to a closed storage.\n     */\n    this.destroyed = true;\n    Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n    if (this._changeEventBuffer) {\n      this._changeEventBuffer.destroy();\n    }\n    /**\n     * First wait until the whole database is idle.\n     * This ensures that the storage does not get closed\n     * while some operation is running.\n     * It is important that we do not intercept a running call\n     * because it might lead to undefined behavior like when a doc is written\n     * but the change is not added to the changes collection.\n     */\n    return this.database.requestIdlePromise().then(() => Promise.all(this.onDestroy.map(fn => fn()))).then(() => this.storageInstance.close()).then(() => {\n      /**\n       * Unsubscribing must be done AFTER the storageInstance.close()\n       * Because the conflict handling is part of the subscriptions and\n       * otherwise there might be open conflicts to be resolved which\n       * will then stuck and never resolve.\n       */\n      this._subs.forEach(sub => sub.unsubscribe());\n      delete this.database.collections[this.name];\n      return runAsyncPluginHooks('postDestroyRxCollection', this).then(() => true);\n    });\n  }\n\n  /**\n   * remove all data of the collection\n   */;\n  _proto.remove = async function remove() {\n    await this.destroy();\n    await removeCollectionStorages(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.hashFunction);\n  };\n  _createClass(RxCollectionBase, [{\n    key: \"insert$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'INSERT'));\n    }\n  }, {\n    key: \"update$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'UPDATE'));\n    }\n  }, {\n    key: \"remove$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'DELETE'));\n    }\n\n    // defaults\n\n    /**\n     * When the collection is destroyed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n     */\n  }, {\n    key: \"asRxCollection\",\n    get: function () {\n      return this;\n    }\n  }]);\n  return RxCollectionBase;\n}();\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(collection) {\n  if (hooksApplied) return; // already run\n  hooksApplied = true;\n  var colProto = Object.getPrototypeOf(collection);\n  HOOKS_KEYS.forEach(key => {\n    HOOKS_WHEN.map(when => {\n      var fnName = when + ucfirst(key);\n      colProto[fnName] = function (fun, parallel) {\n        return this.addHook(when, key, fun, parallel);\n      };\n    });\n  });\n}\nfunction _incrementalUpsertUpdate(doc, json) {\n  return doc.incrementalModify(_innerDoc => {\n    return json;\n  });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _incrementalUpsertEnsureRxDocumentExists(rxCollection, primary, json) {\n  /**\n   * Optimisation shortcut,\n   * first try to find the document in the doc-cache\n   */\n  var docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);\n  if (docDataFromCache) {\n    return Promise.resolve({\n      doc: rxCollection._docCache.getCachedRxDocument(docDataFromCache),\n      inserted: false\n    });\n  }\n  return rxCollection.findOne(primary).exec().then(doc => {\n    if (!doc) {\n      return rxCollection.insert(json).then(newDoc => ({\n        doc: newDoc,\n        inserted: true\n      }));\n    } else {\n      return {\n        doc,\n        inserted: false\n      };\n    }\n  });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection({\n  database,\n  name,\n  schema,\n  instanceCreationOptions = {},\n  migrationStrategies = {},\n  autoMigrate = true,\n  statics = {},\n  methods = {},\n  attachments = {},\n  options = {},\n  localDocuments = false,\n  cacheReplacementPolicy = defaultCacheReplacementPolicy,\n  conflictHandler = defaultConflictHandler\n}) {\n  var storageInstanceCreationParams = {\n    databaseInstanceToken: database.token,\n    databaseName: database.name,\n    collectionName: name,\n    schema: schema.jsonSchema,\n    options: instanceCreationOptions,\n    multiInstance: database.multiInstance,\n    password: database.password,\n    devMode: overwritable.isDevMode()\n  };\n  runPluginHooks('preCreateRxStorageInstance', storageInstanceCreationParams);\n  return createRxCollectionStorageInstance(database, storageInstanceCreationParams).then(storageInstance => {\n    var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics, conflictHandler);\n    return collection.prepare().then(() => {\n      // ORM add statics\n      Object.entries(statics).forEach(([funName, fun]) => {\n        Object.defineProperty(collection, funName, {\n          get: () => fun.bind(collection)\n        });\n      });\n      var ret = PROMISE_RESOLVE_VOID;\n      if (autoMigrate && collection.schema.version !== 0) {\n        ret = collection.migratePromise();\n      }\n      return ret;\n    }).then(() => {\n      runPluginHooks('createRxCollection', {\n        collection,\n        creator: {\n          name,\n          schema,\n          storageInstance,\n          instanceCreationOptions,\n          migrationStrategies,\n          methods,\n          attachments,\n          options,\n          cacheReplacementPolicy,\n          localDocuments,\n          statics\n        }\n      });\n      return collection;\n    })\n    /**\n     * If the collection creation fails,\n     * we yet have to close the storage instances.\n     */.catch(err => {\n      return storageInstance.close().then(() => Promise.reject(err));\n    });\n  });\n}\nexport function isRxCollection(obj) {\n  return obj instanceof RxCollectionBase;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}