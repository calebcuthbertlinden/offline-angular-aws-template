{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { PROMISE_RESOLVE_TRUE } from '../../plugins/utils';\nimport { REPLICATION_STATE_BY_COLLECTION } from '../replication';\nimport { DEFAULT_CLEANUP_POLICY } from './cleanup-helper';\n\n/**\n * Even on multiple databases,\n * the calls to RxStorage().cleanup()\n * must never run in parallel.\n * The cleanup is a background task which should\n * not affect the performance of other, more important tasks.\n */\nvar RXSOTRAGE_CLEANUP_QUEUE = PROMISE_RESOLVE_TRUE;\nexport function startCleanupForRxCollection(_x) {\n  return _startCleanupForRxCollection.apply(this, arguments);\n}\n\n/**\n * Runs the cleanup for a single RxCollection\n */\nfunction _startCleanupForRxCollection() {\n  _startCleanupForRxCollection = _asyncToGenerator(function* (rxCollection) {\n    var rxDatabase = rxCollection.database;\n    var cleanupPolicy = Object.assign({}, DEFAULT_CLEANUP_POLICY, rxDatabase.cleanupPolicy ? rxDatabase.cleanupPolicy : {});\n\n    /**\n     * Wait until minimumDatabaseInstanceAge is reached\n     * or collection is destroyed.\n     */\n    yield rxCollection.promiseWait(cleanupPolicy.minimumCollectionAge);\n    if (rxCollection.destroyed) {\n      return;\n    }\n    if (cleanupPolicy.waitForLeadership) {\n      yield rxDatabase.waitForLeadership();\n    }\n    if (rxCollection.destroyed) {\n      return;\n    }\n\n    // initially cleanup the collection\n    yield cleanupRxCollection(rxCollection, cleanupPolicy);\n\n    /**\n     * Afterwards we listen to deletes\n     * and only re-run the cleanup after\n     * minimumDeletedTime is reached.\n     */\n    yield runCleanupAfterDelete(rxCollection, cleanupPolicy);\n  });\n  return _startCleanupForRxCollection.apply(this, arguments);\n}\nexport function cleanupRxCollection(_x2, _x3) {\n  return _cleanupRxCollection.apply(this, arguments);\n}\nfunction _cleanupRxCollection() {\n  _cleanupRxCollection = _asyncToGenerator(function* (rxCollection, cleanupPolicy) {\n    var rxDatabase = rxCollection.database;\n    var storageInstance = rxCollection.storageInstance;\n\n    // run cleanup() until it returns true\n    var isDone = false;\n    while (!isDone && !rxCollection.destroyed) {\n      if (cleanupPolicy.awaitReplicationsInSync) {\n        var replicationStates = REPLICATION_STATE_BY_COLLECTION.get(rxCollection);\n        if (replicationStates) {\n          yield Promise.all(replicationStates.map(replicationState => {\n            if (!replicationState.isStopped()) {\n              return replicationState.awaitInSync();\n            }\n          }));\n        }\n      }\n      yield rxDatabase.requestIdlePromise();\n      if (rxCollection.destroyed) {\n        return;\n      }\n      RXSOTRAGE_CLEANUP_QUEUE = RXSOTRAGE_CLEANUP_QUEUE.then(() => {\n        if (rxCollection.destroyed) {\n          return true;\n        }\n        return storageInstance.cleanup(cleanupPolicy.minimumDeletedTime);\n      });\n      isDone = yield RXSOTRAGE_CLEANUP_QUEUE;\n    }\n  });\n  return _cleanupRxCollection.apply(this, arguments);\n}\nexport function runCleanupAfterDelete(_x4, _x5) {\n  return _runCleanupAfterDelete.apply(this, arguments);\n}\nfunction _runCleanupAfterDelete() {\n  _runCleanupAfterDelete = _asyncToGenerator(function* (rxCollection, cleanupPolicy) {\n    while (!rxCollection.destroyed) {\n      yield rxCollection.promiseWait(cleanupPolicy.runEach);\n      if (rxCollection.destroyed) {\n        return;\n      }\n      yield cleanupRxCollection(rxCollection, cleanupPolicy);\n    }\n  });\n  return _runCleanupAfterDelete.apply(this, arguments);\n}","map":{"version":3,"names":["PROMISE_RESOLVE_TRUE","REPLICATION_STATE_BY_COLLECTION","DEFAULT_CLEANUP_POLICY","RXSOTRAGE_CLEANUP_QUEUE","startCleanupForRxCollection","_x","_startCleanupForRxCollection","apply","arguments","_asyncToGenerator","rxCollection","rxDatabase","database","cleanupPolicy","Object","assign","promiseWait","minimumCollectionAge","destroyed","waitForLeadership","cleanupRxCollection","runCleanupAfterDelete","_x2","_x3","_cleanupRxCollection","storageInstance","isDone","awaitReplicationsInSync","replicationStates","get","Promise","all","map","replicationState","isStopped","awaitInSync","requestIdlePromise","then","cleanup","minimumDeletedTime","_x4","_x5","_runCleanupAfterDelete","runEach"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/plugins/cleanup/cleanup.js"],"sourcesContent":["import { PROMISE_RESOLVE_TRUE } from '../../plugins/utils';\nimport { REPLICATION_STATE_BY_COLLECTION } from '../replication';\nimport { DEFAULT_CLEANUP_POLICY } from './cleanup-helper';\n\n/**\n * Even on multiple databases,\n * the calls to RxStorage().cleanup()\n * must never run in parallel.\n * The cleanup is a background task which should\n * not affect the performance of other, more important tasks.\n */\nvar RXSOTRAGE_CLEANUP_QUEUE = PROMISE_RESOLVE_TRUE;\nexport async function startCleanupForRxCollection(rxCollection) {\n  var rxDatabase = rxCollection.database;\n  var cleanupPolicy = Object.assign({}, DEFAULT_CLEANUP_POLICY, rxDatabase.cleanupPolicy ? rxDatabase.cleanupPolicy : {});\n\n  /**\n   * Wait until minimumDatabaseInstanceAge is reached\n   * or collection is destroyed.\n   */\n  await rxCollection.promiseWait(cleanupPolicy.minimumCollectionAge);\n  if (rxCollection.destroyed) {\n    return;\n  }\n  if (cleanupPolicy.waitForLeadership) {\n    await rxDatabase.waitForLeadership();\n  }\n  if (rxCollection.destroyed) {\n    return;\n  }\n\n  // initially cleanup the collection\n  await cleanupRxCollection(rxCollection, cleanupPolicy);\n\n  /**\n   * Afterwards we listen to deletes\n   * and only re-run the cleanup after\n   * minimumDeletedTime is reached.\n   */\n  await runCleanupAfterDelete(rxCollection, cleanupPolicy);\n}\n\n/**\n * Runs the cleanup for a single RxCollection\n */\nexport async function cleanupRxCollection(rxCollection, cleanupPolicy) {\n  var rxDatabase = rxCollection.database;\n  var storageInstance = rxCollection.storageInstance;\n\n  // run cleanup() until it returns true\n  var isDone = false;\n  while (!isDone && !rxCollection.destroyed) {\n    if (cleanupPolicy.awaitReplicationsInSync) {\n      var replicationStates = REPLICATION_STATE_BY_COLLECTION.get(rxCollection);\n      if (replicationStates) {\n        await Promise.all(replicationStates.map(replicationState => {\n          if (!replicationState.isStopped()) {\n            return replicationState.awaitInSync();\n          }\n        }));\n      }\n    }\n    await rxDatabase.requestIdlePromise();\n    if (rxCollection.destroyed) {\n      return;\n    }\n    RXSOTRAGE_CLEANUP_QUEUE = RXSOTRAGE_CLEANUP_QUEUE.then(() => {\n      if (rxCollection.destroyed) {\n        return true;\n      }\n      return storageInstance.cleanup(cleanupPolicy.minimumDeletedTime);\n    });\n    isDone = await RXSOTRAGE_CLEANUP_QUEUE;\n  }\n}\nexport async function runCleanupAfterDelete(rxCollection, cleanupPolicy) {\n  while (!rxCollection.destroyed) {\n    await rxCollection.promiseWait(cleanupPolicy.runEach);\n    if (rxCollection.destroyed) {\n      return;\n    }\n    await cleanupRxCollection(rxCollection, cleanupPolicy);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}