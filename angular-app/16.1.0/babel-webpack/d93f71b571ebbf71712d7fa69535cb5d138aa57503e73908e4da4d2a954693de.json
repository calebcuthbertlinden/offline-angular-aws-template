{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { InjectionToken } from '@angular/core';\nimport { createRxDatabase, lastOfArray } from 'rxdb';\nimport { wrappedKeyEncryptionCryptoJsStorage } from 'rxdb/plugins/encryption-crypto-js';\nimport { getRxStorageDexie } from 'rxdb/plugins/storage-dexie';\nimport { learnerSchema } from '../schema/identity';\nimport { nuggetSchema } from '../schema/nugget';\nimport { Subject } from 'rxjs';\nimport { replicateRxCollection } from 'rxdb/plugins/replication';\nimport { logSchema } from '../schema/log';\nimport * as i0 from \"@angular/core\";\nexport const APP_STORAGE = new InjectionToken('APP_STORAGE');\nexport const IDENTITY_TABLE = 'identity';\nexport const NUGGET_TABLE = 'nugget';\nexport const LOG_TABLE = 'log';\nclass LocalStorageService {\n  constructor() {\n    this.pullStream$ = new Subject();\n  }\n  init() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this._database = yield createRxDatabase({\n        name: 'offlinestore' + new Date().getTime(),\n        storage: wrappedKeyEncryptionCryptoJsStorage({\n          storage: getRxStorageDexie()\n        }),\n        password: 'ThisIsAVeryStrongPasswordForEncryption',\n        cleanupPolicy: {\n          /**\n           * The minimum time in milliseconds for how long a document has to be deleted before it is purged by the cleanup.\n           * [default=one month]\n           */\n          minimumDeletedTime: 1000 * 60 * 60 * 24 * 31,\n          /**\n           * The minimum amount of that that the RxCollection must have existed.\n           * This ensures that at the initial page load, more important tasks are not slowed down because a cleanup process is running.\n           * [default=60 seconds]\n           */\n          minimumCollectionAge: 1000 * 60,\n          /**\n           * After the initial cleanup is done, a new cleanup is started after [runEach] milliseconds\n           * [default=5 minutes]\n           */\n          runEach: 1000 * 60 * 5,\n          /**\n           * If set to true, RxDB will await all running replications to not have a replication cycle running.\n           * This ensures we do not remove deleted documents when they might not have already been replicated.\n           * [default=true]\n           */\n          awaitReplicationsInSync: true\n        }\n      });\n      yield _this.createCollection({\n        identity: {\n          schema: learnerSchema\n        }\n      });\n      yield _this.createCollection({\n        nugget: {\n          schema: nuggetSchema\n        }\n      });\n      yield _this.createCollection({\n        nugget: {\n          log: logSchema\n        }\n      });\n    })();\n  }\n  createCollection(collection) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2._database.addCollections(collection);\n    })();\n  }\n  sync(collection) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      console.log('Syncing from server to client, and then client updates back to server');\n      const replicationState = replicateRxCollection({\n        collection: _this3._database[collection],\n        /**\n         * An id for the replication to identify it and so that RxDB is able to resume the replication on app reload.\n         * If you replicate with a remote server, it is recommended to put the server url into the replicationIdentifier.\n         */\n        replicationIdentifier: 'my-rest-replication-to-prod/v1/sync',\n        /**\n         * By default it will do an ongoing realtime replication.\n         * By settings live: false the replication will run once until the local state is in sync with the remote state, then it will cancel itself.\n         * (optional), default is true.\n         */\n        live: false,\n        /**\n         * Time in milliseconds after when a failed backend request has to be retried.\n         * This time will be skipped if a offline->online switch is detected via navigator.onLine\n         * (optional), default is 5 seconds.\n         */\n        retryTime: 600 * 1000,\n        /**\n         * When multiInstance is true, like when you use RxDB in multiple browser tabs, the replication should always run in only one of the open browser tabs.\n         * If waitForLeadership is true, it will wait until the current instance is leader.\n         * If waitForLeadership is false, it will start replicating, even if it is not leader.\n         * [default=true]\n         */\n        waitForLeadership: true,\n        /**\n         * If this is set to false, the replication will not start automatically but will wait for replicationState.start() being called.\n         * (optional), default is true\n         */\n        autoStart: true,\n        /**\n         * Custom deleted field, the boolean property of the document data that marks a document as being deleted.\n         * If your backend uses a different fieldname then '_deleted', set the fieldname here.\n         * RxDB will still store the documents internally with '_deleted', setting this field only maps the data on the data layer.\n         *\n         * If a custom deleted field contains a non-boolean value, the deleted state\n         * of the documents depends on if the value is truthy or not. So instead of providing a boolean * * deleted value, you could also work with using a 'deletedAt' timestamp instead.\n         *\n         * [default='_deleted']\n         */\n        deletedField: '_deleted',\n        /**\n         * Optional,\n         * only needed when you want to replicate local changes to the remote instance.\n         */\n        push: {\n          /**\n           * Push handler\n           */\n          handler(docs) {\n            return _asyncToGenerator(function* () {\n              /**\n               * Push the local documents to a remote REST server.\n               */\n              const rawResponse = yield fetch(`https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync/${collection}`, {\n                method: 'POST',\n                headers: {\n                  'Accept': 'application/json',\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                  docs\n                })\n              });\n              /**\n               * Contains an array with all conflicts that appeared during this push.\n               * If there were no conflicts, return an empty array.\n               */\n              const response = yield rawResponse.json();\n              return response;\n            })();\n          },\n          /**\n           * Batch size, optional\n           * Defines how many documents will be given to the push handler at once.\n           */\n          batchSize: 5,\n          /**\n           * Modifies all documents before they are given to the push handler.\n           * Can be used to swap out a custom deleted flag instead of the '_deleted' field.\n           * (optional)\n           */\n          modifier: d => d\n        },\n        /**\n         * Optional,\n         * only needed when you want to replicate remote changes to the local state.\n         */\n        pull: {\n          /**\n           * Pull handler\n           */\n          handler(lastCheckpoint, batchSize) {\n            return _asyncToGenerator(function* () {\n              const minTimestamp = 0;\n              // const minTimestamp = lastCheckpoint ? lastCheckpoint.updatedAt : 0;\n              /**\n               * In this example we replicate with a remote REST server\n               */\n              const response = yield fetch(`https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync/${collection}?minUpdatedAt=${minTimestamp}&limit=${batchSize}`);\n              const documentsFromRemote = yield response.json();\n              return {\n                /**\n                 * Contains the pulled documents from the remote.\n                 * Notice: If documentsFromRemote.length < batchSize,\n                 * then RxDB assumes that there are no more un-replicated documents\n                 * on the backend, so the replication will switch to 'Event observation' mode.\n                 */\n                documents: documentsFromRemote,\n                /**\n                 * The last checkpoint of the returned documents.\n                 * On the next call to the pull handler,\n                 * this checkpoint will be passed as 'lastCheckpoint'\n                 */\n                checkpoint: documentsFromRemote.length === 0 ? lastCheckpoint : {\n                  id: \"\",\n                  updatedAt: \"\"\n                }\n              };\n            })();\n          },\n          batchSize: 10,\n          /**\n           * Modifies all documents after they have been pulled\n           * but before they are used by RxDB.\n           * (optional)\n           */\n          modifier: d => d,\n          /**\n           * Stream of the backend document writes.\n           * See below.\n           * You only need a stream$ when you have set live=true\n           */\n          stream$: _this3.pullStream$.asObservable()\n        }\n      });\n      // emits each document that was received from the remote\n      replicationState.received$.subscribe(doc => {});\n      // emits each document that was send to the remote\n      replicationState.send$.subscribe(doc => console.dir(doc));\n      // emits all errors that happen when running the push- & pull-handlers.\n      replicationState.error$.subscribe(error => console.dir(error));\n      // emits true when the replication was canceled, false when not.\n      replicationState.canceled$.subscribe(bool => console.dir(bool));\n      // emits true when a replication cycle is running, false when not.\n      replicationState.active$.subscribe(bool => console.dir(bool));\n    })();\n  }\n  syncPush(collection, path = \"\") {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      console.log('Syncing client to server');\n      const replicationState = replicateRxCollection({\n        collection: _this4._database[collection],\n        replicationIdentifier: 'sync-local-to-prod-v1-sync-push',\n        live: false,\n        retryTime: 600 * 1000,\n        waitForLeadership: true,\n        autoStart: true,\n        deletedField: '_deleted',\n        push: {\n          handler(docs) {\n            return _asyncToGenerator(function* () {\n              const rawResponse = yield fetch(`https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync/${collection}`, {\n                method: 'POST',\n                headers: {\n                  'Accept': 'application/json',\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                  docs\n                })\n              });\n              const response = yield rawResponse.json();\n              return response;\n            })();\n          },\n          batchSize: 5,\n          modifier: d => d\n        }\n      });\n      replicationState.received$.subscribe(doc => console.log(`SYNC received`));\n      replicationState.send$.subscribe(doc => console.log(`SYNC send`));\n      replicationState.error$.subscribe(error => console.dir(`SYNC cancelled ${error}`));\n      replicationState.canceled$.subscribe(bool => console.dir(`SYNC cancelled ${bool}`));\n      replicationState.active$.subscribe(bool => console.log(`SYNC active ${bool}`));\n    })();\n  }\n  syncPull(collection) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      console.log('Syncing server to client');\n      const replicationState = replicateRxCollection({\n        collection: _this5._database[collection],\n        replicationIdentifier: 'sync-prod-v1-sync-to-local',\n        live: false,\n        retryTime: 600 * 1000,\n        waitForLeadership: true,\n        autoStart: true,\n        deletedField: '_deleted',\n        pull: {\n          handler(lastCheckpoint, batchSize) {\n            return _asyncToGenerator(function* () {\n              const minTimestamp = lastCheckpoint ? lastCheckpoint.updatedAt : 0;\n              const response = yield fetch(`https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync/${collection}?minUpdatedAt=${minTimestamp}&limit=${batchSize}`);\n              const documentsFromRemote = yield response.json();\n              const checkpoint = lastOfArray(documentsFromRemote);\n              return {\n                documents: documentsFromRemote,\n                checkpoint: documentsFromRemote.length === 0 ? lastCheckpoint : {\n                  updatedAt: checkpoint.updatedAt\n                }\n              };\n            })();\n          },\n          batchSize: 100,\n          modifier: d => d\n        }\n      });\n      replicationState.received$.subscribe(doc => console.log(`SYNC received`));\n      replicationState.send$.subscribe(doc => console.log(`SYNC send`));\n      replicationState.error$.subscribe(error => console.dir(`SYNC cancelled ${error}`));\n      replicationState.canceled$.subscribe(bool => console.dir(`SYNC cancelled ${bool}`));\n      replicationState.active$.subscribe(bool => console.log(`SYNC active ${bool}`));\n    })();\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Getter for database\n   */\n  get database() {\n    return this._database;\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be inserted.\n   * @param body - The data object representing the record to be inserted.\n   * @returns A Promise that resolves to void once the record has been successfully inserted.\n   *\n   * @example\n   * await post('orders', { id: 1, product: 'Phone', quantity: 2 });\n   * // Inserts a new record into the 'orders' table with the provided data.\n   */\n  post(table, body) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      yield _this6.database[table].insert(body);\n    })();\n  }\n  /**\n   * Retrieves a record from the specified table in the local offline storage based on the provided ID.\n   *\n   * @param table - The name of the table from which the record will be retrieved.\n   * @param id - The ID of the record to be retrieved.\n   * @returns A Promise that resolves to the retrieved record.\n   *\n   * @example\n   * const order = await get('orders', '456');\n   * // Retrieves the record with ID '456' from the 'orders' table.\n   */\n  get(table, id) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return _this7.database[table].findOne(id).exec();\n    })();\n  }\n  getCollection(table) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return _this8.database[table].find().exec();\n    })();\n  }\n  /**\n   * Retrieves an Observable stream of records from the specified table in the local offline storage.\n   *\n   * @param table - The name of the table from which the records will be retrieved.\n   * @returns An Observable that emits the records from the specified table.\n   *\n   * @example\n   * // Example usage:\n   * const users$ = get$('users');\n   * users$.subscribe((users) => {\n   *   console.log(users);\n   * });\n   * // Retrieves the records from the 'users' table and logs the emitted records whenever there is an update.\n   */\n  get$(table) {\n    return this.database[table].$;\n  }\n  /**\n   * Updates an existing record or inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be updated or inserted.\n   * @param body - The data object representing the record to be updated or inserted.\n   * @returns A Promise that resolves to void once the record has been successfully updated or inserted.\n   *\n   * @example\n   * await put('users', { id: '123', name: 'John Doe', age: 30 });\n   * // Updates the record with ID '123' in the 'users' table if it exists, or inserts a new record with the provided data if the record doesn't exist.\n   */\n  put(table, body) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      yield _this9.database[table].upsert(body);\n    })();\n  }\n  /**\n   * DELETE\n   */\n  delete() {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * REMOVE\n   */\n  deleteCollection(table) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      yield _this10.database[table].remove();\n    })();\n  }\n  /**\n   * Destroy\n   */\n  destroyCollection(table) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      yield _this11.database[table].destroy();\n    })();\n  }\n  destroy() {\n    this.database.remove();\n  }\n}\nLocalStorageService.ɵfac = function LocalStorageService_Factory(t) {\n  return new (t || LocalStorageService)();\n};\nLocalStorageService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: LocalStorageService,\n  factory: LocalStorageService.ɵfac,\n  providedIn: 'root'\n});\nexport { LocalStorageService };","map":{"version":3,"names":["InjectionToken","createRxDatabase","lastOfArray","wrappedKeyEncryptionCryptoJsStorage","getRxStorageDexie","learnerSchema","nuggetSchema","Subject","replicateRxCollection","logSchema","APP_STORAGE","IDENTITY_TABLE","NUGGET_TABLE","LOG_TABLE","LocalStorageService","constructor","pullStream$","init","_this","_asyncToGenerator","_database","name","Date","getTime","storage","password","cleanupPolicy","minimumDeletedTime","minimumCollectionAge","runEach","awaitReplicationsInSync","createCollection","identity","schema","nugget","log","collection","_this2","addCollections","sync","_this3","console","replicationState","replicationIdentifier","live","retryTime","waitForLeadership","autoStart","deletedField","push","handler","docs","rawResponse","fetch","method","headers","body","JSON","stringify","response","json","batchSize","modifier","d","pull","lastCheckpoint","minTimestamp","documentsFromRemote","documents","checkpoint","length","id","updatedAt","stream$","asObservable","received$","subscribe","doc","send$","dir","error$","error","canceled$","bool","active$","syncPush","path","_this4","syncPull","_this5","database","post","table","_this6","insert","get","_this7","findOne","exec","getCollection","_this8","find","get$","$","put","_this9","upsert","delete","deleteCollection","_this10","remove","destroyCollection","_this11","destroy","factory","ɵfac","providedIn"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/src/app/repository/local-storage/local-storage.ts"],"sourcesContent":["import { Injectable, InjectionToken } from '@angular/core';\nimport { RxDatabase, RxReplicationPullStreamItem, createRxDatabase, lastOfArray } from 'rxdb';\nimport { wrappedKeyEncryptionCryptoJsStorage } from 'rxdb/plugins/encryption-crypto-js';\nimport { getRxStorageDexie } from 'rxdb/plugins/storage-dexie';\nimport { learnerSchema } from '../schema/identity';\nimport { nuggetSchema } from '../schema/nugget';\nimport { Observable, Subject } from 'rxjs';\nimport { replicateRxCollection } from 'rxdb/plugins/replication';\nimport { LocalStorage } from './local-storage-interface';\nimport { Checkpoint } from './checkpoint';\nimport { logSchema } from '../schema/log';\n\nexport const APP_STORAGE = new InjectionToken<any>('APP_STORAGE');\nexport const IDENTITY_TABLE = 'identity';\nexport const NUGGET_TABLE = 'nugget';\nexport const LOG_TABLE = 'log';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocalStorageService implements LocalStorage {\n  private _database: RxDatabase | undefined;\n  private pullStream$ = new Subject<RxReplicationPullStreamItem<any, any>>();\n\n  constructor() {}\n\n  async init() {\n    this._database = await createRxDatabase({\n      name: 'offlinestore'+ new Date().getTime(),\n      storage: wrappedKeyEncryptionCryptoJsStorage({\n        storage: getRxStorageDexie()\n      }),\n      password: 'ThisIsAVeryStrongPasswordForEncryption',\n      cleanupPolicy: {\n        /**\n         * The minimum time in milliseconds for how long a document has to be deleted before it is purged by the cleanup.\n         * [default=one month]\n         */\n        minimumDeletedTime: 1000 * 60 * 60 * 24 * 31, // one month,\n        /**\n         * The minimum amount of that that the RxCollection must have existed.\n         * This ensures that at the initial page load, more important tasks are not slowed down because a cleanup process is running.\n         * [default=60 seconds]\n         */\n        minimumCollectionAge: 1000 * 60, // 60 seconds\n        /**\n         * After the initial cleanup is done, a new cleanup is started after [runEach] milliseconds\n         * [default=5 minutes]\n         */\n        runEach: 1000 * 60 * 5, // 5 minutes\n        /**\n         * If set to true, RxDB will await all running replications to not have a replication cycle running.\n         * This ensures we do not remove deleted documents when they might not have already been replicated.\n         * [default=true]\n         */\n        awaitReplicationsInSync: true,\n      }\n    });\n\n    await this.createCollection({identity: {\n      schema: learnerSchema\n    }})\n\n    await this.createCollection({nugget: {\n      schema: nuggetSchema\n    }})\n\n    await this.createCollection({nugget: {\n      log: logSchema\n    }})\n  }\n\n  async createCollection(collection:any) {\n    await this._database!.addCollections(collection);\n  }\n\n  async sync(collection:string) {\n    console.log('Syncing from server to client, and then client updates back to server');\n    const replicationState = replicateRxCollection({\n      collection: this._database![collection],\n      /**\n       * An id for the replication to identify it and so that RxDB is able to resume the replication on app reload.\n       * If you replicate with a remote server, it is recommended to put the server url into the replicationIdentifier.\n       */\n      replicationIdentifier: 'my-rest-replication-to-prod/v1/sync',\n      /**\n       * By default it will do an ongoing realtime replication.\n       * By settings live: false the replication will run once until the local state is in sync with the remote state, then it will cancel itself.\n       * (optional), default is true.\n       */\n      live: false,\n      /**\n       * Time in milliseconds after when a failed backend request has to be retried.\n       * This time will be skipped if a offline->online switch is detected via navigator.onLine\n       * (optional), default is 5 seconds.\n       */\n      retryTime: 600 * 1000,\n      /**\n       * When multiInstance is true, like when you use RxDB in multiple browser tabs, the replication should always run in only one of the open browser tabs.\n       * If waitForLeadership is true, it will wait until the current instance is leader.\n       * If waitForLeadership is false, it will start replicating, even if it is not leader.\n       * [default=true]\n       */\n      waitForLeadership: true,\n      /**\n       * If this is set to false, the replication will not start automatically but will wait for replicationState.start() being called.\n       * (optional), default is true\n       */\n      autoStart: true,\n\n      /**\n       * Custom deleted field, the boolean property of the document data that marks a document as being deleted.\n       * If your backend uses a different fieldname then '_deleted', set the fieldname here.\n       * RxDB will still store the documents internally with '_deleted', setting this field only maps the data on the data layer.\n       *\n       * If a custom deleted field contains a non-boolean value, the deleted state\n       * of the documents depends on if the value is truthy or not. So instead of providing a boolean * * deleted value, you could also work with using a 'deletedAt' timestamp instead.\n       *\n       * [default='_deleted']\n       */\n      deletedField: '_deleted',\n\n      /**\n       * Optional,\n       * only needed when you want to replicate local changes to the remote instance.\n       */\n      push: {\n          /**\n           * Push handler\n           */\n          async handler(docs) {\n              /**\n               * Push the local documents to a remote REST server.\n               */\n              const rawResponse = await fetch(`https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync/${collection}`, {\n                  method: 'POST',\n                  headers: {\n                      'Accept': 'application/json',\n                      'Content-Type': 'application/json'\n                  },\n                  body: JSON.stringify({ docs })\n              });\n              /**\n               * Contains an array with all conflicts that appeared during this push.\n               * If there were no conflicts, return an empty array.\n               */\n              const response = await rawResponse.json();\n              return response;\n          },\n          /**\n           * Batch size, optional\n           * Defines how many documents will be given to the push handler at once.\n           */\n          batchSize: 5,\n          /**\n           * Modifies all documents before they are given to the push handler.\n           * Can be used to swap out a custom deleted flag instead of the '_deleted' field.\n           * (optional)\n           */\n          modifier: d => d\n      },\n      /**\n       * Optional,\n       * only needed when you want to replicate remote changes to the local state.\n       */\n      pull: {\n          /**\n           * Pull handler\n           */\n          async handler(lastCheckpoint, batchSize) {\n              const minTimestamp = 0;\n              // const minTimestamp = lastCheckpoint ? lastCheckpoint.updatedAt : 0;\n              /**\n               * In this example we replicate with a remote REST server\n               */\n              const response = await fetch(\n                  `https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync/${collection}?minUpdatedAt=${minTimestamp}&limit=${batchSize}`\n              );\n              const documentsFromRemote = await response.json();\n              return {\n                  /**\n                   * Contains the pulled documents from the remote.\n                   * Notice: If documentsFromRemote.length < batchSize,\n                   * then RxDB assumes that there are no more un-replicated documents\n                   * on the backend, so the replication will switch to 'Event observation' mode.\n                   */\n                  documents: documentsFromRemote,\n                  /**\n                   * The last checkpoint of the returned documents.\n                   * On the next call to the pull handler,\n                   * this checkpoint will be passed as 'lastCheckpoint'\n                   */\n                  checkpoint: documentsFromRemote.length === 0 ? lastCheckpoint : {\n                      id: \"\",\n                      updatedAt: \"\"\n                  }\n              };\n          },\n          batchSize: 10,\n          /**\n           * Modifies all documents after they have been pulled\n           * but before they are used by RxDB.\n           * (optional)\n           */\n          modifier: d => d,\n          /**\n           * Stream of the backend document writes.\n           * See below.\n           * You only need a stream$ when you have set live=true\n           */\n          stream$: this.pullStream$.asObservable()\n      },\n    });\n\n\n\n    // emits each document that was received from the remote\n    replicationState.received$.subscribe(doc => {});\n\n    // emits each document that was send to the remote\n    replicationState.send$.subscribe(doc => console.dir(doc));\n\n    // emits all errors that happen when running the push- & pull-handlers.\n    replicationState.error$.subscribe(error => console.dir(error));\n\n    // emits true when the replication was canceled, false when not.\n    replicationState.canceled$.subscribe(bool => console.dir(bool));\n\n    // emits true when a replication cycle is running, false when not.\n    replicationState.active$.subscribe(bool => console.dir(bool));\n  }\n\n  async syncPush(collection:string, path:string = \"\") {\n    console.log('Syncing client to server');\n    const replicationState = replicateRxCollection({\n      collection: this._database![collection],\n      replicationIdentifier: 'sync-local-to-prod-v1-sync-push',\n      live: false,\n      retryTime: 600 * 1000,\n      waitForLeadership: true,\n      autoStart: true,\n      deletedField: '_deleted',\n      push: {\n          async handler(docs) {\n              const rawResponse = await fetch(`https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync/${collection}`, {\n                  method: 'POST',\n                  headers: {\n                      'Accept': 'application/json',\n                      'Content-Type': 'application/json'\n                  },\n                  body: JSON.stringify({ docs })\n              });\n              const response = await rawResponse.json();\n              return response;\n          },\n          batchSize: 5,\n          modifier: d => d\n      },\n    });\n\n    replicationState.received$.subscribe(doc => console.log(`SYNC received`));\n    replicationState.send$.subscribe(doc => console.log(`SYNC send`));\n    replicationState.error$.subscribe(error => console.dir(`SYNC cancelled ${error}`));\n    replicationState.canceled$.subscribe(bool => console.dir(`SYNC cancelled ${bool}`));\n    replicationState.active$.subscribe(bool => console.log(`SYNC active ${bool}`));\n  }\n\n  async syncPull(collection:string) {\n    console.log('Syncing server to client');\n    const replicationState = replicateRxCollection({\n      collection: this._database![collection],\n      replicationIdentifier: 'sync-prod-v1-sync-to-local',\n      live: false,\n      retryTime: 600 * 1000,\n      waitForLeadership: true,\n      autoStart: true,\n      deletedField: '_deleted',\n      pull: {\n        async handler(lastCheckpoint: Checkpoint, batchSize) {\n            const minTimestamp = lastCheckpoint ? lastCheckpoint.updatedAt : 0;\n            const response = await fetch(\n                `https://brwpjqq55e.execute-api.eu-west-1.amazonaws.com/prod/v1/sync/${collection}?minUpdatedAt=${minTimestamp}&limit=${batchSize}`\n            );\n            const documentsFromRemote = await response.json();\n            const checkpoint = lastOfArray(documentsFromRemote) as Checkpoint;\n            return {\n                documents: documentsFromRemote,\n                checkpoint: documentsFromRemote.length === 0 ? lastCheckpoint : {\n                  updatedAt: checkpoint.updatedAt\n                }\n            };\n        },\n        batchSize: 100,\n        modifier: d => d,\n      },\n    });\n\n    replicationState.received$.subscribe(doc => console.log(`SYNC received`));\n    replicationState.send$.subscribe(doc => console.log(`SYNC send`));\n    replicationState.error$.subscribe(error => console.dir(`SYNC cancelled ${error}`));\n    replicationState.canceled$.subscribe(bool => console.dir(`SYNC cancelled ${bool}`));\n    replicationState.active$.subscribe(bool => console.log(`SYNC active ${bool}`));\n  }\n\n  // -----------------------------------------------------------------------------------------------------\n  // @ Accessors\n  // -----------------------------------------------------------------------------------------------------\n\n  /**\n   * Getter for database\n   */\n  get database(): RxDatabase {\n    return this._database as RxDatabase;\n  }\n\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n\n  /**\n   * Inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be inserted.\n   * @param body - The data object representing the record to be inserted.\n   * @returns A Promise that resolves to void once the record has been successfully inserted.\n   *\n   * @example\n   * await post('orders', { id: 1, product: 'Phone', quantity: 2 });\n   * // Inserts a new record into the 'orders' table with the provided data.\n   */\n  async post(table: string, body: any): Promise<void> {\n    await this.database[table].insert(body);\n  }\n\n  /**\n   * Retrieves a record from the specified table in the local offline storage based on the provided ID.\n   *\n   * @param table - The name of the table from which the record will be retrieved.\n   * @param id - The ID of the record to be retrieved.\n   * @returns A Promise that resolves to the retrieved record.\n   *\n   * @example\n   * const order = await get('orders', '456');\n   * // Retrieves the record with ID '456' from the 'orders' table.\n   */\n  async get(table: string, id: string): Promise<any> {\n    return this.database[table].findOne(id).exec();\n  }\n\n  async getCollection(table: string): Promise<any> {\n    return this.database[table].find().exec();\n  }\n\n\n  /**\n   * Retrieves an Observable stream of records from the specified table in the local offline storage.\n   *\n   * @param table - The name of the table from which the records will be retrieved.\n   * @returns An Observable that emits the records from the specified table.\n   *\n   * @example\n   * // Example usage:\n   * const users$ = get$('users');\n   * users$.subscribe((users) => {\n   *   console.log(users);\n   * });\n   * // Retrieves the records from the 'users' table and logs the emitted records whenever there is an update.\n   */\n  get$(table: string): Observable<any> {\n    return this.database[table].$;\n  }\n\n  /**\n   * Updates an existing record or inserts a new record into the specified table in the local offline storage.\n   *\n   * @param table - The name of the table where the record will be updated or inserted.\n   * @param body - The data object representing the record to be updated or inserted.\n   * @returns A Promise that resolves to void once the record has been successfully updated or inserted.\n   *\n   * @example\n   * await put('users', { id: '123', name: 'John Doe', age: 30 });\n   * // Updates the record with ID '123' in the 'users' table if it exists, or inserts a new record with the provided data if the record doesn't exist.\n   */\n  async put(table: string, body: any): Promise<void> {\n    await this.database[table].upsert(body);\n  }\n\n\n  /**\n   * DELETE\n   */\n  async delete(): Promise<void> {\n\n  }\n\n  /**\n   * REMOVE\n   */\n  async deleteCollection(table: string): Promise<void> {\n    await this.database[table].remove();\n  }\n\n  /**\n   * Destroy\n   */\n  async destroyCollection(table: string): Promise<void> {\n    await this.database[table].destroy();\n  }\n\n  destroy(): void {\n    this.database.remove()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}