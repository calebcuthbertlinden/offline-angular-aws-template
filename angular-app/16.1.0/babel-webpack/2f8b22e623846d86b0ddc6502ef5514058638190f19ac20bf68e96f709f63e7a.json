{"ast":null,"code":"/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\n\nimport { filter } from 'rxjs/operators';\nexport var ChangeEventBuffer = /*#__PURE__*/function () {\n  /**\n   * array with changeEvents\n   * starts with oldest known event, ends with newest\n   */\n\n  function ChangeEventBuffer(collection) {\n    this.subs = [];\n    this.limit = 100;\n    this.counter = 0;\n    this.eventCounterMap = new WeakMap();\n    this.buffer = [];\n    this.collection = collection;\n    this.subs.push(this.collection.$.pipe(filter(cE => !cE.isLocal)).subscribe(cE => this._handleChangeEvent(cE)));\n  }\n  var _proto = ChangeEventBuffer.prototype;\n  _proto._handleChangeEvent = function _handleChangeEvent(changeEvent) {\n    this.counter++;\n    this.buffer.push(changeEvent);\n    this.eventCounterMap.set(changeEvent, this.counter);\n    while (this.buffer.length > this.limit) {\n      this.buffer.shift();\n    }\n  }\n\n  /**\n   * gets the array-index for the given pointer\n   * @return arrayIndex which can be used to iterate from there. If null, pointer is out of lower bound\n   */;\n  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {\n    var oldestEvent = this.buffer[0];\n    var oldestCounter = this.eventCounterMap.get(oldestEvent);\n    if (pointer < oldestCounter) return null; // out of bounds\n\n    var rest = pointer - oldestCounter;\n    return rest;\n  }\n\n  /**\n   * get all changeEvents which came in later than the pointer-event\n   * @return array with change-events. If null, pointer out of bounds\n   */;\n  _proto.getFrom = function getFrom(pointer) {\n    var ret = [];\n    var currentIndex = this.getArrayIndexByPointer(pointer);\n    if (currentIndex === null)\n      // out of bounds\n      return null;\n    while (true) {\n      var nextEvent = this.buffer[currentIndex];\n      currentIndex++;\n      if (!nextEvent) {\n        return ret;\n      } else {\n        ret.push(nextEvent);\n      }\n    }\n  };\n  _proto.runFrom = function runFrom(pointer, fn) {\n    var ret = this.getFrom(pointer);\n    if (ret === null) {\n      throw new Error('out of bounds');\n    } else {\n      ret.forEach(cE => fn(cE));\n    }\n  }\n\n  /**\n   * no matter how many operations are done on one document,\n   * only the last operation has to be checked to calculate the new state\n   * this function reduces the events to the last ChangeEvent of each doc\n   */;\n  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {\n    return changeEvents.slice(0);\n    // TODO the old implementation was wrong\n    // because it did not correctly reassigned the previousData of the changeevents\n    // this should be added to the event-reduce library and not be done in RxDB\n    var docEventMap = {};\n    changeEvents.forEach(changeEvent => {\n      docEventMap[changeEvent.documentId] = changeEvent;\n    });\n    return Object.values(docEventMap);\n  };\n  _proto.destroy = function destroy() {\n    this.subs.forEach(sub => sub.unsubscribe());\n  };\n  return ChangeEventBuffer;\n}();\nexport function createChangeEventBuffer(collection) {\n  return new ChangeEventBuffer(collection);\n}","map":{"version":3,"names":["filter","ChangeEventBuffer","collection","subs","limit","counter","eventCounterMap","WeakMap","buffer","push","$","pipe","cE","isLocal","subscribe","_handleChangeEvent","_proto","prototype","changeEvent","set","length","shift","getArrayIndexByPointer","pointer","oldestEvent","oldestCounter","get","rest","getFrom","ret","currentIndex","nextEvent","runFrom","fn","Error","forEach","reduceByLastOfDoc","changeEvents","slice","docEventMap","documentId","Object","values","destroy","sub","unsubscribe","createChangeEventBuffer"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/change-event-buffer.js"],"sourcesContent":["/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\n\nimport { filter } from 'rxjs/operators';\nexport var ChangeEventBuffer = /*#__PURE__*/function () {\n  /**\n   * array with changeEvents\n   * starts with oldest known event, ends with newest\n   */\n\n  function ChangeEventBuffer(collection) {\n    this.subs = [];\n    this.limit = 100;\n    this.counter = 0;\n    this.eventCounterMap = new WeakMap();\n    this.buffer = [];\n    this.collection = collection;\n    this.subs.push(this.collection.$.pipe(filter(cE => !cE.isLocal)).subscribe(cE => this._handleChangeEvent(cE)));\n  }\n  var _proto = ChangeEventBuffer.prototype;\n  _proto._handleChangeEvent = function _handleChangeEvent(changeEvent) {\n    this.counter++;\n    this.buffer.push(changeEvent);\n    this.eventCounterMap.set(changeEvent, this.counter);\n    while (this.buffer.length > this.limit) {\n      this.buffer.shift();\n    }\n  }\n\n  /**\n   * gets the array-index for the given pointer\n   * @return arrayIndex which can be used to iterate from there. If null, pointer is out of lower bound\n   */;\n  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {\n    var oldestEvent = this.buffer[0];\n    var oldestCounter = this.eventCounterMap.get(oldestEvent);\n    if (pointer < oldestCounter) return null; // out of bounds\n\n    var rest = pointer - oldestCounter;\n    return rest;\n  }\n\n  /**\n   * get all changeEvents which came in later than the pointer-event\n   * @return array with change-events. If null, pointer out of bounds\n   */;\n  _proto.getFrom = function getFrom(pointer) {\n    var ret = [];\n    var currentIndex = this.getArrayIndexByPointer(pointer);\n    if (currentIndex === null)\n      // out of bounds\n      return null;\n    while (true) {\n      var nextEvent = this.buffer[currentIndex];\n      currentIndex++;\n      if (!nextEvent) {\n        return ret;\n      } else {\n        ret.push(nextEvent);\n      }\n    }\n  };\n  _proto.runFrom = function runFrom(pointer, fn) {\n    var ret = this.getFrom(pointer);\n    if (ret === null) {\n      throw new Error('out of bounds');\n    } else {\n      ret.forEach(cE => fn(cE));\n    }\n  }\n\n  /**\n   * no matter how many operations are done on one document,\n   * only the last operation has to be checked to calculate the new state\n   * this function reduces the events to the last ChangeEvent of each doc\n   */;\n  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {\n    return changeEvents.slice(0);\n    // TODO the old implementation was wrong\n    // because it did not correctly reassigned the previousData of the changeevents\n    // this should be added to the event-reduce library and not be done in RxDB\n    var docEventMap = {};\n    changeEvents.forEach(changeEvent => {\n      docEventMap[changeEvent.documentId] = changeEvent;\n    });\n    return Object.values(docEventMap);\n  };\n  _proto.destroy = function destroy() {\n    this.subs.forEach(sub => sub.unsubscribe());\n  };\n  return ChangeEventBuffer;\n}();\nexport function createChangeEventBuffer(collection) {\n  return new ChangeEventBuffer(collection);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}