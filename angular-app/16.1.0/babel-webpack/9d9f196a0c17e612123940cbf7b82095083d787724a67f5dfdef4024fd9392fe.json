{"ast":null,"code":"/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nvar ObliviousSet = /** @class */function () {\n  function ObliviousSet(ttl) {\n    this.ttl = ttl;\n    this.map = new Map();\n    /**\n     * Creating calls to setTimeout() is expensive,\n     * so we only do that if there is not timeout already open.\n     */\n    this._to = false;\n  }\n  ObliviousSet.prototype.has = function (value) {\n    return this.map.has(value);\n  };\n  ObliviousSet.prototype.add = function (value) {\n    var _this = this;\n    this.map.set(value, now());\n    /**\n     * When a new value is added,\n     * start the cleanup at the next tick\n     * to not block the cpu for more important stuff\n     * that might happen.\n     */\n    if (!this._to) {\n      this._to = true;\n      setTimeout(function () {\n        _this._to = false;\n        removeTooOldValues(_this);\n      }, 0);\n    }\n  };\n  ObliviousSet.prototype.clear = function () {\n    this.map.clear();\n  };\n  return ObliviousSet;\n}();\nexport { ObliviousSet };\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(obliviousSet) {\n  var olderThen = now() - obliviousSet.ttl;\n  var iterator = obliviousSet.map[Symbol.iterator]();\n  /**\n   * Because we can assume the new values are added at the bottom,\n   * we start from the top and stop as soon as we reach a non-too-old value.\n   */\n  while (true) {\n    var next = iterator.next().value;\n    if (!next) {\n      return; // no more elements\n    }\n\n    var value = next[0];\n    var time = next[1];\n    if (time < olderThen) {\n      obliviousSet.map.delete(value);\n    } else {\n      // We reached a value that is not old enough\n      return;\n    }\n  }\n}\nexport function now() {\n  return new Date().getTime();\n}","map":{"version":3,"names":["ObliviousSet","ttl","map","Map","_to","prototype","has","value","add","_this","set","now","setTimeout","removeTooOldValues","clear","obliviousSet","olderThen","iterator","Symbol","next","time","delete","Date","getTime"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/oblivious-set/dist/es/index.js"],"sourcesContent":["/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nvar ObliviousSet = /** @class */ (function () {\n    function ObliviousSet(ttl) {\n        this.ttl = ttl;\n        this.map = new Map();\n        /**\n         * Creating calls to setTimeout() is expensive,\n         * so we only do that if there is not timeout already open.\n         */\n        this._to = false;\n    }\n    ObliviousSet.prototype.has = function (value) {\n        return this.map.has(value);\n    };\n    ObliviousSet.prototype.add = function (value) {\n        var _this = this;\n        this.map.set(value, now());\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        if (!this._to) {\n            this._to = true;\n            setTimeout(function () {\n                _this._to = false;\n                removeTooOldValues(_this);\n            }, 0);\n        }\n    };\n    ObliviousSet.prototype.clear = function () {\n        this.map.clear();\n    };\n    return ObliviousSet;\n}());\nexport { ObliviousSet };\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(obliviousSet) {\n    var olderThen = now() - obliviousSet.ttl;\n    var iterator = obliviousSet.map[Symbol.iterator]();\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n        var next = iterator.next().value;\n        if (!next) {\n            return; // no more elements\n        }\n        var value = next[0];\n        var time = next[1];\n        if (time < olderThen) {\n            obliviousSet.map.delete(value);\n        }\n        else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\nexport function now() {\n    return new Date().getTime();\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,IAAIA,YAAY,GAAG,aAAe,YAAY;EAC1C,SAASA,YAAYA,CAACC,GAAG,EAAE;IACvB,IAAI,CAACA,GAAG,GAAGA,GAAG;IACd,IAAI,CAACC,GAAG,GAAG,IAAIC,GAAG,CAAC,CAAC;IACpB;AACR;AACA;AACA;IACQ,IAAI,CAACC,GAAG,GAAG,KAAK;EACpB;EACAJ,YAAY,CAACK,SAAS,CAACC,GAAG,GAAG,UAAUC,KAAK,EAAE;IAC1C,OAAO,IAAI,CAACL,GAAG,CAACI,GAAG,CAACC,KAAK,CAAC;EAC9B,CAAC;EACDP,YAAY,CAACK,SAAS,CAACG,GAAG,GAAG,UAAUD,KAAK,EAAE;IAC1C,IAAIE,KAAK,GAAG,IAAI;IAChB,IAAI,CAACP,GAAG,CAACQ,GAAG,CAACH,KAAK,EAAEI,GAAG,CAAC,CAAC,CAAC;IAC1B;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAAC,IAAI,CAACP,GAAG,EAAE;MACX,IAAI,CAACA,GAAG,GAAG,IAAI;MACfQ,UAAU,CAAC,YAAY;QACnBH,KAAK,CAACL,GAAG,GAAG,KAAK;QACjBS,kBAAkB,CAACJ,KAAK,CAAC;MAC7B,CAAC,EAAE,CAAC,CAAC;IACT;EACJ,CAAC;EACDT,YAAY,CAACK,SAAS,CAACS,KAAK,GAAG,YAAY;IACvC,IAAI,CAACZ,GAAG,CAACY,KAAK,CAAC,CAAC;EACpB,CAAC;EACD,OAAOd,YAAY;AACvB,CAAC,CAAC,CAAE;AACJ,SAASA,YAAY;AACrB;AACA;AACA;AACA;AACA,OAAO,SAASa,kBAAkBA,CAACE,YAAY,EAAE;EAC7C,IAAIC,SAAS,GAAGL,GAAG,CAAC,CAAC,GAAGI,YAAY,CAACd,GAAG;EACxC,IAAIgB,QAAQ,GAAGF,YAAY,CAACb,GAAG,CAACgB,MAAM,CAACD,QAAQ,CAAC,CAAC,CAAC;EAClD;AACJ;AACA;AACA;EACI,OAAO,IAAI,EAAE;IACT,IAAIE,IAAI,GAAGF,QAAQ,CAACE,IAAI,CAAC,CAAC,CAACZ,KAAK;IAChC,IAAI,CAACY,IAAI,EAAE;MACP,OAAO,CAAC;IACZ;;IACA,IAAIZ,KAAK,GAAGY,IAAI,CAAC,CAAC,CAAC;IACnB,IAAIC,IAAI,GAAGD,IAAI,CAAC,CAAC,CAAC;IAClB,IAAIC,IAAI,GAAGJ,SAAS,EAAE;MAClBD,YAAY,CAACb,GAAG,CAACmB,MAAM,CAACd,KAAK,CAAC;IAClC,CAAC,MACI;MACD;MACA;IACJ;EACJ;AACJ;AACA,OAAO,SAASI,GAAGA,CAAA,EAAG;EAClB,OAAO,IAAIW,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;AAC/B"},"metadata":{},"sourceType":"module","externalDependencies":[]}