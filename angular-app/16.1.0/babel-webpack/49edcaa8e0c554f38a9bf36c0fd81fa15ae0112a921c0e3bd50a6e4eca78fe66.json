{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Subject } from 'rxjs';\nimport { now, PROMISE_RESOLVE_VOID, RX_META_LWT_MINIMUM, sortDocumentsByLastWriteTime, lastOfArray, ensureNotFalsy, appendToArray } from '../utils';\nimport { closeDexieDb, fromDexieToStorage, fromStorageToDexie, getDexieDbWithTables, getDocsInDb, RX_STORAGE_NAME_DEXIE } from './dexie-helper';\nimport { dexieCount, dexieQuery } from './dexie-query';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport { categorizeBulkWriteRows } from '../../rx-storage-helper';\nimport { addRxStorageMultiInstanceSupport } from '../../rx-storage-multiinstance';\nimport { newRxError } from '../../rx-error';\nvar instanceId = now();\nexport var RxStorageInstanceDexie = /*#__PURE__*/function () {\n  function RxStorageInstanceDexie(storage, databaseName, collectionName, schema, internals, options, settings) {\n    this.changes$ = new Subject();\n    this.instanceId = instanceId++;\n    this.closed = false;\n    this.storage = storage;\n    this.databaseName = databaseName;\n    this.collectionName = collectionName;\n    this.schema = schema;\n    this.internals = internals;\n    this.options = options;\n    this.settings = settings;\n    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n  }\n  var _proto = RxStorageInstanceDexie.prototype;\n  _proto.bulkWrite = /*#__PURE__*/function () {\n    var _bulkWrite = _asyncToGenerator(function* (documentWrites, context) {\n      var _this = this;\n      ensureNotClosed(this);\n\n      /**\n       * Check some assumptions to ensure RxDB\n       * does not call the storage with an invalid write.\n       */\n      documentWrites.forEach(row => {\n        // ensure revision is set\n        if (!row.document._rev || row.previous && !row.previous._rev) {\n          throw newRxError('SNH', {\n            args: {\n              row\n            }\n          });\n        }\n      });\n      var state = yield this.internals;\n      var ret = {\n        success: {},\n        error: {}\n      };\n      var documentKeys = documentWrites.map(writeRow => writeRow.document[this.primaryPath]);\n      var categorized;\n      yield state.dexieDb.transaction('rw', state.dexieTable, state.dexieDeletedTable, /*#__PURE__*/_asyncToGenerator(function* () {\n        var docsInDbMap = new Map();\n        var docsInDbWithInternals = yield getDocsInDb(_this.internals, documentKeys);\n        docsInDbWithInternals.forEach(docWithDexieInternals => {\n          var doc = docWithDexieInternals ? fromDexieToStorage(docWithDexieInternals) : docWithDexieInternals;\n          if (doc) {\n            docsInDbMap.set(doc[_this.primaryPath], doc);\n          }\n          return doc;\n        });\n        categorized = categorizeBulkWriteRows(_this, _this.primaryPath, docsInDbMap, documentWrites, context);\n        ret.error = categorized.errors;\n\n        /**\n         * Batch up the database operations\n         * so we can later run them in bulk.\n         */\n        var bulkPutDocs = [];\n        var bulkRemoveDocs = [];\n        var bulkPutDeletedDocs = [];\n        var bulkRemoveDeletedDocs = [];\n        categorized.bulkInsertDocs.forEach(row => {\n          var docId = row.document[_this.primaryPath];\n          ret.success[docId] = row.document;\n          bulkPutDocs.push(row.document);\n        });\n        categorized.bulkUpdateDocs.forEach(row => {\n          var docId = row.document[_this.primaryPath];\n          ret.success[docId] = row.document;\n          if (row.document._deleted && row.previous && !row.previous._deleted) {\n            // newly deleted\n            bulkRemoveDocs.push(docId);\n            bulkPutDeletedDocs.push(row.document);\n          } else if (row.document._deleted && row.previous && row.previous._deleted) {\n            // deleted was modified but is still deleted\n            bulkPutDeletedDocs.push(row.document);\n          } else if (!row.document._deleted) {\n            // non-deleted was changed\n            bulkPutDocs.push(row.document);\n          } else {\n            throw newRxError('SNH', {\n              args: {\n                row\n              }\n            });\n          }\n        });\n        yield Promise.all([bulkPutDocs.length > 0 ? state.dexieTable.bulkPut(bulkPutDocs.map(d => fromStorageToDexie(d))) : PROMISE_RESOLVE_VOID, bulkRemoveDocs.length > 0 ? state.dexieTable.bulkDelete(bulkRemoveDocs) : PROMISE_RESOLVE_VOID, bulkPutDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkPut(bulkPutDeletedDocs.map(d => fromStorageToDexie(d))) : PROMISE_RESOLVE_VOID, bulkRemoveDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkDelete(bulkRemoveDeletedDocs) : PROMISE_RESOLVE_VOID]);\n      }));\n      categorized = ensureNotFalsy(categorized);\n      if (categorized.eventBulk.events.length > 0) {\n        var lastState = ensureNotFalsy(categorized.newestRow).document;\n        categorized.eventBulk.checkpoint = {\n          id: lastState[this.primaryPath],\n          lwt: lastState._meta.lwt\n        };\n        var endTime = now();\n        categorized.eventBulk.events.forEach(event => event.endTime = endTime);\n        this.changes$.next(categorized.eventBulk);\n      }\n      return ret;\n    });\n    function bulkWrite(_x, _x2) {\n      return _bulkWrite.apply(this, arguments);\n    }\n    return bulkWrite;\n  }();\n  _proto.findDocumentsById = /*#__PURE__*/function () {\n    var _findDocumentsById = _asyncToGenerator(function* (ids, deleted) {\n      var _this2 = this;\n      ensureNotClosed(this);\n      var state = yield this.internals;\n      var ret = {};\n      yield state.dexieDb.transaction('r', state.dexieTable, state.dexieDeletedTable, /*#__PURE__*/_asyncToGenerator(function* () {\n        var docsInDb;\n        if (deleted) {\n          docsInDb = yield getDocsInDb(_this2.internals, ids);\n        } else {\n          docsInDb = yield state.dexieTable.bulkGet(ids);\n        }\n        ids.forEach((id, idx) => {\n          var documentInDb = docsInDb[idx];\n          if (documentInDb && (!documentInDb._deleted || deleted)) {\n            ret[id] = fromDexieToStorage(documentInDb);\n          }\n        });\n      }));\n      return ret;\n    });\n    function findDocumentsById(_x3, _x4) {\n      return _findDocumentsById.apply(this, arguments);\n    }\n    return findDocumentsById;\n  }();\n  _proto.query = function query(preparedQuery) {\n    ensureNotClosed(this);\n    return dexieQuery(this, preparedQuery);\n  };\n  _proto.count = /*#__PURE__*/function () {\n    var _count = _asyncToGenerator(function* (preparedQuery) {\n      var result = yield dexieCount(this, preparedQuery);\n      return {\n        count: result,\n        mode: 'fast'\n      };\n    });\n    function count(_x5) {\n      return _count.apply(this, arguments);\n    }\n    return count;\n  }();\n  _proto.getChangedDocumentsSince = /*#__PURE__*/function () {\n    var _getChangedDocumentsSince = _asyncToGenerator(function* (limit, checkpoint) {\n      var _this3 = this;\n      ensureNotClosed(this);\n      var sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n      var sinceId = checkpoint ? checkpoint.id : '';\n      var state = yield this.internals;\n      var [changedDocsNormal, changedDocsDeleted] = yield Promise.all([state.dexieTable, state.dexieDeletedTable].map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (table) {\n          var query = table.where('[_meta.lwt+' + _this3.primaryPath + ']').above([sinceLwt, sinceId]).limit(limit);\n          var changedDocuments = yield query.toArray();\n          return changedDocuments.map(d => fromDexieToStorage(d));\n        });\n        return function (_x8) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      var changedDocs = changedDocsNormal.slice(0);\n      appendToArray(changedDocs, changedDocsDeleted);\n      changedDocs = sortDocumentsByLastWriteTime(this.primaryPath, changedDocs);\n      changedDocs = changedDocs.slice(0, limit);\n      var lastDoc = lastOfArray(changedDocs);\n      return {\n        documents: changedDocs,\n        checkpoint: lastDoc ? {\n          id: lastDoc[this.primaryPath],\n          lwt: lastDoc._meta.lwt\n        } : checkpoint ? checkpoint : {\n          id: '',\n          lwt: 0\n        }\n      };\n    });\n    function getChangedDocumentsSince(_x6, _x7) {\n      return _getChangedDocumentsSince.apply(this, arguments);\n    }\n    return getChangedDocumentsSince;\n  }();\n  _proto.remove = /*#__PURE__*/function () {\n    var _remove = _asyncToGenerator(function* () {\n      ensureNotClosed(this);\n      var state = yield this.internals;\n      yield Promise.all([state.dexieDeletedTable.clear(), state.dexieTable.clear()]);\n      return this.close();\n    });\n    function remove() {\n      return _remove.apply(this, arguments);\n    }\n    return remove;\n  }();\n  _proto.changeStream = function changeStream() {\n    ensureNotClosed(this);\n    return this.changes$.asObservable();\n  };\n  _proto.cleanup = /*#__PURE__*/function () {\n    var _cleanup = _asyncToGenerator(function* (minimumDeletedTime) {\n      var _this4 = this;\n      ensureNotClosed(this);\n      var state = yield this.internals;\n      yield state.dexieDb.transaction('rw', state.dexieDeletedTable, /*#__PURE__*/_asyncToGenerator(function* () {\n        var maxDeletionTime = now() - minimumDeletedTime;\n        var toRemove = yield state.dexieDeletedTable.where('_meta.lwt').below(maxDeletionTime).toArray();\n        var removeIds = toRemove.map(doc => doc[_this4.primaryPath]);\n        yield state.dexieDeletedTable.bulkDelete(removeIds);\n      }));\n\n      /**\n       * TODO instead of deleting all deleted docs at once,\n       * only clean up some of them and return false if there are more documents to clean up.\n       * This ensures that when many documents have to be purged,\n       * we do not block the more important tasks too long.\n       */\n      return true;\n    });\n    function cleanup(_x9) {\n      return _cleanup.apply(this, arguments);\n    }\n    return cleanup;\n  }();\n  _proto.getAttachmentData = function getAttachmentData(_documentId, _attachmentId, _digest) {\n    ensureNotClosed(this);\n    throw new Error('Attachments are not implemented in the dexie RxStorage. Make a pull request.');\n  };\n  _proto.close = function close() {\n    ensureNotClosed(this);\n    this.closed = true;\n    this.changes$.complete();\n    closeDexieDb(this.internals);\n    return PROMISE_RESOLVE_VOID;\n  };\n  _proto.conflictResultionTasks = function conflictResultionTasks() {\n    return new Subject();\n  };\n  _proto.resolveConflictResultionTask = /*#__PURE__*/function () {\n    var _resolveConflictResultionTask = _asyncToGenerator(function* (_taskSolution) {});\n    function resolveConflictResultionTask(_x10) {\n      return _resolveConflictResultionTask.apply(this, arguments);\n    }\n    return resolveConflictResultionTask;\n  }();\n  return RxStorageInstanceDexie;\n}();\nexport function createDexieStorageInstance(storage, params, settings) {\n  var internals = getDexieDbWithTables(params.databaseName, params.collectionName, settings, params.schema);\n  var instance = new RxStorageInstanceDexie(storage, params.databaseName, params.collectionName, params.schema, internals, params.options, settings);\n  addRxStorageMultiInstanceSupport(RX_STORAGE_NAME_DEXIE, params, instance);\n  return Promise.resolve(instance);\n}\nfunction ensureNotClosed(instance) {\n  if (instance.closed) {\n    throw new Error('RxStorageInstanceDexie is closed ' + instance.databaseName + '-' + instance.collectionName);\n  }\n}","map":{"version":3,"names":["Subject","now","PROMISE_RESOLVE_VOID","RX_META_LWT_MINIMUM","sortDocumentsByLastWriteTime","lastOfArray","ensureNotFalsy","appendToArray","closeDexieDb","fromDexieToStorage","fromStorageToDexie","getDexieDbWithTables","getDocsInDb","RX_STORAGE_NAME_DEXIE","dexieCount","dexieQuery","getPrimaryFieldOfPrimaryKey","categorizeBulkWriteRows","addRxStorageMultiInstanceSupport","newRxError","instanceId","RxStorageInstanceDexie","storage","databaseName","collectionName","schema","internals","options","settings","changes$","closed","primaryPath","primaryKey","_proto","prototype","bulkWrite","_bulkWrite","_asyncToGenerator","documentWrites","context","_this","ensureNotClosed","forEach","row","document","_rev","previous","args","state","ret","success","error","documentKeys","map","writeRow","categorized","dexieDb","transaction","dexieTable","dexieDeletedTable","docsInDbMap","Map","docsInDbWithInternals","docWithDexieInternals","doc","set","errors","bulkPutDocs","bulkRemoveDocs","bulkPutDeletedDocs","bulkRemoveDeletedDocs","bulkInsertDocs","docId","push","bulkUpdateDocs","_deleted","Promise","all","length","bulkPut","d","bulkDelete","eventBulk","events","lastState","newestRow","checkpoint","id","lwt","_meta","endTime","event","next","_x","_x2","apply","arguments","findDocumentsById","_findDocumentsById","ids","deleted","_this2","docsInDb","bulkGet","idx","documentInDb","_x3","_x4","query","preparedQuery","count","_count","result","mode","_x5","getChangedDocumentsSince","_getChangedDocumentsSince","limit","_this3","sinceLwt","sinceId","changedDocsNormal","changedDocsDeleted","_ref3","table","where","above","changedDocuments","toArray","_x8","changedDocs","slice","lastDoc","documents","_x6","_x7","remove","_remove","clear","close","changeStream","asObservable","cleanup","_cleanup","minimumDeletedTime","_this4","maxDeletionTime","toRemove","below","removeIds","_x9","getAttachmentData","_documentId","_attachmentId","_digest","Error","complete","conflictResultionTasks","resolveConflictResultionTask","_resolveConflictResultionTask","_taskSolution","_x10","createDexieStorageInstance","params","instance","resolve"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/plugins/storage-dexie/rx-storage-instance-dexie.js"],"sourcesContent":["import { Subject } from 'rxjs';\nimport { now, PROMISE_RESOLVE_VOID, RX_META_LWT_MINIMUM, sortDocumentsByLastWriteTime, lastOfArray, ensureNotFalsy, appendToArray } from '../utils';\nimport { closeDexieDb, fromDexieToStorage, fromStorageToDexie, getDexieDbWithTables, getDocsInDb, RX_STORAGE_NAME_DEXIE } from './dexie-helper';\nimport { dexieCount, dexieQuery } from './dexie-query';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport { categorizeBulkWriteRows } from '../../rx-storage-helper';\nimport { addRxStorageMultiInstanceSupport } from '../../rx-storage-multiinstance';\nimport { newRxError } from '../../rx-error';\nvar instanceId = now();\nexport var RxStorageInstanceDexie = /*#__PURE__*/function () {\n  function RxStorageInstanceDexie(storage, databaseName, collectionName, schema, internals, options, settings) {\n    this.changes$ = new Subject();\n    this.instanceId = instanceId++;\n    this.closed = false;\n    this.storage = storage;\n    this.databaseName = databaseName;\n    this.collectionName = collectionName;\n    this.schema = schema;\n    this.internals = internals;\n    this.options = options;\n    this.settings = settings;\n    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n  }\n  var _proto = RxStorageInstanceDexie.prototype;\n  _proto.bulkWrite = async function bulkWrite(documentWrites, context) {\n    ensureNotClosed(this);\n\n    /**\n     * Check some assumptions to ensure RxDB\n     * does not call the storage with an invalid write.\n     */\n    documentWrites.forEach(row => {\n      // ensure revision is set\n      if (!row.document._rev || row.previous && !row.previous._rev) {\n        throw newRxError('SNH', {\n          args: {\n            row\n          }\n        });\n      }\n    });\n    var state = await this.internals;\n    var ret = {\n      success: {},\n      error: {}\n    };\n    var documentKeys = documentWrites.map(writeRow => writeRow.document[this.primaryPath]);\n    var categorized;\n    await state.dexieDb.transaction('rw', state.dexieTable, state.dexieDeletedTable, async () => {\n      var docsInDbMap = new Map();\n      var docsInDbWithInternals = await getDocsInDb(this.internals, documentKeys);\n      docsInDbWithInternals.forEach(docWithDexieInternals => {\n        var doc = docWithDexieInternals ? fromDexieToStorage(docWithDexieInternals) : docWithDexieInternals;\n        if (doc) {\n          docsInDbMap.set(doc[this.primaryPath], doc);\n        }\n        return doc;\n      });\n      categorized = categorizeBulkWriteRows(this, this.primaryPath, docsInDbMap, documentWrites, context);\n      ret.error = categorized.errors;\n\n      /**\n       * Batch up the database operations\n       * so we can later run them in bulk.\n       */\n      var bulkPutDocs = [];\n      var bulkRemoveDocs = [];\n      var bulkPutDeletedDocs = [];\n      var bulkRemoveDeletedDocs = [];\n      categorized.bulkInsertDocs.forEach(row => {\n        var docId = row.document[this.primaryPath];\n        ret.success[docId] = row.document;\n        bulkPutDocs.push(row.document);\n      });\n      categorized.bulkUpdateDocs.forEach(row => {\n        var docId = row.document[this.primaryPath];\n        ret.success[docId] = row.document;\n        if (row.document._deleted && row.previous && !row.previous._deleted) {\n          // newly deleted\n          bulkRemoveDocs.push(docId);\n          bulkPutDeletedDocs.push(row.document);\n        } else if (row.document._deleted && row.previous && row.previous._deleted) {\n          // deleted was modified but is still deleted\n          bulkPutDeletedDocs.push(row.document);\n        } else if (!row.document._deleted) {\n          // non-deleted was changed\n          bulkPutDocs.push(row.document);\n        } else {\n          throw newRxError('SNH', {\n            args: {\n              row\n            }\n          });\n        }\n      });\n      await Promise.all([bulkPutDocs.length > 0 ? state.dexieTable.bulkPut(bulkPutDocs.map(d => fromStorageToDexie(d))) : PROMISE_RESOLVE_VOID, bulkRemoveDocs.length > 0 ? state.dexieTable.bulkDelete(bulkRemoveDocs) : PROMISE_RESOLVE_VOID, bulkPutDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkPut(bulkPutDeletedDocs.map(d => fromStorageToDexie(d))) : PROMISE_RESOLVE_VOID, bulkRemoveDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkDelete(bulkRemoveDeletedDocs) : PROMISE_RESOLVE_VOID]);\n    });\n    categorized = ensureNotFalsy(categorized);\n    if (categorized.eventBulk.events.length > 0) {\n      var lastState = ensureNotFalsy(categorized.newestRow).document;\n      categorized.eventBulk.checkpoint = {\n        id: lastState[this.primaryPath],\n        lwt: lastState._meta.lwt\n      };\n      var endTime = now();\n      categorized.eventBulk.events.forEach(event => event.endTime = endTime);\n      this.changes$.next(categorized.eventBulk);\n    }\n    return ret;\n  };\n  _proto.findDocumentsById = async function findDocumentsById(ids, deleted) {\n    ensureNotClosed(this);\n    var state = await this.internals;\n    var ret = {};\n    await state.dexieDb.transaction('r', state.dexieTable, state.dexieDeletedTable, async () => {\n      var docsInDb;\n      if (deleted) {\n        docsInDb = await getDocsInDb(this.internals, ids);\n      } else {\n        docsInDb = await state.dexieTable.bulkGet(ids);\n      }\n      ids.forEach((id, idx) => {\n        var documentInDb = docsInDb[idx];\n        if (documentInDb && (!documentInDb._deleted || deleted)) {\n          ret[id] = fromDexieToStorage(documentInDb);\n        }\n      });\n    });\n    return ret;\n  };\n  _proto.query = function query(preparedQuery) {\n    ensureNotClosed(this);\n    return dexieQuery(this, preparedQuery);\n  };\n  _proto.count = async function count(preparedQuery) {\n    var result = await dexieCount(this, preparedQuery);\n    return {\n      count: result,\n      mode: 'fast'\n    };\n  };\n  _proto.getChangedDocumentsSince = async function getChangedDocumentsSince(limit, checkpoint) {\n    ensureNotClosed(this);\n    var sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n    var sinceId = checkpoint ? checkpoint.id : '';\n    var state = await this.internals;\n    var [changedDocsNormal, changedDocsDeleted] = await Promise.all([state.dexieTable, state.dexieDeletedTable].map(async table => {\n      var query = table.where('[_meta.lwt+' + this.primaryPath + ']').above([sinceLwt, sinceId]).limit(limit);\n      var changedDocuments = await query.toArray();\n      return changedDocuments.map(d => fromDexieToStorage(d));\n    }));\n    var changedDocs = changedDocsNormal.slice(0);\n    appendToArray(changedDocs, changedDocsDeleted);\n    changedDocs = sortDocumentsByLastWriteTime(this.primaryPath, changedDocs);\n    changedDocs = changedDocs.slice(0, limit);\n    var lastDoc = lastOfArray(changedDocs);\n    return {\n      documents: changedDocs,\n      checkpoint: lastDoc ? {\n        id: lastDoc[this.primaryPath],\n        lwt: lastDoc._meta.lwt\n      } : checkpoint ? checkpoint : {\n        id: '',\n        lwt: 0\n      }\n    };\n  };\n  _proto.remove = async function remove() {\n    ensureNotClosed(this);\n    var state = await this.internals;\n    await Promise.all([state.dexieDeletedTable.clear(), state.dexieTable.clear()]);\n    return this.close();\n  };\n  _proto.changeStream = function changeStream() {\n    ensureNotClosed(this);\n    return this.changes$.asObservable();\n  };\n  _proto.cleanup = async function cleanup(minimumDeletedTime) {\n    ensureNotClosed(this);\n    var state = await this.internals;\n    await state.dexieDb.transaction('rw', state.dexieDeletedTable, async () => {\n      var maxDeletionTime = now() - minimumDeletedTime;\n      var toRemove = await state.dexieDeletedTable.where('_meta.lwt').below(maxDeletionTime).toArray();\n      var removeIds = toRemove.map(doc => doc[this.primaryPath]);\n      await state.dexieDeletedTable.bulkDelete(removeIds);\n    });\n\n    /**\n     * TODO instead of deleting all deleted docs at once,\n     * only clean up some of them and return false if there are more documents to clean up.\n     * This ensures that when many documents have to be purged,\n     * we do not block the more important tasks too long.\n     */\n    return true;\n  };\n  _proto.getAttachmentData = function getAttachmentData(_documentId, _attachmentId, _digest) {\n    ensureNotClosed(this);\n    throw new Error('Attachments are not implemented in the dexie RxStorage. Make a pull request.');\n  };\n  _proto.close = function close() {\n    ensureNotClosed(this);\n    this.closed = true;\n    this.changes$.complete();\n    closeDexieDb(this.internals);\n    return PROMISE_RESOLVE_VOID;\n  };\n  _proto.conflictResultionTasks = function conflictResultionTasks() {\n    return new Subject();\n  };\n  _proto.resolveConflictResultionTask = async function resolveConflictResultionTask(_taskSolution) {};\n  return RxStorageInstanceDexie;\n}();\nexport function createDexieStorageInstance(storage, params, settings) {\n  var internals = getDexieDbWithTables(params.databaseName, params.collectionName, settings, params.schema);\n  var instance = new RxStorageInstanceDexie(storage, params.databaseName, params.collectionName, params.schema, internals, params.options, settings);\n  addRxStorageMultiInstanceSupport(RX_STORAGE_NAME_DEXIE, params, instance);\n  return Promise.resolve(instance);\n}\nfunction ensureNotClosed(instance) {\n  if (instance.closed) {\n    throw new Error('RxStorageInstanceDexie is closed ' + instance.databaseName + '-' + instance.collectionName);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}