{"ast":null,"code":"import _asyncToGenerator from \"/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * These files contain the replication protocol.\n * It can be used to replicated RxStorageInstances or RxCollections\n * or even to do a client(s)-server replication.\n */\n\nimport { BehaviorSubject, combineLatest, filter, firstValueFrom, map, Subject } from 'rxjs';\nimport { getPrimaryFieldOfPrimaryKey } from '../rx-schema-helper';\nimport { ensureNotFalsy, PROMISE_RESOLVE_VOID } from '../plugins/utils';\nimport { getCheckpointKey } from './checkpoint';\nimport { startReplicationDownstream } from './downstream';\nimport { docStateToWriteDoc, writeDocToDocState } from './helper';\nimport { startReplicationUpstream } from './upstream';\nexport * from './checkpoint';\nexport * from './downstream';\nexport * from './upstream';\nexport * from './meta-instance';\nexport * from './conflicts';\nexport * from './helper';\nexport function replicateRxStorageInstance(input) {\n  var checkpointKey = getCheckpointKey(input);\n  var state = {\n    primaryPath: getPrimaryFieldOfPrimaryKey(input.forkInstance.schema.primaryKey),\n    input,\n    checkpointKey,\n    downstreamBulkWriteFlag: 'replication-downstream-' + checkpointKey,\n    events: {\n      canceled: new BehaviorSubject(false),\n      active: {\n        down: new BehaviorSubject(true),\n        up: new BehaviorSubject(true)\n      },\n      processed: {\n        down: new Subject(),\n        up: new Subject()\n      },\n      resolvedConflicts: new Subject(),\n      error: new Subject()\n    },\n    stats: {\n      down: {\n        addNewTask: 0,\n        downstreamProcessChanges: 0,\n        downstreamResyncOnce: 0,\n        masterChangeStreamEmit: 0,\n        persistFromMaster: 0\n      },\n      up: {\n        forkChangeStreamEmit: 0,\n        persistToMaster: 0,\n        persistToMasterConflictWrites: 0,\n        persistToMasterHadConflicts: 0,\n        processTasks: 0,\n        upstreamInitialSync: 0\n      }\n    },\n    firstSyncDone: {\n      down: new BehaviorSubject(false),\n      up: new BehaviorSubject(false)\n    },\n    streamQueue: {\n      down: PROMISE_RESOLVE_VOID,\n      up: PROMISE_RESOLVE_VOID\n    },\n    checkpointQueue: PROMISE_RESOLVE_VOID,\n    lastCheckpointDoc: {}\n  };\n  startReplicationDownstream(state);\n  startReplicationUpstream(state);\n  return state;\n}\nexport function awaitRxStorageReplicationFirstInSync(state) {\n  return firstValueFrom(combineLatest([state.firstSyncDone.down.pipe(filter(v => !!v)), state.firstSyncDone.up.pipe(filter(v => !!v))])).then(() => {});\n}\nexport function awaitRxStorageReplicationInSync(replicationState) {\n  return Promise.all([replicationState.streamQueue.up, replicationState.streamQueue.down, replicationState.checkpointQueue]);\n}\nexport function awaitRxStorageReplicationIdle(_x) {\n  return _awaitRxStorageReplicationIdle.apply(this, arguments);\n}\nfunction _awaitRxStorageReplicationIdle() {\n  _awaitRxStorageReplicationIdle = _asyncToGenerator(function* (state) {\n    yield awaitRxStorageReplicationFirstInSync(state);\n    while (true) {\n      var {\n        down,\n        up\n      } = state.streamQueue;\n      yield Promise.all([up, down]);\n      /**\n       * If the Promises have not been reassigned\n       * after awaiting them, we know that the replication\n       * is in idle state at this point in time.\n       */\n      if (down === state.streamQueue.down && up === state.streamQueue.up) {\n        return;\n      }\n    }\n  });\n  return _awaitRxStorageReplicationIdle.apply(this, arguments);\n}\nexport function rxStorageInstanceToReplicationHandler(instance, conflictHandler, databaseInstanceToken) {\n  var primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n  var replicationHandler = {\n    masterChangeStream$: instance.changeStream().pipe(map(eventBulk => {\n      var ret = {\n        checkpoint: eventBulk.checkpoint,\n        documents: eventBulk.events.map(event => {\n          return writeDocToDocState(ensureNotFalsy(event.documentData));\n        })\n      };\n      return ret;\n    })),\n    masterChangesSince(checkpoint, batchSize) {\n      return instance.getChangedDocumentsSince(batchSize, checkpoint).then(result => {\n        return {\n          checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,\n          documents: result.documents.map(d => writeDocToDocState(d))\n        };\n      });\n    },\n    masterWrite(rows) {\n      return _asyncToGenerator(function* () {\n        var rowById = {};\n        rows.forEach(row => {\n          var docId = row.newDocumentState[primaryPath];\n          rowById[docId] = row;\n        });\n        var ids = Object.keys(rowById);\n        var masterDocsState = yield instance.findDocumentsById(ids, true);\n        var conflicts = [];\n        var writeRows = [];\n        yield Promise.all(Object.entries(rowById).map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* ([id, row]) {\n            var masterState = masterDocsState[id];\n            if (!masterState) {\n              writeRows.push({\n                document: docStateToWriteDoc(databaseInstanceToken, row.newDocumentState)\n              });\n            } else if (masterState && !row.assumedMasterState) {\n              conflicts.push(writeDocToDocState(masterState));\n            } else if ((yield conflictHandler({\n              realMasterState: writeDocToDocState(masterState),\n              newDocumentState: ensureNotFalsy(row.assumedMasterState)\n            }, 'rxStorageInstanceToReplicationHandler-masterWrite')).isEqual === true) {\n              writeRows.push({\n                previous: masterState,\n                document: docStateToWriteDoc(databaseInstanceToken, row.newDocumentState, masterState)\n              });\n            } else {\n              conflicts.push(writeDocToDocState(masterState));\n            }\n          });\n          return function (_x2) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n        if (writeRows.length > 0) {\n          var result = yield instance.bulkWrite(writeRows, 'replication-master-write');\n          Object.values(result.error).forEach(err => {\n            if (err.status !== 409) {\n              throw new Error('non conflict error');\n            } else {\n              conflicts.push(writeDocToDocState(ensureNotFalsy(err.documentInDb)));\n            }\n          });\n        }\n        return conflicts;\n      })();\n    }\n  };\n  return replicationHandler;\n}\nexport function cancelRxStorageReplication(replicationState) {\n  replicationState.events.canceled.next(true);\n  replicationState.events.active.up.complete();\n  replicationState.events.active.down.complete();\n  replicationState.events.processed.up.complete();\n  replicationState.events.processed.down.complete();\n  replicationState.events.resolvedConflicts.complete();\n  replicationState.events.canceled.complete();\n}","map":{"version":3,"names":["BehaviorSubject","combineLatest","filter","firstValueFrom","map","Subject","getPrimaryFieldOfPrimaryKey","ensureNotFalsy","PROMISE_RESOLVE_VOID","getCheckpointKey","startReplicationDownstream","docStateToWriteDoc","writeDocToDocState","startReplicationUpstream","replicateRxStorageInstance","input","checkpointKey","state","primaryPath","forkInstance","schema","primaryKey","downstreamBulkWriteFlag","events","canceled","active","down","up","processed","resolvedConflicts","error","stats","addNewTask","downstreamProcessChanges","downstreamResyncOnce","masterChangeStreamEmit","persistFromMaster","forkChangeStreamEmit","persistToMaster","persistToMasterConflictWrites","persistToMasterHadConflicts","processTasks","upstreamInitialSync","firstSyncDone","streamQueue","checkpointQueue","lastCheckpointDoc","awaitRxStorageReplicationFirstInSync","pipe","v","then","awaitRxStorageReplicationInSync","replicationState","Promise","all","awaitRxStorageReplicationIdle","_x","_awaitRxStorageReplicationIdle","apply","arguments","_asyncToGenerator","rxStorageInstanceToReplicationHandler","instance","conflictHandler","databaseInstanceToken","replicationHandler","masterChangeStream$","changeStream","eventBulk","ret","checkpoint","documents","event","documentData","masterChangesSince","batchSize","getChangedDocumentsSince","result","length","d","masterWrite","rows","rowById","forEach","row","docId","newDocumentState","ids","Object","keys","masterDocsState","findDocumentsById","conflicts","writeRows","entries","_ref","id","masterState","push","document","assumedMasterState","realMasterState","isEqual","previous","_x2","bulkWrite","values","err","status","Error","documentInDb","cancelRxStorageReplication","next","complete"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/replication-protocol/index.js"],"sourcesContent":["/**\n * These files contain the replication protocol.\n * It can be used to replicated RxStorageInstances or RxCollections\n * or even to do a client(s)-server replication.\n */\n\nimport { BehaviorSubject, combineLatest, filter, firstValueFrom, map, Subject } from 'rxjs';\nimport { getPrimaryFieldOfPrimaryKey } from '../rx-schema-helper';\nimport { ensureNotFalsy, PROMISE_RESOLVE_VOID } from '../plugins/utils';\nimport { getCheckpointKey } from './checkpoint';\nimport { startReplicationDownstream } from './downstream';\nimport { docStateToWriteDoc, writeDocToDocState } from './helper';\nimport { startReplicationUpstream } from './upstream';\nexport * from './checkpoint';\nexport * from './downstream';\nexport * from './upstream';\nexport * from './meta-instance';\nexport * from './conflicts';\nexport * from './helper';\nexport function replicateRxStorageInstance(input) {\n  var checkpointKey = getCheckpointKey(input);\n  var state = {\n    primaryPath: getPrimaryFieldOfPrimaryKey(input.forkInstance.schema.primaryKey),\n    input,\n    checkpointKey,\n    downstreamBulkWriteFlag: 'replication-downstream-' + checkpointKey,\n    events: {\n      canceled: new BehaviorSubject(false),\n      active: {\n        down: new BehaviorSubject(true),\n        up: new BehaviorSubject(true)\n      },\n      processed: {\n        down: new Subject(),\n        up: new Subject()\n      },\n      resolvedConflicts: new Subject(),\n      error: new Subject()\n    },\n    stats: {\n      down: {\n        addNewTask: 0,\n        downstreamProcessChanges: 0,\n        downstreamResyncOnce: 0,\n        masterChangeStreamEmit: 0,\n        persistFromMaster: 0\n      },\n      up: {\n        forkChangeStreamEmit: 0,\n        persistToMaster: 0,\n        persistToMasterConflictWrites: 0,\n        persistToMasterHadConflicts: 0,\n        processTasks: 0,\n        upstreamInitialSync: 0\n      }\n    },\n    firstSyncDone: {\n      down: new BehaviorSubject(false),\n      up: new BehaviorSubject(false)\n    },\n    streamQueue: {\n      down: PROMISE_RESOLVE_VOID,\n      up: PROMISE_RESOLVE_VOID\n    },\n    checkpointQueue: PROMISE_RESOLVE_VOID,\n    lastCheckpointDoc: {}\n  };\n  startReplicationDownstream(state);\n  startReplicationUpstream(state);\n  return state;\n}\nexport function awaitRxStorageReplicationFirstInSync(state) {\n  return firstValueFrom(combineLatest([state.firstSyncDone.down.pipe(filter(v => !!v)), state.firstSyncDone.up.pipe(filter(v => !!v))])).then(() => {});\n}\nexport function awaitRxStorageReplicationInSync(replicationState) {\n  return Promise.all([replicationState.streamQueue.up, replicationState.streamQueue.down, replicationState.checkpointQueue]);\n}\nexport async function awaitRxStorageReplicationIdle(state) {\n  await awaitRxStorageReplicationFirstInSync(state);\n  while (true) {\n    var {\n      down,\n      up\n    } = state.streamQueue;\n    await Promise.all([up, down]);\n    /**\n     * If the Promises have not been reassigned\n     * after awaiting them, we know that the replication\n     * is in idle state at this point in time.\n     */\n    if (down === state.streamQueue.down && up === state.streamQueue.up) {\n      return;\n    }\n  }\n}\nexport function rxStorageInstanceToReplicationHandler(instance, conflictHandler, databaseInstanceToken) {\n  var primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n  var replicationHandler = {\n    masterChangeStream$: instance.changeStream().pipe(map(eventBulk => {\n      var ret = {\n        checkpoint: eventBulk.checkpoint,\n        documents: eventBulk.events.map(event => {\n          return writeDocToDocState(ensureNotFalsy(event.documentData));\n        })\n      };\n      return ret;\n    })),\n    masterChangesSince(checkpoint, batchSize) {\n      return instance.getChangedDocumentsSince(batchSize, checkpoint).then(result => {\n        return {\n          checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,\n          documents: result.documents.map(d => writeDocToDocState(d))\n        };\n      });\n    },\n    async masterWrite(rows) {\n      var rowById = {};\n      rows.forEach(row => {\n        var docId = row.newDocumentState[primaryPath];\n        rowById[docId] = row;\n      });\n      var ids = Object.keys(rowById);\n      var masterDocsState = await instance.findDocumentsById(ids, true);\n      var conflicts = [];\n      var writeRows = [];\n      await Promise.all(Object.entries(rowById).map(async ([id, row]) => {\n        var masterState = masterDocsState[id];\n        if (!masterState) {\n          writeRows.push({\n            document: docStateToWriteDoc(databaseInstanceToken, row.newDocumentState)\n          });\n        } else if (masterState && !row.assumedMasterState) {\n          conflicts.push(writeDocToDocState(masterState));\n        } else if ((await conflictHandler({\n          realMasterState: writeDocToDocState(masterState),\n          newDocumentState: ensureNotFalsy(row.assumedMasterState)\n        }, 'rxStorageInstanceToReplicationHandler-masterWrite')).isEqual === true) {\n          writeRows.push({\n            previous: masterState,\n            document: docStateToWriteDoc(databaseInstanceToken, row.newDocumentState, masterState)\n          });\n        } else {\n          conflicts.push(writeDocToDocState(masterState));\n        }\n      }));\n      if (writeRows.length > 0) {\n        var result = await instance.bulkWrite(writeRows, 'replication-master-write');\n        Object.values(result.error).forEach(err => {\n          if (err.status !== 409) {\n            throw new Error('non conflict error');\n          } else {\n            conflicts.push(writeDocToDocState(ensureNotFalsy(err.documentInDb)));\n          }\n        });\n      }\n      return conflicts;\n    }\n  };\n  return replicationHandler;\n}\nexport function cancelRxStorageReplication(replicationState) {\n  replicationState.events.canceled.next(true);\n  replicationState.events.active.up.complete();\n  replicationState.events.active.down.complete();\n  replicationState.events.processed.up.complete();\n  replicationState.events.processed.down.complete();\n  replicationState.events.resolvedConflicts.complete();\n  replicationState.events.canceled.complete();\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;;AAEA,SAASA,eAAe,EAAEC,aAAa,EAAEC,MAAM,EAAEC,cAAc,EAAEC,GAAG,EAAEC,OAAO,QAAQ,MAAM;AAC3F,SAASC,2BAA2B,QAAQ,qBAAqB;AACjE,SAASC,cAAc,EAAEC,oBAAoB,QAAQ,kBAAkB;AACvE,SAASC,gBAAgB,QAAQ,cAAc;AAC/C,SAASC,0BAA0B,QAAQ,cAAc;AACzD,SAASC,kBAAkB,EAAEC,kBAAkB,QAAQ,UAAU;AACjE,SAASC,wBAAwB,QAAQ,YAAY;AACrD,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,YAAY;AAC1B,cAAc,iBAAiB;AAC/B,cAAc,aAAa;AAC3B,cAAc,UAAU;AACxB,OAAO,SAASC,0BAA0BA,CAACC,KAAK,EAAE;EAChD,IAAIC,aAAa,GAAGP,gBAAgB,CAACM,KAAK,CAAC;EAC3C,IAAIE,KAAK,GAAG;IACVC,WAAW,EAAEZ,2BAA2B,CAACS,KAAK,CAACI,YAAY,CAACC,MAAM,CAACC,UAAU,CAAC;IAC9EN,KAAK;IACLC,aAAa;IACbM,uBAAuB,EAAE,yBAAyB,GAAGN,aAAa;IAClEO,MAAM,EAAE;MACNC,QAAQ,EAAE,IAAIxB,eAAe,CAAC,KAAK,CAAC;MACpCyB,MAAM,EAAE;QACNC,IAAI,EAAE,IAAI1B,eAAe,CAAC,IAAI,CAAC;QAC/B2B,EAAE,EAAE,IAAI3B,eAAe,CAAC,IAAI;MAC9B,CAAC;MACD4B,SAAS,EAAE;QACTF,IAAI,EAAE,IAAIrB,OAAO,CAAC,CAAC;QACnBsB,EAAE,EAAE,IAAItB,OAAO,CAAC;MAClB,CAAC;MACDwB,iBAAiB,EAAE,IAAIxB,OAAO,CAAC,CAAC;MAChCyB,KAAK,EAAE,IAAIzB,OAAO,CAAC;IACrB,CAAC;IACD0B,KAAK,EAAE;MACLL,IAAI,EAAE;QACJM,UAAU,EAAE,CAAC;QACbC,wBAAwB,EAAE,CAAC;QAC3BC,oBAAoB,EAAE,CAAC;QACvBC,sBAAsB,EAAE,CAAC;QACzBC,iBAAiB,EAAE;MACrB,CAAC;MACDT,EAAE,EAAE;QACFU,oBAAoB,EAAE,CAAC;QACvBC,eAAe,EAAE,CAAC;QAClBC,6BAA6B,EAAE,CAAC;QAChCC,2BAA2B,EAAE,CAAC;QAC9BC,YAAY,EAAE,CAAC;QACfC,mBAAmB,EAAE;MACvB;IACF,CAAC;IACDC,aAAa,EAAE;MACbjB,IAAI,EAAE,IAAI1B,eAAe,CAAC,KAAK,CAAC;MAChC2B,EAAE,EAAE,IAAI3B,eAAe,CAAC,KAAK;IAC/B,CAAC;IACD4C,WAAW,EAAE;MACXlB,IAAI,EAAElB,oBAAoB;MAC1BmB,EAAE,EAAEnB;IACN,CAAC;IACDqC,eAAe,EAAErC,oBAAoB;IACrCsC,iBAAiB,EAAE,CAAC;EACtB,CAAC;EACDpC,0BAA0B,CAACO,KAAK,CAAC;EACjCJ,wBAAwB,CAACI,KAAK,CAAC;EAC/B,OAAOA,KAAK;AACd;AACA,OAAO,SAAS8B,oCAAoCA,CAAC9B,KAAK,EAAE;EAC1D,OAAOd,cAAc,CAACF,aAAa,CAAC,CAACgB,KAAK,CAAC0B,aAAa,CAACjB,IAAI,CAACsB,IAAI,CAAC9C,MAAM,CAAC+C,CAAC,IAAI,CAAC,CAACA,CAAC,CAAC,CAAC,EAAEhC,KAAK,CAAC0B,aAAa,CAAChB,EAAE,CAACqB,IAAI,CAAC9C,MAAM,CAAC+C,CAAC,IAAI,CAAC,CAACA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;AACvJ;AACA,OAAO,SAASC,+BAA+BA,CAACC,gBAAgB,EAAE;EAChE,OAAOC,OAAO,CAACC,GAAG,CAAC,CAACF,gBAAgB,CAACR,WAAW,CAACjB,EAAE,EAAEyB,gBAAgB,CAACR,WAAW,CAAClB,IAAI,EAAE0B,gBAAgB,CAACP,eAAe,CAAC,CAAC;AAC5H;AACA,gBAAsBU,6BAA6BA,CAAAC,EAAA;EAAA,OAAAC,8BAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAiBlD,SAAAF,+BAAA;EAAAA,8BAAA,GAAAG,iBAAA,CAjBM,WAA6C3C,KAAK,EAAE;IACzD,MAAM8B,oCAAoC,CAAC9B,KAAK,CAAC;IACjD,OAAO,IAAI,EAAE;MACX,IAAI;QACFS,IAAI;QACJC;MACF,CAAC,GAAGV,KAAK,CAAC2B,WAAW;MACrB,MAAMS,OAAO,CAACC,GAAG,CAAC,CAAC3B,EAAE,EAAED,IAAI,CAAC,CAAC;MAC7B;AACJ;AACA;AACA;AACA;MACI,IAAIA,IAAI,KAAKT,KAAK,CAAC2B,WAAW,CAAClB,IAAI,IAAIC,EAAE,KAAKV,KAAK,CAAC2B,WAAW,CAACjB,EAAE,EAAE;QAClE;MACF;IACF;EACF,CAAC;EAAA,OAAA8B,8BAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AACD,OAAO,SAASE,qCAAqCA,CAACC,QAAQ,EAAEC,eAAe,EAAEC,qBAAqB,EAAE;EACtG,IAAI9C,WAAW,GAAGZ,2BAA2B,CAACwD,QAAQ,CAAC1C,MAAM,CAACC,UAAU,CAAC;EACzE,IAAI4C,kBAAkB,GAAG;IACvBC,mBAAmB,EAAEJ,QAAQ,CAACK,YAAY,CAAC,CAAC,CAACnB,IAAI,CAAC5C,GAAG,CAACgE,SAAS,IAAI;MACjE,IAAIC,GAAG,GAAG;QACRC,UAAU,EAAEF,SAAS,CAACE,UAAU;QAChCC,SAAS,EAAEH,SAAS,CAAC7C,MAAM,CAACnB,GAAG,CAACoE,KAAK,IAAI;UACvC,OAAO5D,kBAAkB,CAACL,cAAc,CAACiE,KAAK,CAACC,YAAY,CAAC,CAAC;QAC/D,CAAC;MACH,CAAC;MACD,OAAOJ,GAAG;IACZ,CAAC,CAAC,CAAC;IACHK,kBAAkBA,CAACJ,UAAU,EAAEK,SAAS,EAAE;MACxC,OAAOb,QAAQ,CAACc,wBAAwB,CAACD,SAAS,EAAEL,UAAU,CAAC,CAACpB,IAAI,CAAC2B,MAAM,IAAI;QAC7E,OAAO;UACLP,UAAU,EAAEO,MAAM,CAACN,SAAS,CAACO,MAAM,GAAG,CAAC,GAAGD,MAAM,CAACP,UAAU,GAAGA,UAAU;UACxEC,SAAS,EAAEM,MAAM,CAACN,SAAS,CAACnE,GAAG,CAAC2E,CAAC,IAAInE,kBAAkB,CAACmE,CAAC,CAAC;QAC5D,CAAC;MACH,CAAC,CAAC;IACJ,CAAC;IACKC,WAAWA,CAACC,IAAI,EAAE;MAAA,OAAArB,iBAAA;QACtB,IAAIsB,OAAO,GAAG,CAAC,CAAC;QAChBD,IAAI,CAACE,OAAO,CAACC,GAAG,IAAI;UAClB,IAAIC,KAAK,GAAGD,GAAG,CAACE,gBAAgB,CAACpE,WAAW,CAAC;UAC7CgE,OAAO,CAACG,KAAK,CAAC,GAAGD,GAAG;QACtB,CAAC,CAAC;QACF,IAAIG,GAAG,GAAGC,MAAM,CAACC,IAAI,CAACP,OAAO,CAAC;QAC9B,IAAIQ,eAAe,SAAS5B,QAAQ,CAAC6B,iBAAiB,CAACJ,GAAG,EAAE,IAAI,CAAC;QACjE,IAAIK,SAAS,GAAG,EAAE;QAClB,IAAIC,SAAS,GAAG,EAAE;QAClB,MAAMxC,OAAO,CAACC,GAAG,CAACkC,MAAM,CAACM,OAAO,CAACZ,OAAO,CAAC,CAAC9E,GAAG;UAAA,IAAA2F,IAAA,GAAAnC,iBAAA,CAAC,WAAO,CAACoC,EAAE,EAAEZ,GAAG,CAAC,EAAK;YACjE,IAAIa,WAAW,GAAGP,eAAe,CAACM,EAAE,CAAC;YACrC,IAAI,CAACC,WAAW,EAAE;cAChBJ,SAAS,CAACK,IAAI,CAAC;gBACbC,QAAQ,EAAExF,kBAAkB,CAACqD,qBAAqB,EAAEoB,GAAG,CAACE,gBAAgB;cAC1E,CAAC,CAAC;YACJ,CAAC,MAAM,IAAIW,WAAW,IAAI,CAACb,GAAG,CAACgB,kBAAkB,EAAE;cACjDR,SAAS,CAACM,IAAI,CAACtF,kBAAkB,CAACqF,WAAW,CAAC,CAAC;YACjD,CAAC,MAAM,IAAI,OAAOlC,eAAe,CAAC;cAChCsC,eAAe,EAAEzF,kBAAkB,CAACqF,WAAW,CAAC;cAChDX,gBAAgB,EAAE/E,cAAc,CAAC6E,GAAG,CAACgB,kBAAkB;YACzD,CAAC,EAAE,mDAAmD,CAAC,EAAEE,OAAO,KAAK,IAAI,EAAE;cACzET,SAAS,CAACK,IAAI,CAAC;gBACbK,QAAQ,EAAEN,WAAW;gBACrBE,QAAQ,EAAExF,kBAAkB,CAACqD,qBAAqB,EAAEoB,GAAG,CAACE,gBAAgB,EAAEW,WAAW;cACvF,CAAC,CAAC;YACJ,CAAC,MAAM;cACLL,SAAS,CAACM,IAAI,CAACtF,kBAAkB,CAACqF,WAAW,CAAC,CAAC;YACjD;UACF,CAAC;UAAA,iBAAAO,GAAA;YAAA,OAAAT,IAAA,CAAArC,KAAA,OAAAC,SAAA;UAAA;QAAA,IAAC,CAAC;QACH,IAAIkC,SAAS,CAACf,MAAM,GAAG,CAAC,EAAE;UACxB,IAAID,MAAM,SAASf,QAAQ,CAAC2C,SAAS,CAACZ,SAAS,EAAE,0BAA0B,CAAC;UAC5EL,MAAM,CAACkB,MAAM,CAAC7B,MAAM,CAAC/C,KAAK,CAAC,CAACqD,OAAO,CAACwB,GAAG,IAAI;YACzC,IAAIA,GAAG,CAACC,MAAM,KAAK,GAAG,EAAE;cACtB,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;YACvC,CAAC,MAAM;cACLjB,SAAS,CAACM,IAAI,CAACtF,kBAAkB,CAACL,cAAc,CAACoG,GAAG,CAACG,YAAY,CAAC,CAAC,CAAC;YACtE;UACF,CAAC,CAAC;QACJ;QACA,OAAOlB,SAAS;MAAC;IACnB;EACF,CAAC;EACD,OAAO3B,kBAAkB;AAC3B;AACA,OAAO,SAAS8C,0BAA0BA,CAAC3D,gBAAgB,EAAE;EAC3DA,gBAAgB,CAAC7B,MAAM,CAACC,QAAQ,CAACwF,IAAI,CAAC,IAAI,CAAC;EAC3C5D,gBAAgB,CAAC7B,MAAM,CAACE,MAAM,CAACE,EAAE,CAACsF,QAAQ,CAAC,CAAC;EAC5C7D,gBAAgB,CAAC7B,MAAM,CAACE,MAAM,CAACC,IAAI,CAACuF,QAAQ,CAAC,CAAC;EAC9C7D,gBAAgB,CAAC7B,MAAM,CAACK,SAAS,CAACD,EAAE,CAACsF,QAAQ,CAAC,CAAC;EAC/C7D,gBAAgB,CAAC7B,MAAM,CAACK,SAAS,CAACF,IAAI,CAACuF,QAAQ,CAAC,CAAC;EACjD7D,gBAAgB,CAAC7B,MAAM,CAACM,iBAAiB,CAACoF,QAAQ,CAAC,CAAC;EACpD7D,gBAAgB,CAAC7B,MAAM,CAACC,QAAQ,CAACyF,QAAQ,CAAC,CAAC;AAC7C"},"metadata":{},"sourceType":"module","externalDependencies":[]}