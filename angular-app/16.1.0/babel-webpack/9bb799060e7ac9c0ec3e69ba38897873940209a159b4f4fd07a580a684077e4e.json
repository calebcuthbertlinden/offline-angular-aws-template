{"ast":null,"code":"import { LOGICAL_OPERATORS } from './query-planner';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nimport { clone, firstPropertyNameOfObject, toArray, isMaybeReadonlyArray, parseRegex, flatClone, objectPathMonad } from './plugins/utils';\nimport { DEFAULT_COMPARATOR as mingoSortComparator } from 'mingo/util';\nimport { newRxError } from './rx-error';\nimport { getMingoQuery } from './rx-query-mingo';\n\n/**\n * Normalize the query to ensure we have all fields set\n * and queries that represent the same query logic are detected as equal by the caching.\n */\nexport function normalizeMangoQuery(schema, mangoQuery) {\n  var primaryKey = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n  mangoQuery = flatClone(mangoQuery);\n\n  // regex normalization must run before deep clone because deep clone cannot clone RegExp\n  if (mangoQuery.selector) {\n    mangoQuery.selector = normalizeQueryRegex(mangoQuery.selector);\n  }\n  var normalizedMangoQuery = clone(mangoQuery);\n  if (typeof normalizedMangoQuery.skip !== 'number') {\n    normalizedMangoQuery.skip = 0;\n  }\n  if (!normalizedMangoQuery.selector) {\n    normalizedMangoQuery.selector = {};\n  } else {\n    normalizedMangoQuery.selector = normalizedMangoQuery.selector;\n    /**\n     * In mango query, it is possible to have an\n     * equals comparison by directly assigning a value\n     * to a property, without the '$eq' operator.\n     * Like:\n     * selector: {\n     *   foo: 'bar'\n     * }\n     * For normalization, we have to normalize this\n     * so our checks can perform properly.\n     *\n     *\n     * TODO this must work recursive with nested queries that\n     * contain multiple selectors via $and or $or etc.\n     */\n    Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n      if (typeof matcher !== 'object' || matcher === null) {\n        normalizedMangoQuery.selector[field] = {\n          $eq: matcher\n        };\n      }\n    });\n  }\n\n  /**\n   * Ensure that if an index is specified,\n   * the primaryKey is inside of it.\n   */\n  if (normalizedMangoQuery.index) {\n    var indexAr = toArray(normalizedMangoQuery.index);\n    if (!indexAr.includes(primaryKey)) {\n      indexAr.push(primaryKey);\n    }\n    normalizedMangoQuery.index = indexAr;\n  }\n\n  /**\n   * To ensure a deterministic sorting,\n   * we have to ensure the primary key is always part\n   * of the sort query.\n   * Primary sorting is added as last sort parameter,\n   * similar to how we add the primary key to indexes that do not have it.\n   *\n   */\n  if (!normalizedMangoQuery.sort) {\n    /**\n     * If no sort is given at all,\n     * we can assume that the user does not care about sort order at al.\n     *\n     * we cannot just use the primary key as sort parameter\n     * because it would likely cause the query to run over the primary key index\n     * which has a bad performance in most cases.\n     */\n    if (normalizedMangoQuery.index) {\n      normalizedMangoQuery.sort = normalizedMangoQuery.index.map(field => {\n        return {\n          [field]: 'asc'\n        };\n      });\n    } else {\n      /**\n       * Find the index that best matches the fields with the logical operators\n       */\n      if (schema.indexes) {\n        var fieldsWithLogicalOperator = new Set();\n        Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n          var hasLogical = false;\n          if (typeof matcher === 'object' && matcher !== null) {\n            hasLogical = !!Object.keys(matcher).find(operator => LOGICAL_OPERATORS.has(operator));\n          } else {\n            hasLogical = true;\n          }\n          if (hasLogical) {\n            fieldsWithLogicalOperator.add(field);\n          }\n        });\n        var currentFieldsAmount = -1;\n        var currentBestIndexForSort;\n        schema.indexes.forEach(index => {\n          var useIndex = isMaybeReadonlyArray(index) ? index : [index];\n          var firstWrongIndex = useIndex.findIndex(indexField => !fieldsWithLogicalOperator.has(indexField));\n          if (firstWrongIndex > 0 && firstWrongIndex > currentFieldsAmount) {\n            currentFieldsAmount = firstWrongIndex;\n            currentBestIndexForSort = useIndex;\n          }\n        });\n        if (currentBestIndexForSort) {\n          normalizedMangoQuery.sort = currentBestIndexForSort.map(field => {\n            return {\n              [field]: 'asc'\n            };\n          });\n        }\n      }\n\n      /**\n       * Fall back to the primary key as sort order\n       * if no better one has been found\n       */\n      if (!normalizedMangoQuery.sort) {\n        normalizedMangoQuery.sort = [{\n          [primaryKey]: 'asc'\n        }];\n      }\n    }\n  } else {\n    var isPrimaryInSort = normalizedMangoQuery.sort.find(p => firstPropertyNameOfObject(p) === primaryKey);\n    if (!isPrimaryInSort) {\n      normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);\n      normalizedMangoQuery.sort.push({\n        [primaryKey]: 'asc'\n      });\n    }\n  }\n  return normalizedMangoQuery;\n}\n\n/**\n * @recursive\n * @mutates the input so that we do not have to deep clone\n */\nexport function normalizeQueryRegex(selector) {\n  if (typeof selector !== 'object' || selector === null) {\n    return selector;\n  }\n  var keys = Object.keys(selector);\n  var ret = {};\n  keys.forEach(key => {\n    var value = selector[key];\n    if (key === '$regex' && value instanceof RegExp) {\n      var parsed = parseRegex(value);\n      ret.$regex = parsed.pattern;\n      ret.$options = parsed.flags;\n    } else if (Array.isArray(value)) {\n      ret[key] = value.map(item => normalizeQueryRegex(item));\n    } else {\n      ret[key] = normalizeQueryRegex(value);\n    }\n  });\n  return ret;\n}\n\n/**\n * Returns the sort-comparator,\n * which is able to sort documents in the same way\n * a query over the db would do.\n */\nexport function getSortComparator(schema, query) {\n  if (!query.sort) {\n    throw newRxError('SNH', {\n      query\n    });\n  }\n  var sortParts = [];\n  query.sort.forEach(sortBlock => {\n    var key = Object.keys(sortBlock)[0];\n    var direction = Object.values(sortBlock)[0];\n    sortParts.push({\n      key,\n      direction,\n      getValueFn: objectPathMonad(key)\n    });\n  });\n  var fun = (a, b) => {\n    for (var i = 0; i < sortParts.length; ++i) {\n      var sortPart = sortParts[i];\n      var valueA = sortPart.getValueFn(a);\n      var valueB = sortPart.getValueFn(b);\n      if (valueA !== valueB) {\n        var ret = sortPart.direction === 'asc' ? mingoSortComparator(valueA, valueB) : mingoSortComparator(valueB, valueA);\n        return ret;\n      }\n    }\n  };\n  return fun;\n}\n\n/**\n * Returns a function\n * that can be used to check if a document\n * matches the query.\n */\nexport function getQueryMatcher(_schema, query) {\n  if (!query.sort) {\n    throw newRxError('SNH', {\n      query\n    });\n  }\n  var mingoQuery = getMingoQuery(query.selector);\n  var fun = doc => {\n    if (doc._deleted) {\n      return false;\n    }\n    var cursor = mingoQuery.find([doc]);\n    var next = cursor.next();\n    if (next) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  return fun;\n}","map":{"version":3,"names":["LOGICAL_OPERATORS","getPrimaryFieldOfPrimaryKey","clone","firstPropertyNameOfObject","toArray","isMaybeReadonlyArray","parseRegex","flatClone","objectPathMonad","DEFAULT_COMPARATOR","mingoSortComparator","newRxError","getMingoQuery","normalizeMangoQuery","schema","mangoQuery","primaryKey","selector","normalizeQueryRegex","normalizedMangoQuery","skip","Object","entries","forEach","field","matcher","$eq","index","indexAr","includes","push","sort","map","indexes","fieldsWithLogicalOperator","Set","hasLogical","keys","find","operator","has","add","currentFieldsAmount","currentBestIndexForSort","useIndex","firstWrongIndex","findIndex","indexField","isPrimaryInSort","p","slice","ret","key","value","RegExp","parsed","$regex","pattern","$options","flags","Array","isArray","item","getSortComparator","query","sortParts","sortBlock","direction","values","getValueFn","fun","a","b","i","length","sortPart","valueA","valueB","getQueryMatcher","_schema","mingoQuery","doc","_deleted","cursor","next"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/rx-query-helper.js"],"sourcesContent":["import { LOGICAL_OPERATORS } from './query-planner';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper';\nimport { clone, firstPropertyNameOfObject, toArray, isMaybeReadonlyArray, parseRegex, flatClone, objectPathMonad } from './plugins/utils';\nimport { DEFAULT_COMPARATOR as mingoSortComparator } from 'mingo/util';\nimport { newRxError } from './rx-error';\nimport { getMingoQuery } from './rx-query-mingo';\n\n/**\n * Normalize the query to ensure we have all fields set\n * and queries that represent the same query logic are detected as equal by the caching.\n */\nexport function normalizeMangoQuery(schema, mangoQuery) {\n  var primaryKey = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n  mangoQuery = flatClone(mangoQuery);\n\n  // regex normalization must run before deep clone because deep clone cannot clone RegExp\n  if (mangoQuery.selector) {\n    mangoQuery.selector = normalizeQueryRegex(mangoQuery.selector);\n  }\n  var normalizedMangoQuery = clone(mangoQuery);\n  if (typeof normalizedMangoQuery.skip !== 'number') {\n    normalizedMangoQuery.skip = 0;\n  }\n  if (!normalizedMangoQuery.selector) {\n    normalizedMangoQuery.selector = {};\n  } else {\n    normalizedMangoQuery.selector = normalizedMangoQuery.selector;\n    /**\n     * In mango query, it is possible to have an\n     * equals comparison by directly assigning a value\n     * to a property, without the '$eq' operator.\n     * Like:\n     * selector: {\n     *   foo: 'bar'\n     * }\n     * For normalization, we have to normalize this\n     * so our checks can perform properly.\n     *\n     *\n     * TODO this must work recursive with nested queries that\n     * contain multiple selectors via $and or $or etc.\n     */\n    Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n      if (typeof matcher !== 'object' || matcher === null) {\n        normalizedMangoQuery.selector[field] = {\n          $eq: matcher\n        };\n      }\n    });\n  }\n\n  /**\n   * Ensure that if an index is specified,\n   * the primaryKey is inside of it.\n   */\n  if (normalizedMangoQuery.index) {\n    var indexAr = toArray(normalizedMangoQuery.index);\n    if (!indexAr.includes(primaryKey)) {\n      indexAr.push(primaryKey);\n    }\n    normalizedMangoQuery.index = indexAr;\n  }\n\n  /**\n   * To ensure a deterministic sorting,\n   * we have to ensure the primary key is always part\n   * of the sort query.\n   * Primary sorting is added as last sort parameter,\n   * similar to how we add the primary key to indexes that do not have it.\n   *\n   */\n  if (!normalizedMangoQuery.sort) {\n    /**\n     * If no sort is given at all,\n     * we can assume that the user does not care about sort order at al.\n     *\n     * we cannot just use the primary key as sort parameter\n     * because it would likely cause the query to run over the primary key index\n     * which has a bad performance in most cases.\n     */\n    if (normalizedMangoQuery.index) {\n      normalizedMangoQuery.sort = normalizedMangoQuery.index.map(field => {\n        return {\n          [field]: 'asc'\n        };\n      });\n    } else {\n      /**\n       * Find the index that best matches the fields with the logical operators\n       */\n      if (schema.indexes) {\n        var fieldsWithLogicalOperator = new Set();\n        Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n          var hasLogical = false;\n          if (typeof matcher === 'object' && matcher !== null) {\n            hasLogical = !!Object.keys(matcher).find(operator => LOGICAL_OPERATORS.has(operator));\n          } else {\n            hasLogical = true;\n          }\n          if (hasLogical) {\n            fieldsWithLogicalOperator.add(field);\n          }\n        });\n        var currentFieldsAmount = -1;\n        var currentBestIndexForSort;\n        schema.indexes.forEach(index => {\n          var useIndex = isMaybeReadonlyArray(index) ? index : [index];\n          var firstWrongIndex = useIndex.findIndex(indexField => !fieldsWithLogicalOperator.has(indexField));\n          if (firstWrongIndex > 0 && firstWrongIndex > currentFieldsAmount) {\n            currentFieldsAmount = firstWrongIndex;\n            currentBestIndexForSort = useIndex;\n          }\n        });\n        if (currentBestIndexForSort) {\n          normalizedMangoQuery.sort = currentBestIndexForSort.map(field => {\n            return {\n              [field]: 'asc'\n            };\n          });\n        }\n      }\n\n      /**\n       * Fall back to the primary key as sort order\n       * if no better one has been found\n       */\n      if (!normalizedMangoQuery.sort) {\n        normalizedMangoQuery.sort = [{\n          [primaryKey]: 'asc'\n        }];\n      }\n    }\n  } else {\n    var isPrimaryInSort = normalizedMangoQuery.sort.find(p => firstPropertyNameOfObject(p) === primaryKey);\n    if (!isPrimaryInSort) {\n      normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);\n      normalizedMangoQuery.sort.push({\n        [primaryKey]: 'asc'\n      });\n    }\n  }\n  return normalizedMangoQuery;\n}\n\n/**\n * @recursive\n * @mutates the input so that we do not have to deep clone\n */\nexport function normalizeQueryRegex(selector) {\n  if (typeof selector !== 'object' || selector === null) {\n    return selector;\n  }\n  var keys = Object.keys(selector);\n  var ret = {};\n  keys.forEach(key => {\n    var value = selector[key];\n    if (key === '$regex' && value instanceof RegExp) {\n      var parsed = parseRegex(value);\n      ret.$regex = parsed.pattern;\n      ret.$options = parsed.flags;\n    } else if (Array.isArray(value)) {\n      ret[key] = value.map(item => normalizeQueryRegex(item));\n    } else {\n      ret[key] = normalizeQueryRegex(value);\n    }\n  });\n  return ret;\n}\n\n/**\n * Returns the sort-comparator,\n * which is able to sort documents in the same way\n * a query over the db would do.\n */\nexport function getSortComparator(schema, query) {\n  if (!query.sort) {\n    throw newRxError('SNH', {\n      query\n    });\n  }\n  var sortParts = [];\n  query.sort.forEach(sortBlock => {\n    var key = Object.keys(sortBlock)[0];\n    var direction = Object.values(sortBlock)[0];\n    sortParts.push({\n      key,\n      direction,\n      getValueFn: objectPathMonad(key)\n    });\n  });\n  var fun = (a, b) => {\n    for (var i = 0; i < sortParts.length; ++i) {\n      var sortPart = sortParts[i];\n      var valueA = sortPart.getValueFn(a);\n      var valueB = sortPart.getValueFn(b);\n      if (valueA !== valueB) {\n        var ret = sortPart.direction === 'asc' ? mingoSortComparator(valueA, valueB) : mingoSortComparator(valueB, valueA);\n        return ret;\n      }\n    }\n  };\n  return fun;\n}\n\n/**\n * Returns a function\n * that can be used to check if a document\n * matches the query.\n */\nexport function getQueryMatcher(_schema, query) {\n  if (!query.sort) {\n    throw newRxError('SNH', {\n      query\n    });\n  }\n  var mingoQuery = getMingoQuery(query.selector);\n  var fun = doc => {\n    if (doc._deleted) {\n      return false;\n    }\n    var cursor = mingoQuery.find([doc]);\n    var next = cursor.next();\n    if (next) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  return fun;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}