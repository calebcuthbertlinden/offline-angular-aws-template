{"ast":null,"code":"/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\n\nimport { getFromMapOrCreate, nextTick, now, requestIdlePromise } from './plugins/utils';\nexport var QueryCache = /*#__PURE__*/function () {\n  function QueryCache() {\n    this._map = new Map();\n  }\n  var _proto = QueryCache.prototype;\n  /**\n   * check if an equal query is in the cache,\n   * if true, return the cached one,\n   * if false, save the given one and return it\n   */\n  _proto.getByQuery = function getByQuery(rxQuery) {\n    var stringRep = rxQuery.toString();\n    return getFromMapOrCreate(this._map, stringRep, () => rxQuery);\n  };\n  return QueryCache;\n}();\nexport function createQueryCache() {\n  return new QueryCache();\n}\nexport function uncacheRxQuery(queryCache, rxQuery) {\n  rxQuery.uncached = true;\n  var stringRep = rxQuery.toString();\n  queryCache._map.delete(stringRep);\n}\nexport function countRxQuerySubscribers(rxQuery) {\n  return rxQuery.refCount$.observers.length;\n}\nexport var DEFAULT_TRY_TO_KEEP_MAX = 100;\nexport var DEFAULT_UNEXECUTED_LIFETIME = 30 * 1000;\n\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\nexport var defaultCacheReplacementPolicyMonad = (tryToKeepMax, unExecutedLifetime) => (_collection, queryCache) => {\n  if (queryCache._map.size < tryToKeepMax) {\n    return;\n  }\n  var minUnExecutedLifetime = now() - unExecutedLifetime;\n  var maybeUncache = [];\n  var queriesInCache = Array.from(queryCache._map.values());\n  for (var rxQuery of queriesInCache) {\n    // filter out queries with subscribers\n    if (countRxQuerySubscribers(rxQuery) > 0) {\n      continue;\n    }\n    // directly uncache queries that never executed and are older then unExecutedLifetime\n    if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n      uncacheRxQuery(queryCache, rxQuery);\n      continue;\n    }\n    maybeUncache.push(rxQuery);\n  }\n  var mustUncache = maybeUncache.length - tryToKeepMax;\n  if (mustUncache <= 0) {\n    return;\n  }\n  var sortedByLastUsage = maybeUncache.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);\n  var toRemove = sortedByLastUsage.slice(0, mustUncache);\n  toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));\n};\nexport var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETIME);\nexport var COLLECTIONS_WITH_RUNNING_CLEANUP = new WeakSet();\n\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\nexport function triggerCacheReplacement(rxCollection) {\n  if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {\n    // already started\n    return;\n  }\n  COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);\n\n  /**\n   * Do not run directly to not reduce result latency of a new query\n   */\n  nextTick() // wait at least one tick\n  .then(() => requestIdlePromise(200)) // and then wait for the CPU to be idle\n  .then(() => {\n    if (!rxCollection.destroyed) {\n      rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n    }\n    COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);\n  });\n}","map":{"version":3,"names":["getFromMapOrCreate","nextTick","now","requestIdlePromise","QueryCache","_map","Map","_proto","prototype","getByQuery","rxQuery","stringRep","toString","createQueryCache","uncacheRxQuery","queryCache","uncached","delete","countRxQuerySubscribers","refCount$","observers","length","DEFAULT_TRY_TO_KEEP_MAX","DEFAULT_UNEXECUTED_LIFETIME","defaultCacheReplacementPolicyMonad","tryToKeepMax","unExecutedLifetime","_collection","size","minUnExecutedLifetime","maybeUncache","queriesInCache","Array","from","values","_lastEnsureEqual","_creationTime","push","mustUncache","sortedByLastUsage","sort","a","b","toRemove","slice","forEach","defaultCacheReplacementPolicy","COLLECTIONS_WITH_RUNNING_CLEANUP","WeakSet","triggerCacheReplacement","rxCollection","has","add","then","destroyed","cacheReplacementPolicy","_queryCache"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/rxdb/dist/es/query-cache.js"],"sourcesContent":["/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\n\nimport { getFromMapOrCreate, nextTick, now, requestIdlePromise } from './plugins/utils';\nexport var QueryCache = /*#__PURE__*/function () {\n  function QueryCache() {\n    this._map = new Map();\n  }\n  var _proto = QueryCache.prototype;\n  /**\n   * check if an equal query is in the cache,\n   * if true, return the cached one,\n   * if false, save the given one and return it\n   */\n  _proto.getByQuery = function getByQuery(rxQuery) {\n    var stringRep = rxQuery.toString();\n    return getFromMapOrCreate(this._map, stringRep, () => rxQuery);\n  };\n  return QueryCache;\n}();\nexport function createQueryCache() {\n  return new QueryCache();\n}\nexport function uncacheRxQuery(queryCache, rxQuery) {\n  rxQuery.uncached = true;\n  var stringRep = rxQuery.toString();\n  queryCache._map.delete(stringRep);\n}\nexport function countRxQuerySubscribers(rxQuery) {\n  return rxQuery.refCount$.observers.length;\n}\nexport var DEFAULT_TRY_TO_KEEP_MAX = 100;\nexport var DEFAULT_UNEXECUTED_LIFETIME = 30 * 1000;\n\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\nexport var defaultCacheReplacementPolicyMonad = (tryToKeepMax, unExecutedLifetime) => (_collection, queryCache) => {\n  if (queryCache._map.size < tryToKeepMax) {\n    return;\n  }\n  var minUnExecutedLifetime = now() - unExecutedLifetime;\n  var maybeUncache = [];\n  var queriesInCache = Array.from(queryCache._map.values());\n  for (var rxQuery of queriesInCache) {\n    // filter out queries with subscribers\n    if (countRxQuerySubscribers(rxQuery) > 0) {\n      continue;\n    }\n    // directly uncache queries that never executed and are older then unExecutedLifetime\n    if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n      uncacheRxQuery(queryCache, rxQuery);\n      continue;\n    }\n    maybeUncache.push(rxQuery);\n  }\n  var mustUncache = maybeUncache.length - tryToKeepMax;\n  if (mustUncache <= 0) {\n    return;\n  }\n  var sortedByLastUsage = maybeUncache.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);\n  var toRemove = sortedByLastUsage.slice(0, mustUncache);\n  toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));\n};\nexport var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETIME);\nexport var COLLECTIONS_WITH_RUNNING_CLEANUP = new WeakSet();\n\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\nexport function triggerCacheReplacement(rxCollection) {\n  if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {\n    // already started\n    return;\n  }\n  COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);\n\n  /**\n   * Do not run directly to not reduce result latency of a new query\n   */\n  nextTick() // wait at least one tick\n  .then(() => requestIdlePromise(200)) // and then wait for the CPU to be idle\n  .then(() => {\n    if (!rxCollection.destroyed) {\n      rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n    }\n    COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}