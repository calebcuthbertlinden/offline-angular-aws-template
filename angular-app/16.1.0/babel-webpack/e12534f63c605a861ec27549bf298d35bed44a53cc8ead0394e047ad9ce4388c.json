{"ast":null,"code":"/*\nlet t = 0;\nwhile (t < 10000) {\n    const char = String.fromCharCode(t);\n    console.log(t + ' : ' + char);\n    t++;\n}\n*/\n/*\n\nTo have a really small string representation, we have to hack some stuff\nwhich makes is complicated but effective.\n\nRules for the string:\n- The string starts with a number like '23' that defines how many leaf-nodes we have\n- leaf nodes consist of two chars like 'ab'\n    - the first char is the id\n    - the second the value is a number you can get via String.charCodeAt()\n- Internal nodes have four chars like 'abcd'\n    - the first char is the id\n    - the second char is the id of the 0-branch\n    - the third char is the id of the 1-branch\n    - the last char is the id of the boolean-function (= level)\n- The last 3 chars of the string is the root node like 'abc'\n    - it looks like the internal-node but without the id (first char)\n\n*/\n// we use this because 39 is the quotes which causes problems\nexport const CHAR_CODE_OFFSET = 40; // String.fromCharCode(33) === ')'\nexport function getCharOfLevel(level) {\n  const charCode = CHAR_CODE_OFFSET + level;\n  return String.fromCharCode(charCode);\n}\nexport function getNumberOfChar(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode - CHAR_CODE_OFFSET;\n}\nexport function getCharOfValue(value) {\n  const charCode = CHAR_CODE_OFFSET + value;\n  return String.fromCharCode(charCode);\n}\nexport const FIRST_CHAR_CODE_FOR_ID = 97; // String.fromCharCode(97) === 'a'\nexport function getNextCharId(lastCode) {\n  // jump these codes because they look strange\n  if (lastCode >= 128 && lastCode <= 160) {\n    lastCode = 161;\n  }\n  const char = String.fromCharCode(lastCode);\n  return {\n    char,\n    nextCode: lastCode + 1\n  };\n}","map":{"version":3,"names":["CHAR_CODE_OFFSET","getCharOfLevel","level","charCode","String","fromCharCode","getNumberOfChar","char","charCodeAt","getCharOfValue","value","FIRST_CHAR_CODE_FOR_ID","getNextCharId","lastCode","nextCode"],"sources":["/Users/caleblinden/Documents/GitHub/mmf-poc/mmf-poc/node_modules/binary-decision-diagram/dist/es/minimal-string/string-format.js"],"sourcesContent":["/*\nlet t = 0;\nwhile (t < 10000) {\n    const char = String.fromCharCode(t);\n    console.log(t + ' : ' + char);\n    t++;\n}\n*/\n/*\n\nTo have a really small string representation, we have to hack some stuff\nwhich makes is complicated but effective.\n\nRules for the string:\n- The string starts with a number like '23' that defines how many leaf-nodes we have\n- leaf nodes consist of two chars like 'ab'\n    - the first char is the id\n    - the second the value is a number you can get via String.charCodeAt()\n- Internal nodes have four chars like 'abcd'\n    - the first char is the id\n    - the second char is the id of the 0-branch\n    - the third char is the id of the 1-branch\n    - the last char is the id of the boolean-function (= level)\n- The last 3 chars of the string is the root node like 'abc'\n    - it looks like the internal-node but without the id (first char)\n\n*/\n// we use this because 39 is the quotes which causes problems\nexport const CHAR_CODE_OFFSET = 40; // String.fromCharCode(33) === ')'\nexport function getCharOfLevel(level) {\n    const charCode = CHAR_CODE_OFFSET + level;\n    return String.fromCharCode(charCode);\n}\nexport function getNumberOfChar(char) {\n    const charCode = char.charCodeAt(0);\n    return charCode - CHAR_CODE_OFFSET;\n}\nexport function getCharOfValue(value) {\n    const charCode = CHAR_CODE_OFFSET + value;\n    return String.fromCharCode(charCode);\n}\nexport const FIRST_CHAR_CODE_FOR_ID = 97; // String.fromCharCode(97) === 'a'\nexport function getNextCharId(lastCode) {\n    // jump these codes because they look strange\n    if (lastCode >= 128 && lastCode <= 160) {\n        lastCode = 161;\n    }\n    const char = String.fromCharCode(lastCode);\n    return {\n        char,\n        nextCode: lastCode + 1\n    };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,gBAAgB,GAAG,EAAE,CAAC,CAAC;AACpC,OAAO,SAASC,cAAcA,CAACC,KAAK,EAAE;EAClC,MAAMC,QAAQ,GAAGH,gBAAgB,GAAGE,KAAK;EACzC,OAAOE,MAAM,CAACC,YAAY,CAACF,QAAQ,CAAC;AACxC;AACA,OAAO,SAASG,eAAeA,CAACC,IAAI,EAAE;EAClC,MAAMJ,QAAQ,GAAGI,IAAI,CAACC,UAAU,CAAC,CAAC,CAAC;EACnC,OAAOL,QAAQ,GAAGH,gBAAgB;AACtC;AACA,OAAO,SAASS,cAAcA,CAACC,KAAK,EAAE;EAClC,MAAMP,QAAQ,GAAGH,gBAAgB,GAAGU,KAAK;EACzC,OAAON,MAAM,CAACC,YAAY,CAACF,QAAQ,CAAC;AACxC;AACA,OAAO,MAAMQ,sBAAsB,GAAG,EAAE,CAAC,CAAC;AAC1C,OAAO,SAASC,aAAaA,CAACC,QAAQ,EAAE;EACpC;EACA,IAAIA,QAAQ,IAAI,GAAG,IAAIA,QAAQ,IAAI,GAAG,EAAE;IACpCA,QAAQ,GAAG,GAAG;EAClB;EACA,MAAMN,IAAI,GAAGH,MAAM,CAACC,YAAY,CAACQ,QAAQ,CAAC;EAC1C,OAAO;IACHN,IAAI;IACJO,QAAQ,EAAED,QAAQ,GAAG;EACzB,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}